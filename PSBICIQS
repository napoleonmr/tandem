!*FIX2.28  04/16/12  PSBICIS 60101TAL    SW60PSBI SW0G100  ?P                ***
!*FIX2.28  04/16/12  PSBICIS 60100TAL    SW60PSBI SW0G094  ?O                ***
!*FIX2.28  04/16/12  PSBICIS 6099 TAL    SW60PSBI SW0F236  ?N                ***
!*FIX2.28  04/16/12  PSBICIS 6098 TAL    SW60PSBI SW0F165  ?M                ***
!*FIX2.28  04/16/12  PSBICIS 6097 TAL    SW60PSBI SW0F059  ?L                ***
!*FIX2.28  04/16/12  PSBICIS 6096 TAL    SW60PSBI SW0F056  ?K                ***
!*FIX2.28  07/12/11  PSBICIS 6095 TAL    SW60PSBI SW0E246  ?J                ***
!*FIX2.28  07/12/11  PSBICIS 6094 TAL    SW60PSBI SW0E229  ?I                ***
!*FIX2.28  07/12/11  PSBICIS 6093 TAL    SW60PSBI SW0E111  ?H                ***
!*FIX2.28  07/12/11  PSBICIS 6092 TAL    SW60PSBI SW0E065  ?G                ***
!*FIX2.28  07/12/11  PSBICIS 6091 TAL    SW60PSBI SW0D517  ?F                ***
!*FIX2.28  07/12/11  PSBICIS 6090 TAL    SW60PSBI SW0D455  ?E                ***
!*FIX2.28  07/12/11  PSBICIS 6089 TAL    SW60PSBI SW0D380  ?D                ***
!*FIX2.28  07/12/11  PSBICIS 6088 TAL    SW60PSBI SW0D289  ?C                ***
!*FIX2.28  07/12/11  PSBICIS 6087 TAL    SW60PSBI SW0D283  ?B                ***
!*FIX2.28  07/12/11  PSBICIS 6086 TAL    SW60PSBI SW0D121  ?A                ***
!*FIX2.28  07/12/11  PSBICIS 6085 TAL    SW60PSBI SW0D047  9                 ***
!*FIX2.28  07/12/11  PSBICIS 6084 TAL    SW60PSBI SW0D042  8                 ***
!*FIX2.28  07/12/11  PSBICIS 6083 TAL    SW60PSBI SW0D001  7                 ***
!*FIX2.28  07/12/11  PSBICIS 6082 TAL    SW60PSBI SW0C689  6                 ***
!*FIX2.28  07/12/11  PSBICIS 6081 TAL    SW60PSBI SW0C451  5                 ***
!*FIX2.28  06/20/08  PSBICIS 6080 TAL    SW60PSBI SW0C411  4                 ***
!*FIX2.28  03/25/08  PSBICIS 6079 TAL    SW60PSBI SW0C286  3                 ***
!*FIX2.28  02/05/08  PSBICIS 6078 TAL    SW60PSBI SW0C109  2                 ***
!*FIX2.28  02/01/08  PSBICIS 6077 TAL    SW60PSBI SW0C102  1                 ***
!*FIX2.28  01/09/08  PSBICIS 6076 TAL    SW60PSBI SW0C043  0                 ***
!*FIX2.28  12/18/07  PSBICIS 6075 TAL    SW60PSBI SW0C017  }                 ***
!*FIX2.28  12/12/07  PSBICIS 6074 TAL    SW60PSBI SW0C013  {                 ***
!*FIX2.28  11/30/07  PSBICIS 6073 TAL    SW60PSBI SW0B608  )                 ***
!*FIX2.28  08/10/07  PSBICIS 6072 TAL    SW60PSBI SW0B463  (                 ***
!*FIX2.28  07/30/07  PSBICIS 6071 TAL    SW60PSBI SW0B438  ~                 ***
!*FIX2.28  07/16/07  PSBICIS 6070 TAL    SW60PSBI SW0B412  `                 ***
!*FIX2.28  06/27/07  PSBICIS 6069 TAL    SW60PSBI SW0B379  ^                 ***
!*FIX2.28  06/06/07  PSBICIS 6068 TAL    SW60PSBI SW0B350  ]                 ***
!*FIX2.28  04/26/07  PSBICIS 6067 TAL    SW60PSBI SW0B292  \                 ***
!*FIX2.28  03/07/07  PSBICIS 6066 TAL    SW60PSBI SW0B160  @                 ***
!*FIX2.28  12/08/06  PSBICIS 6065 TAL    SW60PSBI SW0B013  |                 ***
!*FIX2.26  10/11/06  PSBICIS 6064 TAL    SW60PSBI SW0A648  >                 ***
!*FIX2.26  07/28/06  PSBICIS 6063 TAL    SW60PSBI SW0A501  =                 ***
!*FIX2.26  07/17/06  PSBICIS 6062 TAL    SW60PSBI SW0A483  <                 ***
!*FIX2.26  04/27/06  PSBICIS 6061 TAL    SW60PSBI SW0A329  ;                 ***
!*FIX2.26  03/31/06  PSBICIS 6060 TAL    SW60PSBI SW0A297  :                 ***
!*FIX2.26  03/30/06  PSBICIS 6059 TAL    SW60PSBI SW0A296  -                 ***
!*FIX2.26  03/27/06  PSBICIS 6058 TAL    SW60PSBI SW0A286  +                 ***
!*FIX2.26  03/21/06  PSBICIS 6057 TAL    SW60PSBI SW0A273  *                 ***
!*FIX2.26  02/12/06  PSBICIS 6056 TAL    SW60PSBI SW0A166  &                 ***
!*FIX2.26  02/07/06  PSBICIS 6055 TAL    SW60PSBI SW0A142  %                 ***
!*FIX2.26  12/05/05  PSBICIS 6054 TAL    SW60PSBI SW0A028  $                 ***
!*FIX2.26  12/01/05  PSBICIS 6053 TAL    SW60PSBI SW0A023  #                 ***
!*FIX2.26  10/24/05  PSBICIS 6052 TAL    SW60PSBI SW09631  z                 ***
!*FIX2.24  10/10/05  PSBICIS 6051 TAL    SW60PSBI SW09600  y                 ***
!*FIX2.24  08/16/05  PSBICIS 6050 TAL    SW60PSBI SW09488  x                 ***
!*FIX2.24  07/12/05  PSBICIS 6049 TAL    SW60PSBI SW09438  w                 ***
!*FIX2.24  07/06/05  PSBICIS 6048 TAL    SW60PSBI SW09427  v                 ***
!*FIX2.24  06/10/05  PSBICIS 6047 TAL    SW60PSBI SW09414  u                 ***
!*FIX2.24  06/08/05  PSBICIS 6046 TAL    SW60PSBI SW09413  t                 ***
!*FIX2.24  06/06/05  PSBICIS 6045 TAL    SW60PSBI SW09411  s                 ***
!*FIX2.24  05/19/05  PSBICIS 6044 TAL    SW60PSBI SW09381  r                 ***
!*FIX2.24  07/13/04  PSBICIS 6043 TAL    SW60PSBI SW08436  q                 ***
!*FIX2.23  03/30/04  PSBICIS 6042 TAL    SW60PSBI SW08272  p                 ***
!*FIX2.23  02/11/04  PSBICIS 6041 TAL    SW60PSBI SW08159  o                 ***
!*FIX2.23  12/29/03  PSBICIS 6040 TAL    SW60PSBI SW08086  n                 ***
!*FIX2.23  10/31/03  PSBICIS 6039 TAL    SW60PSBI SW07455  m                 ***
!*FIX2.23  10/15/03  PSBICIS 6038 TAL    SW60PSBI SW07452  l                 ***
!*FIX2.23  09/08/03  PSBICIS 6037 TAL    SW60PSBI SW07380  k                 ***
!*FIX2.23  07/17/03  PSBICIS 6036 TAL    SW60PSBI SW07259  j                 ***
!*FIX2.23  06/11/03  PSBICIS 6035 TAL    SW60PSBI SW07199  i                 ***
!*FIX2.23  04/14/03  PSBICIS 6034 TAL    SW60PSBI SW07119  h                 ***
!*FIX2.23  02/11/03  PSBICIS 6033 TAL    SW60PSBI SW06305  g                 ***
!*FIX2.23  01/10/03  PSBICIS 6032 TAL    SW60PSBI SW06245  f                 ***
!*FIX2.23  12/19/02  PSBICIS 6031 TAL    SW60PSBI SW06216  e                 ***
!*FIX2.23  10/15/02  PSBICIS 6030 TAL    SW60PSBI SW06082  d                 ***
!*FIX2.22  06/26/02  PSBICIS 6029 TAL    SW60PSBI SW05462  c                 ***
!*FIX2.22  02/20/02  PSBICIS 6028 TAL    SW60PSBI SW05218  b                 ***
!*FIX2.19  01/11/02  PSBICIS 6027 TAL    SW60PSBI SW05129  a                 ***
!*FIX2.17  08/30/01  PSBICIS 6026 TAL    SW60PSBI SW05055  Z                 ***
!*FIX2.17  08/09/01  PSBICIS 6025 TAL    SW60PSBI SW05023  Y                 ***
!*FIX2.17  08/07/01  PSBICIS 6024 TAL    SW60PSBI SW05021  X                 ***
!*FIX2.15  06/27/01  PSBICIS 6023 TAL    SW60PSBI SW04468  W                 ***
!*FIX2.14  04/17/01  PSBICIS 6022 TAL    SW60PSBI SW04371  V                 ***
!*FIX2.14  03/23/01  PSBICIS 6021 TAL    SW60PSBI SW04324  U                 ***
!*FIX2.13  02/28/01  PSBICIS 6020 TAL    SW60PSBI SW04281  T                 ***
!*FIX2.13  02/20/01  PSBICIS 6019 TAL    SW60PSBI SW04277  S                 ***
!*SEQ0.04  11/01/00  PSBICIS 6018 TAL    SW60PSBI SW04000  R                 ***
!*FIX2.09  10/25/99  PSBICIS 5318 TAL    SW53PSBI SW04087  R                 ***
!*FIX2.07  06/29/99  PSBICIS 5317 TAL    SW53PSBI SW04029  Q                 ***
!*SYNC.04  12/08/98  PSBICIS 5316 TAL    SW53PSBI SW04000  P                 ***
!*FIX2.03  08/28/98  PSBICIS 5316 TAL    SW53PSBI SW03000  P                 ***
!*FIX2.06  08/13/98  PSBICIS 5116 TAL    SW51PSBI SW03154  P                 ***
!*FIX2.06  07/23/98  PSBICIS 5115 TAL    SW51PSBI SW03147  O                 ***
!*SYNC.03  08/25/97  PSBICIS 5114 TAL    SW51PSBI SW03000  N                 ***
!*FIX2.04  05/20/97  PSBICIS 5114 TAL    SW51PSBI SW51173  N                 ***
!*FIX2.04  04/09/97  PSBICIS 5113 TAL    SW51PSBI SW51141  M                 ***
!*FIX2.00  01/13/94  PSBICIS 5112 TAL    SW51PSBI SW51408  L                 ***
!*FIX2.00  12/30/92  PSBICIS 5011 TAL    SW50PSBI SW50325  K                 ***
!*FIX2.00  01/09/91  PSBICIS 5010 TAL    SW50PSBI SW40968  J                 ***
!*FIX1.19  01/02/91  PSBICIS 4009 TAL    SW40PSBI SW40957  I                 ***
!*FIX1.19  11/16/90  PSBICIS 4008 TAL    SW40PSBI SW40900  H                 ***
!*FIX1.19  10/30/90  PSBICIS 4007 TAL    SW40PSBI SW40876  G                 ***
!*FIX1.19  07/03/90  PSBICIS 4006 TAL    SW40PSBI SW40696  F                 ***
!*FIX1.19  04/18/90  PSBICIS 4005 TAL    SW40PSBI SW40580  E                 ***
!*FIX1.19  03/05/90  PSBICIS 4004 TAL    SW40PSBI SW40532  D                 ***
!*FIX1.19  09/14/89  PSBICIS 4003 TAL    SW40PSBI SW40236  C                 ***
!*FIX1.17  10/19/88  PSBICIS 4002 TAL    SW40PSBI SW40729  B                 ***
!*FIX1.17  05/18/88  PSBICIS 4001 TAL    SW40PSBI SW40493  A                 ***
!*SEQ2.17  04/28/88  PSBICIS 4000 TAL    SW40PSBI                              !
                                                                       !00000R00
?page "header and modification history"                                !00000R01
!#####################################################################!!00000R02
!#                                                                   #!!00000R03
!#                            BASE24-pos                             #!!00000R04
!#                            ----------                             #!!00000R05
!#                                                                   #!!00000R06
                                                                       !00000S00
!#                        BIC ISO Interface                          #!
                                                                       !00000S03
!#                                                                   #!!00000R08
!#                   Proprietary Software Product                    #!!00000R09
!#                                                                   #!!00000R0A
!#                        ACI Worldwide Inc.                         #!!00000R0B
!#                      330 South 108th Avenue                       #!!00000R0C
!#                      Omaha, Nebraska  68154                       #!!00000R0D
!#                          (402) 390-7600                           #!!00000R0E
!#                                                                   #!!00000R0F
                                                                       !00000S04
                                                                       !00000U00
!#    Copyright by ACI Worldwide Inc. 1988 - 2001                    #!
                                                                       !00000U03
                                                                       !00000S07
!#                                                                   #!!00000R0H
!#    All Rights Reserved.  No part of this document may be          #!!00000R0I
!#    reproduced in any manner without the prior written consent of  #!!00000R0J
!#    ACI Worldwide Inc.  This material is a trade secret and its    #!!00000R0K
!#    confidentiality is strictly maintained.  Use of any copyright  #!!00000R0L
!#    notice does not imply unrestricted or public access to these   #!!00000R0M
!#    materials.                                                     #!!00000R0N
!#                                                                   #!!00000R0O
!#    BASE24 (R) is a registered trademark of ACI Worldwide Inc.     #!!00000R0P
!#                                                                   #!!00000R0Q
!#####################################################################!!00000R0R
                                                                       !00000R0S
?page                                                                !!!00000R0T
! Record of Changes:                                                 ! !00000R0U
!                                                                    ! !00000R0V
! Date        Person/Emp #                                           ! !00000R0W
! ---------   ------------                                           ! !00000R0X
                                                                       !00000R0Y
                                                                       !00001R00
                                                                       !00001R01
!  88MAY13            TLE!                                             !00024A01
!  SYMPTOM: None.!                                                     !00024A02
!  PROBLEM: SSV's no longer work the same with the C00 operating!      !00024A03
!           system.  The source and search statements can no longer!   !00024A04
!           reference subvolumes along with the filename.!             !00024A05
!  FIX:     Modified source and search statements to only reference!   !00024A06
!           a filename for the C00 operating system. This fix will!    !00024A07
!           also work with prior releases of the operating system.!    !00024A08
!  DEPENDENCIES: Apply fix and re-compile.!                            !00024A09
!  REFERENCE:  ACI GENERATED ENHANCEMENT.!                             !00024A0A
                                                                       !00024A0B
                                                                       !00024B00
                                                                       !00024B01
!   88/18/10    JG!                                                    !00024B02
!   SYMPTOM:    None.!                                                 !00024B03
!   PROBLEM:    C10 Upgrade.  The C10 compiler produces warning 52!    !00024B04
!               when procs CPULOAD and LOCKDATA are sourced in from!   !00024B05
!               EXDECS. All EXDECS procs are now sourced in, because a!!00024B06
!               list of procs is not qualified in the ?SOURCE command.!!00024B07
!   FIX:        Eliminate the CPULOAD and LOCKDATA procs by fully!     !00024B08
!               qualifying the procs required for the switch in the!   !00024B09
!               ?SOURCE command.!                                      !00024B0A
!   IMP.DPND:   Apply fix and recompile.!                              !00024B0B
!   REF:        None.!                                                 !00024B0C
                                                                       !00024B0D
                                                                       !00024B0E
                                                                       !00024C00
!   9/13/89     Heim                                                !  !00024C01
!   SYMPTOM:    Performance totals for inbound trans are not being  !  !00024C02
!               rolled over correctly.                              !  !00024C03
!   PROBLEM:    The move statement that rolls the totals over was   !  !00024C04
!               being done for WLEN and should have been $LEN.      !  !00024C05
!               This causes only half of the data to be rolled over.!  !00024C06
!   FIX:        Changed move to be for the $LEN instead of WLEN.    !  !00024C07
!   IMP.DPND:   Apply fix and recompile.                            !  !00024C08
!   REF:        RPC #121018.                                        !  !00024C09
                                                                       !00024C0A
                                                                       !00024C0B
                                                                       !00024D00
! 26FEB90  DAS!                                                        !00024D01
! SYMPTOM: VISANET POS Address Verification Enhancements!              !00024D02
!          VISANET has mandated issuer compliance of Address!          !00024D03
!          Verification by April 30, 1990.  Address Verification is!   !00024D04
!          designed to reduce chargeback losses, chargeback processing!!00024D05
!          expenses and fraud for mail/phone order transactions in the!!00024D06
!          direct marketing retailer segment.!                         !00024D07
! PROBLEM (E) : None.!                                                 !00024D08
! FIX: Modified default bit maps to enable Address Verification data!  !00024D09
!      to be sent/received in 0200s, 0210s, and 0220s.  Added!         !00024D0A
!      code to transfer address, zip code, and address verification!   !00024D0B
!      status in all transactions going to the issuer.  Added code!    !00024D0C
!      to transfer address verification status in 0210s returning!     !00024D0D
!      to the acquirer.  Added code to transfer the address!           !00024D0E
!      verification status between the PSTM and the ILF.!              !00024D0F
! DEPENDENCIES: Apply fix to BASE and POS DDLs, then re-ddl.!          !00024D0G
!               Apply fix to this code and recompile.!                 !00024D0H
! REFERENCE: RPE #E890525!                                             !00024D0I
                                                                       !00024D0J
! 26FEB90  DAS!                                                        !00024D0K
! SYMPTOM: When BIC ISO was being used with the MHI, the MHI was!      !00024D0L
!          unable to read the PTDF.!                                   !00024D0M
! PROBLEM (C): The PSTM user^data field was having two bytes of!       !00024D0N
!              extraneous data inserted between the length!            !00024D0O
!              specifier and the actual data.!                         !00024D0P
! FIX: Reduced the amount of data being moved from the length!         !00024D0Q
!      specifier to the PSTM user^data field in pos^util^send^pstm!    !00024D0R
!      from two to one word of data.!                                  !00024D0S
! DEPENDENCIES: Apply fix and recompile.!                              !00024D0T
! REFERENCE: ACI generated.!                                           !00024D0U
                                                                       !00024D0V
                                                                       !00024E00
!   18Apr90     Heim                                                !  !00024E01
!   SYMPTOM:    Failed response msgs from auth are not processed.   !  !00024E02
!   PROBLEM:    Failed response msgs from auth not reversed if they !  !00024E03
!               were approved.                                      !  !00024E04
!   FIX:        (P) Added a proc pos^failed^0x10^pstm^resp.  This   !  !00024E05
!               proc will call pstm^0420^reversal and reverse the   !  !00024E06
!               transaction if it was approved.                     !  !00024E07
!   IMP.DPND:   Apply fix and recompile.                            !  !00024E08
!   REF:        RPC #125095.                                        !  !00024E09
                                                                       !00024E0A
                                                                       !00024E0B
                                                                       !00024E0C
                                                                       !00024E0D
                                                                       !00024F00
!   03Jul90     kjw                                                 !  !00024F01
!   SYMPTOM:    Interface sending response codes into Base24 that   !  !00024F02
!               are not supported by Base24.                        !  !00024F03
!   PROBLEM:    ISO response codes are incorrectly translated into  !  !00024F04
!               Base24 response code values.                        !  !00024F05
!   FIX:        (C) Changed mapping of response codes into Base24.  !  !00024F06
!   IMP.DPND:   Apply fix and recompile.                            !  !00024F07
!   REF:        RPC #127191.                                        !  !00024F08
                                                                       !00024G00
!   10/30/90    Vogel                                               !  !00024G01
!   SYMPTOM:    Interface is not doing stand-in auth properly.      !  !00024G02
!   PROBLEM:    The interface was setting pstm.rte.pri, alt1 and    !  !00024G03
!               alt2 with net.myname.  When the transaction was sent!  !00024G04
!               back to Router/Auth, he would keep returning the    !  !00024G05
!               tran back to the interface and not perform stand in !  !00024G06
!               authorization.                                      !  !00024G07
!   FIX:        (C) Changed proc pstm^0200^request so that the      !  !00024G08
!               interface will not change the pstm.rte fields.      !  !00024G09
!   IMP.DPND:   Apply fix and recompile.                            !  !00024G0A
!   REF:        RPC #129317.                                        !  !00024G0B
                                                                       !00024G0C
                                                                       !00024H00
                                                                       !00024H01
! 11/16/90     MRA                                                  !  !00024H02
! SYMPTOM:     Enhancement to allow Pre-Authorization for a lesser  !  !00024H03
!              amount than originally requested.  Star systems      !  !00024H04
!              requires all acquirer and issuer processors to       !  !00024H05
!              support Pre-Authorization for a lesser amount when   !  !00024H06
!              the originally requested funds are not available or  !  !00024H07
!              limits will be exceeded.  This enhancement will bring!  !00024H08
!              BASE24-pos into compliance with these requirements.  !  !00024H09
! PROBLEM:     (E) None.                                            !  !00024H0A
! FIX:         Two new literals were added.  PSTM^RESP^LOW^FUND^ERR !  !00024H0B
!              ^L has a value of 76 for declined low funds.  POS^   !  !00024H0C
!              RVSL^SUPPORT^ERR^L has a value of 40 for requested   !  !00024H0D
!              function not supported.  Added PRE^AUTH^FLAG as a    !  !00024H0E
!              third parameter to proc POS^FRMT^SEM^TO^PSTM^0210.   !  !00024H0F
!              If this flag is true, the deny procs will be called  !  !00024H0G
!              using the new literals.  If the flag is false, which !  !00024H0H
!              it is initialized to, the deny procs will be called  !  !00024H0I
!              as previously implemented.                           !  !00024H0J
! IMPLEMENT:   Recompile BASE, BASE POS, and POS DDLs.              !  !00024H0K
!              Apply fix to PSBICIS, recompile, and bind.           !  !00024H0L
! REFERENCE:   RPE #PS900626-2.                                     !  !00024H0M
                                                                       !00024H0N
                                                                       !00024H0O
                                                                       !00024H0P
                                                                       !00024H0Q
                                                                       !00024I00
!   01/02/91   KSB                                                  !  !00024I01
!   SYMPTOM:   Force posts not being sent back to co-network.       !  !00024I02
!   PROBLEM:   In proc stm^0220^advice, we check the field          !  !00024I03
!              pct.options.acq^stand^in to determine whether or     !  !00024I04
!              not to send the force post message.  Since it is     !  !00024I05
!              possible that this field may not be set, this check  !  !00024I06
!              should be removed.                                   !  !00024I07
!   FIX:       (P) Removed the check for offline completion for     !  !00024I08
!              force post transactions.                             !  !00024I09
!   IMPLEMENT: Apply fix and recompile.                             !  !00024I0A
!   REFERENCE: ACI GENERATED ENHANCEMENT.                           !  !00024I0B
                                                                       !00024I0C
! 01/02/91   KSB                                                    !  !00024I0D
! SYMPTOM:   BIC ISO does not send reversal transactions when an    !  !00024I0E
!            outbound transaction timeout occurs if the protocol    !  !00024I0F
!            being used is X.25.                                    !  !00024I0G
! PROBLEM:   (P) The message may get lost between the TANDEM X25AM  !  !00024I0H
!            processes which exist on each co-network, without the  !  !00024I0I
!            BIC processes knowing that messages got lost.          !  !00024I0J
! FIX:       In the proc pos^tim^out^01^outbound^rqst a local       !  !00024I0K
!            struct definition was added .sem( sem^def ).           !  !00024I0L
!            If the protocol type is X.25, then a call was made to  !  !00024I0M
!            pstm^frmt^b24^to^pos^sem( susp.msg, sem ) and a call   !  !00024I0N
!            to pstm^frmt^b24^to^pos^0200( susp.msg, sem ).  Then   !  !00024I0O
!            '00' was moved into sem.isopsem.resp^cde to allow a    !  !00024I0P
!            call to be made to the proc pos^0210^deny( sem,        !  !00024I0Q
!            susp.orig^net^pro, pos^rvsl^timeout^l ).               !  !00024I0R
!            This formats a reversal message to the                 !  !00024I0S
!            co-network when X.25 protocol is being used.           !  !00024I0T
!            In the procs pos^failed^0200^pstm^request,             !  !00024I0U
!            pos^failed^0200^sem^request, pos^0210^response, and    !  !00024I0V
!            pstm^0210^response the suspense record                 !  !00024I0W
!            primary key is formatted from the failed PSTM 0200     !  !00024I0X
!            request before attempting to delete the suspended      !  !00024I0Y
!            record from extended memory.  This required declaring  !  !00024I0Z
!            int pan^lgth and a string .pan[0:18].  The processing  !  !00024I10
!            required a call to pos^frmt^sem^to^prikey and          !  !00024I11
!            pstm^frmt^b24^to^prikey.  The trace^num param is also  !  !00024I12
!            removed when there is a call to util^suspend^tran^     !  !00024I13
!            delete.  In the proc pos^0420^reversal, if the protocol!  !00024I14
!            type indicates a X.25 protocol being used,             !  !00024I15
!            (i.e. pct.proto^type = "03" ), then added code to find !  !00024I16
!            and delete the inbound request timer and supsense      !  !00024I17
!            record for this transaction.  This required formatting !  !00024I18
!            the prikey and a call to util^suspend^tran^delete.     !  !00024I19
!            If the timer is located and deleted on the reversal    !  !00024I1A
!            transaction, then the reversal transaction is logged to!  !00024I1B
!            the ilf.  This required a call to the proc util^ilf^add.! !00024I1C
! IMPLEMENT: Apply fix, recompile all BIC ISO product modules, and  !  !00024I1D
!            rebind.                                                !  !00024I1E
! REFERENCE: RPC #128787.                                           !  !00024I1F
                                                                       !00024J00
!   1/9/91      Vogel                                               !  !00024J01
!   SYMPTOM:    Interface is not alternate routing correctly.       !  !00024J02
!   PROBLEM:    If the acquirer stand in flag is not set and the    !  !00024J03
!               current authorizer is something other than AUTHH,   !  !00024J04
!               the transaction is never returned to auth.  Also,   !  !00024J05
!               if something other than AUTHH is used and the       !  !00024J06
!               acquirer stand in flag is set, then the transaction !  !00024J07
!               would loop between the interface and auth           !  !00024J08
!               indefinitely.                                       !  !00024J09
!   FIX:        (F) Corrected the logic in pstm^0200^route so that  !  !00024J0A
!               the transactions will be alternate routed if        !  !00024J0B
!               possible.                                           !  !00024J0C
!   IMP.DPND:   Apply fix and recompile.                            !  !00024J0D
!   REF:        RPC #129317.                                        !  !00024J0E
                                                                       !00024J0F
                                                                       !00024K00
                                                                       !00024K01
!********************************************************************! !00024K02
!*                  Release 5.0                                     *! !00024K03
!********************************************************************! !00024K04
!                                                                   !  !00024K05
!   12/28/92    dsh/712                                             !  !00024K06
!   SYMPTOM:    Multiple echotest messages are sent.                !  !00024K07
!   PROBLEM:    The previous fix ("I") inserted a prikey in the     !  !00024K08
!               timer^userbuf^def.  Since this prikey was added the !  !00024K09
!               network management timers could no longer be found  !  !00024K0A
!               or deleted.  The network management timers use the  !  !00024K0B
!               sta^x and pro^x, since the prikey was added these   !  !00024K0C
!               fields are no longer at the beginning of the struct !  !00024K0D
!               so timers can not be found or deleted.              !  !00024K0E
!   FIX:        (F) Redefined the timer^userbuf^def prikey so       !  !00024K0F
!               network management timers can be found and deleted. !  !00024K0G
!               There is now a nmm^prikey that network management   !  !00024K0H
!               and saf timers will use.                            !  !00024K0I
!   IMP.DPND:   Apply fix to BABICIS, BABICIG, ATBICIS OR PSBICIS   !  !00024K0J
!               recompile all modules and rebind.                   !  !00024K0K
!   REF:        RPC #130989.                                        !  !00024K0L
                                                                       !00024K0M
!   12/28/92    dsh/712                                             !  !00024K0N
!   SYMPTOM:    Interface is not suspending the entire message      !  !00024K0O
!               correctly.                                          !  !00024K0P
!   PROBLEM:    The interface is using msg^text^start to determine  !  !00024K0Q
!               where the beginning of the message is.              !  !00024K0R
!               Msg^text^start does not always point to the first   !  !00024K0S
!               byte of the application message, so the interface   !  !00024K0T
!               was suspending the message starting at the wrong    !  !00024K0U
!               byte.                                               !  !00024K0V
!   FIX:        Pass mtp as a parameter to procs pos^0200^request   !  !00024K0W
!               and use mtp to suspend the message instead of       !  !00024K0X
!               msg^text^start.                                     !  !00024K0Y
!   IMP.DPND:   Apply fix to PSBICIS, re-genfwd2, recompile, rebind.!  !00024K0Z
!   REFERENCE:  RPC # 132918.                                       !  !00024K10
                                                                       !00024K11
!   12/28/92    dsh/712                                             !  !00024K12
!   SYMPTOM:    Process dumping.                                    !  !00024K13
!   PROBLEM:    There was an unitialized pointer because of         !  !00024K14
!               unmatched tests.                                    !  !00024K15
!   FIX:        (F) Modified proc POS^UTIL^UPDT^SETL^TTLS to return !  !00024K16
!               if no match was found                               !  !00024K17
!   IMP.DPND:   Apply fix to PSBICIS, recompile all modules and     !  !00024K18
!               rebind.                                             !  !00024K19
!   REF:        RPC #132014.                                        !  !00024K1A
                                                                       !00024K1B
!   12/28/92    dsh/712                                             !  !00024K1C
!   SYMPTOM:    Message is logged indicating error 1 on the Saf.    !  !00024K1D
!   PROBLEM:    If a 0x20 message is failed back to Bic, the process!  !00024K1E
!               is not correctly looking for the saf timer.  This   !  !00024K1F
!               could cause the Saf flags to be set incorrectly and !  !00024K1G
!               could cause an error 1 to be generated.             !  !00024K1H
!   FIX:        (P) Changed pos^failed^0xxx^sem^advice to use util^ !  !00024K1I
!               find^timer to locate and delete the Saf timer.  If  !  !00024K1J
!               a timer is not found nothing will be done to the    !  !00024K1K
!               Saf pending and retry counter fields.               !  !00024K1L
!   IMP.DPND:   Apply fix to PSBICIS recompile and rebind.          !  !00024K1M
!   REF:        RPC #133158.                                        !  !00024K1N
                                                                       !00024K1O
!   12/28/92    dsh/712                                             !  !00024K1P
!   SYMPTOM:    Reversals sent into AUTH with pans of all zeroes.   !  !00024K1Q
!   PROBLEM:    A prior fix generated a reversal whenever a request !  !00024K1R
!               message timed out and the protocol being used was   !  !00024K1S
!               X25.  The fix did not format the internal 0420 msg  !  !00024K1T
!               for logging to the ILF, thus the record which was   !  !00024K1U
!               written to the ILF had zeroes in most of the fields.!  !00024K1V
!               Also, an ACK was never sent back to the acquiring   !  !00024K1W
!               network which caused the SAF'd reversal to be sent  !  !00024K1X
!               a second time.  Upon receipt of the second reversal,!  !00024K1Y
!               the ILF record was retrieved and a reversal was     !  !00024K1Z
!               generated from it; this happened because the        !  !00024K20
!               ILF.POS^TYP was "0000" not "0420".  The reversal    !  !00024K21
!               AUTH received had zeroes in the pan, tran code and  !  !00024K22
!               many other significant fields.                      !  !00024K23
!   FIX:        (F) Modified POS^0420^REVERSAL to check for protocol!  !00024K24
!               type = "03" AND util^suspend^tran^delete; if both   !  !00024K25
!               of these conditions are met then the following procs!  !00024K26
!               will be called before the record is added to the    !  !00024K27
!               ILF:  pos^frmt^sem^to^pstm^0420, pos^frmt^sem^to^   !  !00024K28
!               pstm^tran, and pos^frmt^sem^to^pstm^acct.  If these !  !00024K29
!               2 conditions are not met then the ELSE portions of  !  !00024K2A
!               the IF statement will be tested.  Also changed POS^ !  !00024K2B
!               0420^REVERSAL so that pct.options.ack^to^swi is     !  !00024K2C
!               checked for all cases under which an external 0420  !  !00024K2D
!               message can be received.                            !  !00024K2E
!   IMP.DPND:   Apply fix to PSBICIS and/or corresponding fix to    !  !00024K2F
!               ATBICIS, recompile all product specific modules and !  !00024K2G
!               rebind.                                             !  !00024K2H
!   REF:        RPC #134646.                                        !  !00024K2I
                                                                       !00024K2J
!   12/28/92    dsh/712                                             !  !00024K2K
!   SYMPTOM:    The reports show pans of all 0s for inbound requests!  !00024K2L
!               which have timed out.                               !  !00024K2M
!   PROBLEM:    If an external 0200 times out, or is not passed into!  !00024K2N
!               RTAU due to a failure on preliminary checks, not all!  !00024K2O
!               PSTM fields will be filled in prior to logging the  !  !00024K2P
!               record to the ILF.  The interface does not call a   !  !00024K2Q
!               proc to fill in the pan, and tran code fields in the!  !00024K2R
!               PSTM.                                               !  !00024K2S
!   FIX:        (P) Changed POS^0200^DENY to call POS^FRMT^SEM^TO^  !  !00024K2T
!               PSTM^0200; this will allow the PAN and TRAN CODE    !  !00024K2U
!               to be placed in the PSTM prior to logging it to the !  !00024K2V
!               ILF.                                                !  !00024K2W
!   IMP.DPND:   Apply fix, recompile and bind.                      !  !00024K2X
!   REF:        RPC #136462.                                        !  !00024K2Y
                                                                       !00024K2Z
!   12/28/92    dsh/712                                             !  !00024K30
!   SYMPTOM:    Interface is reversing transactions that were       !  !00024K31
!               denied.                                             !  !00024K32
!   PROBLEM:    When a tran is reversed, the Interface was checking !  !00024K33
!               for an approved tran before formatting a reversal.  !  !00024K34
!               The check was incorrectly checking the orig resp^cde!  !00024K35
!   FIX:        Modified define pstm^approved^d to check for resp^  !  !00024K36
!               cde < "050" instead of resp^cde.byte[1] <= "09".    !  !00024K37
!   IMP.DPND:   Apply fix to PSBICIS, re-genfwd2, recompile, rebind.!  !00024K38
!   REFERENCE:  RPC # 141788                                        !  !00024K39
                                                                       !00024K3A
!   12/28/92    dsh/712                                             !  !00024K3B
!   SYMPTOM:    Response codes are mapped incorrectly.              !  !00024K3C
!   PROBLEM:    The interface is mapping an inbound "07" into a     !  !00024K3D
!               "910" when it should be mapping it to "909", because!  !00024K3E
!               "910" is not a valid BASE24 response code.          !  !00024K3F
!               The interface is mapping an outbound "909" to "O4"  !  !00024K3G
!               when it should be mapping it to "04".               !  !00024K3H
!   FIX:        In the proc pstm^frmt^b24^to^pos^0210, mapped the   !  !00024K3I
!               outbound "909" to a "04".  In the proc              !  !00024K3J
!               pos^frmt^sem^to^pstm^0210, mapped the inbound "07"  !  !00024K3K
!               to a "909".                                         !  !00024K3L
!   IMP.DPND:   Apply fix to PSBICIS, recompile and rebind.         !  !00024K3M
!   REFERENCE:  RPC #141895.                                        !  !00024K3N
                                                                       !00024K3O
!   12/28/92    dsh/712                                             !  !00024K3P
!   SYMPTOM:    PIN translation problem.                            !  !00024K3Q
!   PROBLEM:    In proc PSTM^0200^REQUEST the value "PIN IS SECURED"!  !00024K3R
!               is put in the pin field before the original request !  !00024K3S
!               is suspended.  When fix "I" was implemented, (in    !  !00024K3T
!               proc pos^tim^out^01^outbound^rqst) the pin translate!  !00024K3U
!               did not work.                                       !  !00024K3V
!   FIX:        (P) Deleted the line that filled the spstm.pin      !  !00024K3W
!               with the value "PIN IS SECURED".                    !  !00024K3X
!   IMP.DPND:   Apply fix to PSBICIS recompile all modules and      !  !00024K3Y
!               rebind.                                             !  !00024K3Z
!   REF:        RPC #900109.                                        !  !00024K40
!                                                                   !  !00024K41
!   12/28/92    dsh/712                                             !  !00024K42
!   SYMPTOM:    Field P-60 on the 0420 message contains no data when!  !00024K43
!               a late 0110/0210 is processed.                      !  !00024K44
!   PROBLEM:    Field P-60 is mandatory on the 0420 message but not !  !00024K45
!               mandatory on the 0110/0210 message.  On late        !  !00024K46
!               0110/0210, field P-60 of the 0420 does not contain  !  !00024K47
!               any data when it is sent to the co-network.         !  !00024K48
!   FIX:        (P) Modified the default bit map so that field P-60 !  !00024K49
!               is mandatory on all but 0110/02101 messages.        !  !00024K4A
!   IMP.DPND:   Apply fix to PSBICIS.  Recompile and rebind.        !  !00024K4B
!   REF:        RPC #900114.                                        !  !00024K4C
!                                                                   !  !00024K4D
!  12/28/92     dsh/712                                             !  !00024K4E
!  SYMPTOM:        BASE24-base Release 5.0 Enhancements.            !  !00024K4F
!  PROBLEM:        (E) None.                                        !  !00024K4G
!  FIX:            1.  Added support for Message Tokenization.      !  !00024K4H
!                  2.  Added support for Hardware MAC'ing.          !  !00024K4I
!                  3.  Added support Double Length Keys.            !  !00024K4J
!                  4.  Added support err flag in token.             !  !00024K4K
!  DEPENDENCIES:   Apply fixes to PSBICIS recompile and rebind.     !  !00024K4L
!                                                                   !  !00024K4M
!                  See the release 5.0 installation documentation   !  !00024K4N
!                  for further information.                         !  !00024K4O
!  REFERENCE:      BASE24-base Release 5.0 External Specification   !  !00024K4P
!                    - Message Tokenization Enhancements            !  !00024K4Q
!                    - Hardware MAC Support Enhancements            !  !00024K4R
!                    - Double Length Keys Enhancements              !  !00024K4S
!                                                                   !  !00024K4T
                                                                       !00024L00
!   01/06/93    MILLER.                                             !  !00024L01
!   SYMPTOM:    Not-on-us transaction requests received by the BIC  !  !00024L02
!               ISO interface and routed through BASE24 to VISA     !  !00024L03
!               contained invalid track2 service codes.             !  !00024L04
!   PROBLEM:    Fixed length ISO messages indicate a track2 length  !  !00024L05
!               of 37, however, track2 may be variable.  The proc   !  !00024L06
!               pos^frmt^sem^to^pstm^acct was always moving 37 bytes!  !00024L07
!               of the external track2 field and placing the end    !  !00024L08
!               sentinel at the end of the PSTM track2 field.  This !  !00024L09
!               would cause blanks to be present between the actual !  !00024L0A
!               track2 data and the end sentinel.                   !  !00024L0B
!   FIX:        (P) Modified proc pos^frmt^sem^to^pstm^acct to      !  !00024L0C
!               calculate the actual track2 length for use in the   !  !00024L0D
!               move statement thus causing the end sentinel to be  !  !00024L0E
!               placed directly after the actual track2 data.       !  !00024L0F
!   IMP.DPND:   Apply fix to PSBICIS, recompile, and re-bind.       !  !00024L0G
!   REF:        RPC #312.                                           !  !00024L0H
!                                                                   !  !00024L0I
! 1/26/93    KSB/1259                                               !  !00024L0J
! SYMPTOM:   When the POS-LN-CUTOVER param is left out, the log     !  !00024L0K
!            message does not indicate the param that is left out.  !  !00024L0L
! PROBLEM:   The wlform for the log message call has a "/?" where   !  !00024L0M
!            the param should be placed.  It now has a "\?" so the  !  !00024L0N
!            actual param name will be logged instead of /?.        !  !00024L0O
! FIX:       Modified the bad^param wlform in the proc              !  !00024L0P
!            pos^init^get^lconf^info to use "\?" for the param      !  !00024L0Q
!            variable instead of "/?".                              !  !00024L0R
! IMP.DPND:  Apply fix to PSBICIS, recompile and bind.              !  !00024L0S
! REFERENCE: RPC # 002607.                                          !  !00024L0T
!                                                                   !  !00024L0U
!   2/3/93      dsh/712                                             !  !00024L0V
!   SYMPTOM:    Pre^auth^seq^num is not returned to auth on a 0420. !  !00024L0W
!   PROBLEM:    When an internal 0420 message is formatted the      !  !00024L0X
!               pre^auth^seq^num is moved back into the PSTM.       !  !00024L0Y
!   FIX:        (P) Change code to move the pre^auth^seq^num from   !  !00024L0Z
!               the external message to the PSTM 0420 message.      !  !00024L10
!   IMP.DPND:   Apply fix to PSBICIS.  Recompile and rebind.        !  !00024L11
!   REF:        RPC #2676.                                          !  !00024L12
!                                                                   !  !00024L13
!   2/3/93      dsh/712                                             !  !00024L14
!   SYMPTOM:    When formatting an internal 0220/0420 the Address   !  !00024L15
!               Verification token is being added to the PSTM.      !  !00024L16
!   PROBLEM:    The fields from the external token should be placed !  !00024L17
!               in the PSTM and the token deleted from the PSTM.    !  !00024L18
!               When formatting an external 0220/0420 the token was !  !00024L19
!               always being added and it should only be added if   !  !00024L1A
!               the addr^typ in the pstm is "98".                   !  !00024L1B
!   FIX:        (P) Change code to format the ext token fields to   !  !00024L1C
!               PSTM fields and delete the token from the PSTM.     !  !00024L1D
!               Also change code to not add the token to the        !  !00024L1E
!               external message unless the addr^typ is "98".       !  !00024L1F
!   IMP.DPND:   Apply fix to PSBICIS.  Recompile and rebind.        !  !00024L1G
!   REF:        RPC #2675.                                          !  !00024L1H
!                                                                   !  !00024L1I
!   2/9/93      KSB/1259                                            !  !00024L1J
!   SYMPTOM:    Interface is not allowing 050 as a POS tran code.   !  !00024L1K
!   PROBLEM:    When a tran is reversed, the Interface was checking !  !00024L1L
!               for an approved tran before formatting a reversal.  !  !00024L1M
!               The check was incorrectly checking the response code!  !00024L1N
!   FIX:        Modified define pstm^approved^d to check for resp^  !  !00024L1O
!               cde < "050" instead of resp^cde.byte[0] <= "050".   !  !00024L1P
!   IMP.DPND:   Apply fix to PSBICIS, re-genfwd2, recompile, rebind.!  !00024L1Q
!   REFERENCE:  RPC # 002763.                                       !  !00024L1R
!                                                                   !  !00024L1S
!   2/19/93     KSB/1259                                            !  !00024L1T
!   SYMPTOM:    Denied transactions are being reversed.             !  !00024L1U
!   PROBLEM:    When a transaction is timed out at the issuing BIC, !  !00024L1V
!               and the acquiring BIC sends a 0420, the issuing BIC !  !00024L1W
!               will reverse the denied transaction.                !  !00024L1X
!   FIX:        (S) In the proc pos^0420^reversal, after we get the !  !00024L1Y
!               original transaction from the ILF, a check is made  !  !00024L1Z
!               to see if the tran is approved, not an inquiry and  !  !00024L20
!               not a reversal advice before formatting the internal!  !00024L21
!               0420.  A check was added to check for a 0200 as well!  !00024L22
!               as a reversal advice.                               !  !00024L23
!   IMP.DPND:   Apply fix to PSBICIS, ATBICIS, recompile and bind.  !  !00024L24
!   REF:        RPC #002762.                                        !  !00024L25
!                                                                   !  !00024L26
!  02/23/93     Stefankiewicz                                       !  !00024L27
!  SYMPTOM:     Reversal sent twice in timeout/late response        !  !00024L28
!               situations whenever X25 protocol is used.           !  !00024L29
!  PROBLEM:     When X25 protocol is being used, a reversal is sent !  !00024L2A
!               at the time the transaction times out, by the       !  !00024L2B
!               acquiring network.  Also, another reversal is       !  !00024L2C
!               generated when the late 0210 response is received;  !  !00024L2D
!               this second reversal is not necessary.              !  !00024L2E
!  FIX:         Changed proc pos^0210^response to not reverse the   !  !00024L2F
!               0210 response if it is late (cannot find suspended  !  !00024L2G
!               request), and the protocol type = 03. (X25)         !  !00024L2H
!  DEPENDENCIES:   Apply fix to PSBICIS and corresponding fix to    !  !00024L2I
!                  ATBICIS, if applicable.  Recompile and rebind.   !  !00024L2J
!  REFERENCE:   RPC # 2863.                                         !  !00024L2K
!                                                                   !  !00024L2L
! 17Mar93    kjw                                                    !  !00024L2M
! SYMPTOM:   None.                                                  !  !00024L2N
! PROBLEM:   (E) Adding 5-day settlement to this module.            !  !00024L2O
! FIX:       Changed code so interface will bypass ILF creation and !  !00024L2P
!            totals message processing on weekends and holidays     !  !00024L2Q
!            when ICF settlement flag is set to 0.                  !  !00024L2R
! IMP.DPND:  Apply fix to babicis, and ATM or POS modules as needed,!  !00024L2S
!            recompile and bind.                                    !  !00024L2T
! REF:       RPE R920504-06                                         !  !00024L2U
!                                                                   !  !00024L2V
! 04/12/93   dsh/712                                                !  !00024L2W
! SYMPTOM:   None.                                                  !  !00024L2X
! PROBLEM:   (P) The code was limiting the value of version number  !  !00024L2Y
!            to be "01" current or "02" previous release.  This     !  !00024L2Z
!            could require the co-network to change the release     !  !00024L30
!            number on their ICF.                                   !  !00024L31
! FIX:       Changed code so current release is indicated by having !  !00024L32
!            "01" in the ICF version number field.  Any other value,!  !00024L33
!            ( 00 or 02-99 ) is considered previous release.        !  !00024L34
! IMP.DPND:  Apply fix to babicis and psbicis, recompile and rebind.!  !00024L35
! REF:       RPC #3019.                                             !  !00024L36
!                                                                   !  !00024L37
! 05/14/93    dsh/712                                               !  !00024L38
! SYMPTOM:    The host rejects message with mac error when ims      !  !00024L39
!             prefix characters are included in the message.        !  !00024L3A
! PROBLEM:    The mac value is not placed at the correct offset in  !  !00024L3B
!             the external message when an ims code is attached.    !  !00024L3C
! FIX:        Modified proc pos^util^sem^collapse to use the ims    !  !00024L3D
!             length when inserting mac value into message.         !  !00024L3E
! IMPLEMENT:  Apply fix to PSBICIS.  Recompile and rebind.          !  !00024L3F
! REFERENCE:  RPC # 3352.                                           !  !00024L3G
!                                                                   !  !00024L3H
! 05/14/93    dsh/712                                               !  !00024L3I
! SYMPTOM:    The ims codes are duplicated when saf records are     !  !00024L3J
!             sent to the co-network.                               !  !00024L3K
! PROBLEM:    When the message is added to the saf file, it is      !  !00024L3L
!             collapsed and ims codes are added to the message.     !  !00024L3M
!             When a saf record is to be sent, we expand the record !  !00024L3N
!             to modify the tracenum, then we collapse it again     !  !00024L3O
!             before we send it. On the second collapse ims codes   !  !00024L3P
!             should not be added.                                  !  !00024L3Q
! FIX:        Fixed code to pass the entire saf.msg to the product  !  !00024L3R
!             specific saf send procs.  This will over eliminate the!  !00024L3S
!             duplicate ims codes.                                  !  !00024L3T
! IMPLEMENT:  Apply fix to PSBICIS.  Recompile and rebind.          !  !00024L3U
! REFERENCE:  RPC # 3400.                                           !  !00024L3V
!                                                                   !  !00024L3W
!                                                                   !  !00024L3X
! 08/03/93    KSB/1259                                              !  !00024L3Y
! SYMPTOM:    The pin length could reach a pin length of 17 while   !  !00024L3Z
!             the max length in only 16.                            !  !00024L40
! PROBLEM:    (C)  In the procs pos^frmt^sem^to^pstm^0200 and       !  !00024L41
!             atm^frmt^sem^to^stm^0200, a while loop is performed   !  !00024L42
!             to find the length of the external pin.  The loop is  !  !00024L43
!             a while loop that goes from epin starting at 0 until  !  !00024L44
!             it is <= max^pin^lgth^l when it should only be <.     !  !00024L45
! FIX:        Changed the procs pos^frmt^sem^to^pstm^0200 and       !  !00024L46
!             atm^frmt^sem^to^stm^0200 to perform the while loop    !  !00024L47
!             on the external pin until it is < max^pin^lgth^l.     !  !00024L48
! IMPLEMENT:  Apply fix to PSBICIS, recompile and rebind.           !  !00024L49
! REFERENCE:  RPC #004517                                           !  !00024L4A
!                                                                   !  !00024L4B
!   09/08/93    kjw                                                 !  !00024L4C
!   SYMPTOM:    None.                                               !  !00024L4D
!   PROBLEM:    Added currency conversion to this module.           !  !00024L4E
!   FIX:        (E) Modified the following list of procs to provide !  !00024L4F
!               conversion from acquirers currency to shared network!  !00024L4G
!               currency and from shared network currency to issuer !  !00024L4H
!               local currency. Totals will be kept in shared       !  !00024L4I
!               network currency.                                   !  !00024L4J
!               pos^frmt^sem^to^pstm^0200 pos^frmt^sem^to^pstm^0210 !  !00024L4K
!               pos^frmt^sem^to^pstm^0220 pos^frmt^sem^to^pstm^0402 !  !00024L4L
!               pos^frmt^sem^to^pstm^0420 pstm^frmt^b24^to^pos^0200 !  !00024L4M
!               pstm^frmt^b24^to^pos^0210 pstm^frmt^b24^to^pos^0220 !  !00024L4N
!               pstm^frmt^b24^to^pos^0420 pos^util^updt^setl^ttls   !  !00024L4O
!      new -->  pstm^frmt^b24^to^pos^amt  pos^frmt^sem^to^pstm^amt  !  !00024L4P
!   IMP.DPND:   Apply fix to PSBICIS, recompile all modules and     !  !00024L4Q
!               rebind. Refer to file SW50BABI.BABIUPDT for ICF     !  !00024L4R
!               settings and complete install instructions.         !  !00024L4S
!   REF:        RPE R930112-01                                      !  !00024L4T
!                                                                   !  !00024L4U
! 09/15/93    Stefankiewicz                                         !  !00024L4V
! SYMPTOM:    Transactions with previous days date are still being  !  !00024L4W
!             accepted and logged to an old ILF.                    !  !00024L4X
! PROBLEM:    (P)  When the interface is processing as the MASTER,  !  !00024L4Y
!             the previous days ILF is not being closed at LN       !  !00024L4Z
!             cutover time which allows the SLAVE to continue to    !  !00024L50
!             send transactions in with an old psem.cap^dat.  The   !  !00024L51
!             SLAVE is required to cutover before the master and    !  !00024L52
!             this error is not being detected by the MASTER.       !  !00024L53
! FIX:        Changed procs pos^0200^request and pos^0402^request   !  !00024L54
!             to pass the pstm parameter to pos^0200^deny when a    !  !00024L55
!             transaction is denied because of a bad date in the    !  !00024L56
!             message.  This change prevents pos^frmt^sem^to^pstm   !  !00024L57
!             from being called and the bad date from being placed  !  !00024L58
!             back into the pstm.acq^ichg^setl^dat; this field is   !  !00024L59
!             used for logging to the ILF.                          !  !00024L5A
! IMPLEMENT:  Apply fix to PSBICIS, dependent fixes to BABICIS and  !  !00024L5B
!             ATBICIS, recompile and BIND.                          !  !00024L5C
! REFERENCE:  RPC #004938.                                          !  !00024L5D
!                                                                   !  !00024L5E
! 09Nov93    GJD                                                    !  !00024L5F
! SYMPTOM:   (F) Incorrect tran code on 420 Merch. Rtn. Adjust.     !  !00024L5G
! PROBLEM:   PSTM.ADJ^FLG is being set incorrectly.                 !  !00024L5H
! FIX:       In proc POS^FRMT^SEM^TO^PSTM^0420 changed code to      !  !00024L5I
!            correctly set the PSTM.ADJ^FLG.                        !  !00024L5J
! IMP.DPND:  Apply fix recompile and bind.                          !  !00024L5K
! REF:       RPC #3889.                                             !  !00024L5L
!                                                                   !  !00024L5M
!  12/02/93     kjw                                                 !  !00024L5N
!  SYMPTOM:     The draft capture flag was being set to "0" by      !  !00024L5O
!               RTAU even though the acquiring BIC set the draft    !  !00024L5P
!               capture flag correctly.                             !  !00024L5Q
!  PROBLEM:     (C)  In the proc POS^FRMT^SEM^TO^PSTM the draft     !  !00024L5R
!               capture flag in the PSTM is set from the associated !  !00024L5S
!               field in the SEM. But when the PSTM goes to RTAU,   !  !00024L5T
!               the tran profile flag from PSTM.SRVCS can be used   !  !00024L5U
!               to set the draft capture flag for further processing!  !00024L5V
!  FIX:         Modified the procs POS^FRMT^SEM^TO^PSTM and         !  !00024L5W
!               POS^UTIL^ILF^EXPAND to set the tran profile flag    !  !00024L5X
!               from the PSTM draft capture field.                  !  !00024L5Y
!  DEPENDENCIES:   Apply fixes to PSBICIS recompile and rebind.     !  !00024L5Z
!  REFERENCE:      RPC #201556.                                     !  !00024L60
!                                                                   !  !00024L61
! 12/06/93   GJD                                                    !  !00024L62
! SYMPTOM:   NONE.                                                  !  !00024L63
! PROBLEM:   No support for the REVERSE-BAL-INQ param.              !  !00024L64
! FIX:       Added support for the param REVERSE-BAL-INQ.           !  !00024L65
! IMP.DPND:  Apply fix and recompile.                               !  !00024L66
! REF:       RPC #2417.                                             !  !00024L67
!                                                                   !  !00024L68
! 12/22/93    kjw                                                   !  !00024L69
! SYMPTOM:    Transactions received by Master before 0810 cutover   !  !00024L6A
!             ack is received from Slave are denied using the same  !  !00024L6B
!             response code used for link down situations.          !  !00024L6C
! PROBLEM:    (P)  In this case the issuer is available, the        !  !00024L6D
!             acquirer has not responded to the cutover message. A  !  !00024L6E
!             more descriptive response code would be "90", meaning !  !00024L6F
!             cutover in progress. The code currently used is "91", !  !00024L6G
!             indicating the issuer is unavailable.                 !  !00024L6H
! FIX:        Changed proc POS^0200^REQUEST to deny transactions    !  !00024L6I
!             received before the cutover ack is processed as "90"  !  !00024L6J
!             response code.                                        !  !00024L6K
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024L6L
! REFERENCE:  RPC #202170.                                          !  !00024L6M
!                                                                   !  !00024L6N
! 01/04/94    kjw                                                   !  !00024L6O
! SYMPTOM:    Fix for SCN SW5D351 was wrong.                        !  !00024L6P
! PROBLEM:    (C) The check on PCT.STATUS.CTVR.ACK was made after   !  !00024L6Q
!             the transaction was suspended.                        !  !00024L6R
! FIX:        Moved the check for PCT.STATUS.CTVR.ACK above the code!  !00024L6S
!             that suspended the transaction.                       !  !00024L6T
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024L6U
! REFERENCE:  RPC #202170.                                          !  !00024L6V
!                                                                   !  !00024L6W
! 01/06/94    kjw                                                   !  !00024L6X
! SYMPTOM:    Transactions received by the Master after 0810 cutover!  !00024L6Y
!             ack is received from the Slave with old dates are not !  !00024L6Z
!             being rejected by the Master.                         !  !00024L70
! PROBLEM:    (P)  After the receipt of the 0810 cutover ack, the   !  !00024L71
!             Master should only allow transactions with the new    !  !00024L72
!             current date. Currently transactions with old dates   !  !00024L73
!             are allowed because an ILF that matches the old date  !  !00024L74
!             is open until the settlement interval timer expires.  !  !00024L75
! FIX:        Changed proc POS^0200^REQUEST to deny transactions    !  !00024L76
!             when the process is running as a Master cutover       !  !00024L77
!             partner, the capture date in the SEM does not match   !  !00024L78
!             PCT.ILF.CUR.DAT, and there is a settlement interval   !  !00024L79
!             timer pending.                                        !  !00024L7A
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024L7B
! REFERENCE:  RPC #203232.                                          !  !00024L7C
!                                                                   !  !00024L7D
                                                                       !00024M00
!*******************************************************************!  !00024M01
!*                       RELEASE 5.1                                !  !00024M02
!*******************************************************************!  !00024M03
!                                                                   !  !00024M04
! 09/01/96    DTW/1779                                              !  !00024M05
! SYMPTOM:    BASE24-Switch Release 5.1 Enhancements.               !  !00024M06
! PROBLEM:    (E) None.                                             !  !00024M07
! FIX:        Added defines and created MAKE file.                  !  !00024M08
! IMPLEMEMT   Make changes to BABICIS and compile.                  !  !00024M09
!             Make changes to DDL'S, PSBICIS,PSBIFM, PSBIMM,        !  !00024M0A
!             compile and rebind.                                   !  !00024M0B
! REF:        BASE24 Release 5.1 MAKE Document Utilization.         !  !00024M0C
!                                                                   !  !00024M0D
!                                                                   !  !00024M0E
! 02/9/94     KSB/1259  DTW/1779                                    !  !00024M0F
! SYMPTOM:    On issuer transactions, the BIC ISO interface was not !  !00024M0G
!             formatting a correct BIC ISO response code from       !  !00024M0H
!             a "251" response code generated at RTAU.              !  !00024M0I
! PROBLEM:    (P) The response code mapping table that formats      !  !00024M0J
!             a POS 0210 message out to the Co-Network, did not     !  !00024M0K
!             have entry "251" mapped to a BIC ISO response code.   !  !00024M0L
! FIX:        Modified the proc pstm^frmt^b24^to^pos^0210 to map    !  !00024M0M
!             a B24 response code of "251" into a BIC ISO response  !  !00024M0N
!             code of "T7".                                         !  !00024M0O
! IMP.DPND:   Apply fix to psbicis, recompile and bind.             !  !00024M0P
! REF:        RPC 203892.                                           !  !00024M0Q
!                                                                   !  !00024M0R
! 03/17/94    kjw   DTW/1779                                        !  !00024M0S
! SYMPTOM:    Purchase transactions with default account types      !  !00024M0T
!             report with denied descriptions despite the value of  !  !00024M0U
!             the internal or external response codes.              !  !00024M0V
! PROBLEM:    (P)  When the response to a default purchase is       !  !00024M0W
!             received from Base24, account type defaults are filled!  !00024M0X
!             by RTAU. The interface does not reflect this in the   !  !00024M0Y
!             the external processing code in the external response.!  !00024M0Z
!             The external processing code is also not reformatted  !  !00024M10
!             into the internal tran code if the internal tran code !  !00024M11
!             is a default purchase.                                !  !00024M12
! FIX:        Changed proc POS^FRMT^RESP^TO^B24^0210 and proc       !  !00024M13
!             PSTM^FRMT^B24^TO^POS^RESP to reformat the tran code or!  !00024M14
!             the processing code if the request is a default purch.!  !00024M15
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024M16
! REFERENCE:  RPC #200524.                                          !  !00024M17
!                                                                   !  !00024M18
! 04/11/94    KSB/1259   DTW/1779                                   !  !00024M19
! SYMPTOM:    When BIC receives a message from the co-network with  !  !00024M1A
!             userdata, a log message from SKEL (invalid msg tlen)  !  !00024M1B
!             is logged to the logger and the message does not go   !  !00024M1C
!             to RTAU.                                              !  !00024M1D
! PROBLEM:    (P)  In migrating to FORTIFY, the user data was moved !  !00024M1E
!             into a global, but never appended to the pstm.        !  !00024M1F
!             The logic was initially changed due to adding the     !  !00024M1G
!             call to hiswutil^calc^intrn^msg^lgth.                 !  !00024M1H
! FIX:        Modified the proc pos^util^send^pstm to append the    !  !00024M1I
!             userdata to the pstm before trying to calculate the   !  !00024M1J
!             message length.                                       !  !00024M1K
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024M1L
! REFERENCE:  RPC #206646.                                          !  !00024M1M
!                                                                   !  !00024M1N
! 08/10/94    kjw  DTW/1779                                         !  !00024M1O
! SYMPTOM:    ILF.SEM fields are not filled in for acquirer timeouts!  !00024M1P
! PROBLEM:    (S)  The external message is neither suspended nor    !  !00024M1Q
!             logged to the ILF. In this scenario the SEM was not   !  !00024M1R
!             passed to the ILF logging procedure.                  !  !00024M1S
! FIX:        Changed proc POS^TIM^OUT^01^OUTBOUND^RQST to format   !  !00024M1T
!             the sem fields that could be logged to the ILF and to !  !00024M1U
!             pass the SEM. Changed procs PSTM^0200^ROUTE, and      !  !00024M1V
!             PSTM^0200^DENY to pass the SEM.                       !  !00024M1W
! IMPLEMENT:  Apply fix to ATBICIS, compile and bind.               !  !00024M1X
! REFERENCE:  RPC #210830.                                          !  !00024M1Y
!                                                                   !  !00024M1Z
! 10/26/94    Swenson  DTW/1779                                     !  !00024M20
! SYMPTOM:    The ILF record does not reflect when a reversal is    !  !00024M21
!             sent back to the acquirer on a late response.         !  !00024M22
! PROBLEM:    (P)  The interface does not update the ilf.sem portion!  !00024M23
!             of the ilf record when a late response is received and!  !00024M24
!             a reversal is sent back to the acquirer.  Some        !  !00024M25
!             customers want the interface to retrieve the ILF      !  !00024M26
!             record upon receipt of the late response and update it!  !00024M27
!             to reflect that a reversal was sent out.              !  !00024M28
! FIX:        Modified pos^0210^response to retrieve the ILF record !  !00024M29
!             if updt^ilf^on^late^resp^g is set to true.  It will   !  !00024M2A
!             then update the ILF.SEM portion of the record to      !  !00024M2B
!             reflect the "0420" and a reversal code of "68".       !  !00024M2C
!             Modified pos^tim^out^01^outbound^rqst to not modify   !  !00024M2D
!             the SEM unless the protocol type <> "03" (X.25); this !  !00024M2E
!             will ensure that the ILF.SEM portion reflects the     !  !00024M2F
!             reversal which is sent back at timeout time for X25.  !  !00024M2G
! IMPLEMENT:  Apply fix to PSBICIS, and dependent fixes to BABICIS, !  !00024M2H
!             BABICIG and ATBICIS, recompile and bind.              !  !00024M2I
! REFERENCE:  RPC #210830.                                          !  !00024M2J
!                                                                   !  !00024M2K
! 11/21/94    Swenson  DTW/1779                                     !  !00024M2L
! SYMPTOM:    The interface is not accurately keeping track of      !  !00024M2M
!             timed out messages.                                   !  !00024M2N
! PROBLEM:    (P)  The interface does not reset the stations max    !  !00024M2O
!             timeout counter when responses are received in time.  !  !00024M2P
!             The interface was only resetting this counter when    !  !00024M2Q
!             any message was received and the LINK was DOWN.  This !  !00024M2R
!             counter should only be reset if a timer can be found  !  !00024M2S
!             and the message being received is for an outbound     !  !00024M2T
!             request of some sort.                                 !  !00024M2U
! FIX:        Modified pos^0230^ack, pos^0430^ack, pos^failed^0x00^ !  !00024M2V
!             sem^rqst, and pos^failed^0xxx^sem^advice.  The first  !  !00024M2W
!             2 procedures were modified to reset the pct.sta[i].   !  !00024M2X
!             t^o^ctr to 0 if a timer can be found; this indicates  !  !00024M2Y
!             that the response has been recieved "in time".  The   !  !00024M2Z
!             second 2 have been modified to increment the t^o^ctr  !  !00024M30
!             if the message failure is a 104 or 204 (inidicating a !  !00024M31
!             timeout at the station level ).  Util^station^status  !  !00024M32
!             and Util^link^status are called to alter the station  !  !00024M33
!             and link status.  A new parameter is passed to util^  !  !00024M34
!             link^status to output a message if the link is being  !  !00024M35
!             marked down due to MAX TIMEOUTS.                      !  !00024M36
! IMPLEMENT:  Apply fix to PSBICIS, and dependent fixes to BABICIS, !  !00024M37
!             and ATBICIS, recompile and bind.                      !  !00024M38
! REFERENCE:  RPC #213254.                                          !  !00024M39
!                                                                   !  !00024M3A
! 12/14/94    kjw  DTW/1779                                         !  !00024M3B
! SYMPTOM:    The interface is not updating ILF with 0420 after     !  !00024M3C
!             receiving reversal from co-network, update is 0430.   !  !00024M3D
! PROBLEM:    (C)  The interface can format a 0430 if the ICF flag  !  !00024M3E
!             is turned on, and the ILF update will use the sem that!  !00024M3F
!             was just formatted as a 0430.                         !  !00024M3G
! FIX:        Modified atm^0420^reversal to update the ILF before   !  !00024M3H
!             formatting the 0430.                                  !  !00024M3I
! IMPLEMENT:  Apply fix to PSBICIS recompile and bind.              !  !00024M3J
! REFERENCE:  RPC #215376.                                          !  !00024M3K
!                                                                   !  !00024M3L
! 12/16/94    kjw  DTW/1779                                         !  !00024M3M
! SYMPTOM:    The totals that are kept by this module do not match  !  !00024M3N
!             the calculated totals from the BICI reports.          !  !00024M3O
! PROBLEM:    (C)  The interface interrogates the response code to  !  !00024M3P
!             determine if a transaction is approved. The check is  !  !00024M3Q
!             incorrect because it only checks the last 2 bytes of  !  !00024M3R
!             the response code and sees some approvals as denials. !  !00024M3S
! FIX:        Modified pos^util^updt^setl^ttls to check all 3 bytes !  !00024M3T
!             of the response code to determine approvals.          !  !00024M3U
! IMPLEMENT:  Apply fix to PSBICIS recompile and bind.              !  !00024M3V
! REFERENCE:  RPC #215431.                                          !  !00024M3W
!                                                                   !  !00024M3X
! 02/09/95    kjw  DTW/1779                                         !  !00024M3Y
! SYMPTOM:    The pstm.orig.crncy^cde field is not set correctly    !  !00024M3Z
!             for issuer transactions.                              !  !00024M40
! PROBLEM:    (C)  The interface passes the currency code from the  !  !00024M41
!             acquirer in pstm.orig.crncy^cde. The LCONF param value!  !00024M42
!             should be passed in the internal field.               !  !00024M43
! FIX:        Modified pos^frmt^semt^to^pstm to pass local^crncy^cde!  !00024M44
!             param value in pstm.orig.crncy^cde.                   !  !00024M45
! IMPLEMENT:  Apply fix to PSBICIS recompile and bind.              !  !00024M46
! REFERENCE:  RPC #217892.                                          !  !00024M47
!                                                                   !  !00024M48
! 04/13/95    kjw   DTW/1779                                        !  !00024M49
! SYMPTOM:    The interface is not accurately keeping track of      !  !00024M4A
!             totals after warmbooting the process.                 !  !00024M4B
! PROBLEM:    (C)  The interface restores the totals from disk and  !  !00024M4C
!             attempts to use an address field that indicates which !  !00024M4D
!             ILF records are added into the disk totals. When      !  !00024M4E
!             updating the disk record using the running counter and!  !00024M4F
!             the max value from the ICF, the PCT last address is   !  !00024M4G
!             used before the current record is written causing the !  !00024M4H
!             disk record to be 1 address behind.                   !  !00024M4I
! FIX:        Moved code from pos^util^updt^setl^ttls to a proc in  !  !00024M4J
!             the base module that incremented the running counter  !  !00024M4K
!             and performed the disk totals update when the max from!  !00024M4L
!             the ICF was reached.                                  !  !00024M4M
! IMPLEMENT:  Apply fix to BABICIS, ATBICIS, and PSBICIS recompile  !  !00024M4N
!             and bind.                                             !  !00024M4O
! REFERENCE:  RPC #218594.                                          !  !00024M4P
!                                                                   !  !00024M4Q
! 04/21/95    RAF   DTW/1779                                        !  !00024M4R
! SYMPTOM:    The default volume and subvolume contain garbage when !  !00024M4S
!             starting to run reports.                              !  !00024M4T
! PROBLEM:    In proc POS^^INPUT^FROM^STATION field MAC^IN^REQ is   !  !00024M4U
!             declared as an indirect field.  The problem is that   !  !00024M4V
!             this field is never initialized.  When running normal !  !00024M4W
!             transactions this field is overwriting the report     !  !00024M4X
!             default volume and subvolume.                         !  !00024M4Y
! FIX:        Modified proc POS^^INPUT^FROM^STATION to make the     !  !00024M4Z
!             field MAC^IN^REQ a direct pointer.  The ATM proc also !  !00024M50
!             uses this field, but it is declared correctly here.   !  !00024M51
! IMPLEMENT:  Apply fix, recompile and bind.                        !  !00024M52
! REFERENCE:  RPC #219703.                                          !  !00024M53
!                                                                   !  !00024M54
! 01/01/95    VD/1146  DTW/1779                                     !  !00024M55
! SYMPTOM:    (E) None.                                             !  !00024M56
! PROBLEM:    Track 1 Enhancement.                                  !  !00024M57
! FIX         The BIC ISO Interface has been modified to support    !  !00024M58
!             track1 token.                                         !  !00024M59
!             For an outbound message, if a track1 token exists,    !  !00024M5A
!             the track1 data is moved to field 45.  The point of   !  !00024M5B
!             service entry mode is moved directly from the         !  !00024M5C
!             internal message.  For an inbound message, the        !  !00024M5D
!             track1 data is moved from the external message        !  !00024M5E
!             to the track1 token.  The length of track1 is set to  !  !00024M5F
!             the maximum length when a fixed length format is      !  !00024M5G
!             used.                                                 !  !00024M5H
!             Also modified the code to move in data from field     !  !00024M5I
!             127 to the userdata field in pstm for an inbound      !  !00024M5J
!             message.                                              !  !00024M5K
!             The following procedures have been modified:          !  !00024M5L
!             POS^UTIL^SEM^COLLAPSE                                 !  !00024M5M
!             POS^FRMT^SEM^TO^PSTM                                  !  !00024M5N
!             POS^FRMT^SEM^TO^PSTM^ACCT                             !  !00024M5O
!             PSTM^FRMT^B24^TO^POS^ACCT                             !  !00024M5P
! IMPLEMENT:  Apply fix to PSBICIS, recompile and bind.             !  !00024M5Q
! REFERENCE:  WO #940907-001                                        !  !00024M5R
!                                                                   !  !00024M5S
! 10/26/95    tlt/588  DTW/1779                                     !  !00024M5T
! SYMPTOM:    Incorrect set of tokens sent in 0412 response.        !  !00024M5U
! PROBLEM:    (C)  When determining the token group for an internal !  !00024M5V
!             generated denial, the token group for 0210 was used   !  !00024M5W
!             versus the token group for 0412.                      !  !00024M5X
! FIX:        Modified pos^0200^deny to use the correct token group !  !00024M5Y
!             for 0412.                                             !  !00024M5Z
! IMPLEMENT:  Apply fix to PSBICIS, recompile and bind.             !  !00024M60
! REFERENCE:  RPC #226586.                                          !  !00024M61
!                                                                   !  !00024M62
! 10/26/95    tlt/588  DTW/1779                                     !  !00024M63
! SYMPTOM:    Incorrect settlement totals.                          !  !00024M64
! PROBLEM:    (C)  Purchase with cash back adjustments were not     !  !00024M65
!             accounted for in totals.                              !  !00024M66
! FIX:        Modified pos^util^updt^setl^ttls to account for       !  !00024M67
!             purchases with cash back adjustments.                 !  !00024M68
! IMPLEMENT:  Apply fix to PSBICIS, recompile and bind.             !  !00024M69
! REFERENCE:  RPC #226586.                                          !  !00024M6A
!                                                                   !  !00024M6B
! 12/04/95    kjw  DTW/1779                                         !  !00024M6C
! SYMPTOM:    Totals kept by the POS BIC ISO module are not correct.!  !00024M6D
! PROBLEM:    When processing reversals, the amount in a cash back  !  !00024M6E
!             transaction is added into totals and should not be.   !  !00024M6F
! FIX:        Modified proc:                                        !  !00024M6G
!                 POS^UTIL^UPDT^SETL^TTLS                           !  !00024M6H
!             to only use amount 2 in a reversal if the tran code is!  !00024M6I
!             not a cash back transaction.                          !  !00024M6J
! IMPLEMENT:  Apply fix, recompile and bind.                        !  !00024M6K
! REFERENCE:  RPC #223685.                                          !  !00024M6L
!                                                                   !  !00024M6M
! 05/03/96    rdw/1712  DTW/1779                                    !  !00024M6N
! SYMPTOM:    Blank s90 fields in 0420 to bic.                      !  !00024M6O
! PROBLEM:    SSEM.B24^ORIG fields were being used to populate      !  !00024M6P
!             the pstm.orig^data fields.  In certain conditions the !  !00024M6Q
!             SSEM fields contained blanks.                         !  !00024M6R
! FIX:        Modified procs:                                       !  !00024M6S
!                      pos^frmt^sem^to^pstm                         !  !00024M6T
!                      pos^frmt^sem^to^pstm^0210                    !  !00024M6U
!             to use PSEM values to populate pstm.orig^data fields. !  !00024M6V
! IMPLEMENT:  Apply fix to PSBICIS, recompile and bind.             !  !00024M6W
! REFERENCE:  RPC #229217.                                          !  !00024M6X
!                                                                   !  !00024M6Y
! 05/09/96    kjw   DTW/1779                                        !  !00024M6Z
! SYMPTOM:    PSTM original data fields are wrong.                  !  !00024M70
! PROBLEM:    (C)  PSTM original data transaction date is being set !  !00024M71
!             from the transaction time from field 90 of the SEM.   !  !00024M72
! FIX:        Modified proc:                                        !  !00024M73
!                      pos^frmt^sem^to^pstm                         !  !00024M74
!             to use date from field 90.                            !  !00024M75
! IMPLEMENT:  Apply fix to PSBICIS, compile and bind.               !  !00024M76
! REFERENCE:  RPC #232653.                                          !  !00024M77
!                                                                   !  !00024M78
! 07/31/96    kjw  DTW/1779                                         !  !00024M79
! SYMPTOM:    Transactions not logged to PTLF.                      !  !00024M7A
! PROBLEM:    RTAU uses a convention that recognizes a value of     !  !00024M7B
!             1978 in msg^pro^1 as a message to be sent to a device !  !00024M7C
!             handler instead of routers. The value 1978 indicates  !  !00024M7D
!             the message is from the Generic Simulator.            !  !00024M7E
! FIX:        Modified procs:                                       !  !00024M7F
!                      pos^^input^from^process                      !  !00024M7G
!                      pos^^input^from^station                      !  !00024M7H
!             to check the value of trace^num^g and to increment if !  !00024M7I
!             the value is 1978.                                    !  !00024M7J
! IMPLEMENT:  Apply fix to PSBICIS, recompile and bind.             !  !00024M7K
! REFERENCE:  RPC #234183.                                          !  !00024M7L
!                                                                   !  !00024M7M
! 09/01/96    DTW/1779                                              !  !00024M7N
! SYMPTOM:    An external response code of "00" is always           !  !00024M7O
!             converted to "000" (balances are present).            !  !00024M7P
! PROBLEM:    The only time a balance in POS would be present is    !  !00024M7Q
!             on a balance inquiry transaction.                     !  !00024M7R
! FIX:        Change the internal response table to have BASE24     !  !00024M7S
!             -pos response code of "001" (no balances present)     !  !00024M7T
!             as the first entry and add a check for an approved    !  !00024M7U
!             balance inquiry transaction, if true set the          !  !00024M7V
!             response code to "000" (balances are present)         !  !00024M7W
! IMPLEMENT:  Apply fix and re-make                                 !  !00024M7X
! REFERENCE:  RPC #500043                                           !  !00024M7Y
!                                                                   !  !00024M7Z
! 09/01/96    DTW/1779                                              !  !00024M80
! SYMPTOM:    Incorrect length of token data.                       !  !00024M81
! PROBLEM:    The length of the token data bit needs to increase in !  !00024M82
!             fixed length messages if the length of the overall bit!  !00024M83
!             ever needs to increase for use by another product.    !  !00024M84
! FIX:        When determining the length of bit 63 (token data) for!  !00024M85
!             a fixed length message, BIC ISO should use the length !  !00024M86
!             of POS.ADD^DATA instead of DATA.                      !  !00024M87
! IMPLEMENT:  Apply fix and re-make                                 !  !00024M88
! REFERENCE:  RPC #951188                                           !  !00024M89
                                                                       !00024N00
!                                                                   !  !00024N01
! 03/18/1997  DTW/1779                                              !  !00024N02
! SYMPTOM:    None.                                                 !  !00024N03
! PROBLEM:    Time comparisons made through out this module are not !  !00024N04
!             year 2000 complient. These comparisons will fail if a !  !00024N05
!             given date is after December 31, 1999.                !  !00024N06
! FIX:        Replace each  date  comparison  with  the ACI utility !  !00024N07
!             compare^ascii^yymmdd for ascii  date  comparisons.    !  !00024N08
!             These utilities are both year 2000 complient.         !  !00024N09
! IMPLEMENT:  Apply fix and re-make.                                !  !00024N0A
                                                                       !00024O00
! REFERENCE:  Year 2000 RPE# 960401-4                               !  !00024O01
!                                                                   !  !00024O02
! 07JUL1998   RAF/1258  NP/1618                                     !  !00024O03
! Symptom:    On acquirer POS request messages in which the request !  !00024O04
!             is not allowed (based on the ICF), the request is     !  !00024O05
!             denied with a response code of '100', referral.       !  !00024O06
! Problem:    The interface is denying invalid request transactions !  !00024O07
!             with a POS response code of '100'.                    !  !00024O08
! Fix:        Modified proc PSTM^0200^REQUEST to deny invalid       !  !00024O09
!             request messages with a response code of '055',       !  !00024O0A
!             invalid transaction.                                  !  !00024O0B
! Dependency: Apply fix and re-make.                                !  !00024O0C
! Reference:  None. (Retro of SW5B255 from Case #305849)            !  !00024O0D
!                                                                   !  !00024O0E
! 07JUL1998   RAF/1258 NP/1618                                      !  !00024O0F
! Symptom:    The PSTM Reversal Reason Code is not getting filled in!  !00024O0G
!             on all inbound reversals.                             !  !00024O0H
! Problem:    The interface is only filling in the internal reversal!  !00024O0I
!             reason code on some of the inbound reversal messages. !  !00024O0J
! Fix:        Modified proc: pos^frmt^sem^to^pstm^0420 to fill in   !  !00024O0K
!             the internal reversal reason code on all reversals.   !  !00024O0L
! Dependency: Apply fix to PSBICIS, compile and bind.               !  !00024O0M
! Reference:  None. (Retro of SW5B256 from Case #305746)            !  !00024O0N
!                                                                   !  !00024O0O
! 07JUL1998   RAF/1258 NP/1618                                      !  !00024O0P
! Symptom:    On acquirer POS request messages which timeout, the   !  !00024O0Q
!             interface is denying the request with a response code !  !00024O0R
!             of '100', referral.                                   !  !00024O0S
! Problem:    The interface is denying timed out outbound           !  !00024O0T
!             transactions with a POS response code of '100'.       !  !00024O0U
! Fix:        Modified proc pos^tim^out^01^outbound^rqst to deny    !  !00024O0V
!             timed out outbound transactions with a response code  !  !00024O0W
!             of '113', time out.                                   !  !00024O0X
! Dependency: Apply fix and re-make.                                !  !00024O0Y
! Reference:  None. (Retro of SW5B293 from Case #305864)            !  !00024O0Z
!                                                                   !  !00024O10
! 07JUl1998   RJC/160 NP/1618                                       !  !00024O11
! Symptom:    The transaction acquirer is dropping normal purchase  !  !00024O12
!             transactions that have been denied by the BIC ISO     !  !00024O13
!             interface.                                            !  !00024O14
! Problem:    On external 0210 POS responses, the BIC ISO interface !  !00024O15
!             is trying to create the internal transaction code for !  !00024O16
!             a normal purchase transaction from the default account!  !00024O17
!             even though all the required data is not present. When!  !00024O18
!             the interface denies the transaction, only the first  !  !00024O19
!             eight bytes are returned in bit 61, so when the tran  !  !00024O1A
!             code is created from this data, it is missing a zero  !  !00024O1B
! Fix:        Modified proc pos^0200^deny to place zeroes in bit 61 !  !00024O1C
!             data subfields crd^fiid and crd^ln, leaving the length!  !00024O1D
!             set to the value from the request and the category    !  !00024O1E
!             code intact.                                          !  !00024O1F
! Dependency: Apply fix to PSBICIS and remake.                      !  !00024O1G
! Reference:  None. (Retro of SW5B491 from Case #308375)            !  !00024O1H
                                                                       !00024O1I
                                                                       !00024P00
! 29JUL1998   RJC/160  NP/1618                                      !  !00024P01
! Symptom:    The customer is intermittently receiving a            !  !00024P02
!             'no activity' message on a low volume line.  When     !  !00024P03
!             the operator checks the status of the station, it is  !  !00024P04
!             found to be up, logged on, with one message pending.  !  !00024P05
! Problem:    The pct station pending flag, pct.sta[ sta^x ].pending!  !00024P06
!             is not getting decremented on a failed SAF advice,    !  !00024P07
!             making it appear that the respective station has a    !  !00024P08
!             message pending.  As a result, an echo test does not  !  !00024P09
!             get generated, while a 'no activity' message continues!  !00024P0A
!             to be displayed.                                      !  !00024P0B
! Fix:        Modified proc pos^failed^0xxx^sem^advice to decrement !  !00024P0C
!             pct.sta[ sta^x ].pending as part of its processing of !  !00024P0D
!             a failed SAF advice.                                  !  !00024P0E
! Dependency: Apply fix to PSBICIS and ATBICIS, recompile and rebind!  !00024P0F
! Reference:  None. (Retro of SW5E760 from Case #302397)            !  !00024P0G
!                                                                   !  !00024P0H
! 29JUL1998   kjw/733 NP/1618                                       !  !00024P0I
! Symptom:    Thirty bytes of unused space in field 95 is sent as   !  !00024P0J
!             spaces.                                               !  !00024P0K
! Problem:    The Base24 manual indicates this area is unused but   !  !00024P0L
!             zero-filled.                                          !  !00024P0M
! Fix:        Modified proc:                                        !  !00024P0N
!                          pstm^frmt^b24^to^pos^amt                 !  !00024P0O
!             to zero fill the unused portion of field 95 any time  !  !00024P0P
!             that amount field is formatted with a value.          !  !00024P0Q
!                          pos^util^sem^collapse                    !  !00024P0R
!             to turn bit 95 back on if it was turned off because   !  !00024P0S
!             the substruct was all zeros.                          !  !00024P0T
! Dependency: Apply fix to psbicis, recompile and bind.             !  !00024P0U
! Reference:  None. (Retro of SW5E746 from Case #301358)            !  !00024P0V
                                                                       !00024P0W
                                                                       !00024Q00
! 18JUN1999   kjw/571 NP/1618                                       !  !00024Q01
! Symptom:    Process dumps with trap #0.                           !  !00024Q02
! Problem:    When the process receives a response from Base24, the !  !00024Q03
!             suspended request is expanded. When calling the expand!  !00024Q04
!             procedure in the Base module, uninitialized pointers  !  !00024Q05
!             for the primary and secondary bit maps are passed to  !  !00024Q06
!             util^sem^expand.                                      !  !00024Q07
! Fix:        Modified proc:                                        !  !00024Q08
!                          pos^util^sem^expand                      !  !00024Q09
!             to pass locally defined variables to util^sem^expand. !  !00024Q0A
! Dependency: Apply fix to PSBICIS and remake.                      !  !00024Q0B
! Reference:  Retro of SW5F048 from Case #315955.                   !  !00024Q0C
                                                                       !00024R02
! 22OCT1999   KEW/728 JFP/1694                                       ! !00024R03
! Symptom:    Transactions are logged to the ILF but not the PTLF.   ! !00024R04
! Problem:    RTAU uses a convention that recognizes a value of      ! !00024R05
!             1978 in msg^pro^1 as a message to be sent to device    ! !00024R06
!             handler instead of router. The value 1978 indicates    ! !00024R07
!             the message is from the Generic Simulator.             ! !00024R08
! Fix:        Changed the logic to increment trace^num^g, if it      ! !00024R09
!             equals 1978, before it is moved into msg^pro^l.        ! !00024R0A
!             Modified Proc:  pos^util^send^pstm                     ! !00024R0B
! Dependency: Apply fix and re-make.                                 ! !00024R0C
! Reference:  Retro of SW5F154 from Case #318165.                    ! !00024R0D
                                                                       !00024S00
!********************************************************************! !00024S01
!*                           Release 6.0                            *! !00024S02
!********************************************************************! !00024S03
! 30NOV2000   jds/1802                                               ! !00024S04
! Symptom:    Release 6.0 Enhancements.                              ! !00024S05
! Problem:    None.                                                  ! !00024S06
! Fix:        Procs modified: pos^0200^deny                          ! !00024S07
!                             pos^0200^request                       ! !00024S08
!                             pos^0220^advice                        ! !00024S09
!                             pos^0402^request                       ! !00024S0A
!                             pos^0420^reversal                      ! !00024S0B
!                             pos^init^pct                           ! !00024S0C
!                             pos^failed^0X10^sem^resp               ! !00024S0D
!                             pos^frmt^sem^to^pstm^0200              ! !00024S0E
!                             pos^frmt^sem^to^pstm^0210              ! !00024S0F
!                             pos^frmt^sem^to^pstm^0220              ! !00024S0G
!                             pos^frmt^sem^to^pstm^0402              ! !00024S0H
!                             pos^frmt^sem^to^pstm^0420              ! !00024S0I
!                             pstm^0200^request                      ! !00024S0J
!                             pstm^0210^response                     ! !00024S0K
!                             pstm^0220^advice                       ! !00024S0L
!                             pstm^0402^request                      ! !00024S0M
!             Procs added:    pos_del_tkns                           ! !00024S0N
!                             pos_init_pct_icfe                      ! !00024S0O
!                             pstm_0210_ptlf_write                   ! !00024S0P
! Dependency: Restore Release 6.0 files, modify the appropriate      ! !00024S0Q
!             CUSTMACS flags, and run MAKE.                          ! !00024S0R
! Reference:  WO #981118-3 ( Transactions Allowed Enhancement ).     ! !00024S0S
                                                                       !00024T00
! 26FEB2001   jds/1802                                               ! !00024T01
! Symptom:    Added 5.3 EMV Support.                                 ! !00024T02
! Problem:    None.                                                  ! !00024T03
! Fix:        Added new response codes to support error conditions   ! !00024T04
!             encountered during the Authorization of EMV            ! !00024T05
!             transactions.                                          ! !00024T06
!             Proc modified:  pstm^frmt^b24^to^pos^0210              ! !00024T07
! Dependency: Restore Release 6.0 files, modify the appropriate      ! !00024T08
!             CUSTMACS flags, and run MAKE.                          ! !00024T09
! Reference:  WO #010102-01 ( EMV 5.3/6.0 ).                         ! !00024T0A
                                                                       !00024U00
! 22MAR2001   jds/1802                                               ! !00024U01
! Symptom:    Release 6.0 requirements.                              ! !00024U02
! Problem:    BIC ISO currently supports the following two external  ! !00024U03
!             message formats utilizing the VERSION NUMBER field in  ! !00024U04
!             the BIC ISO specific segment of the ICF: "01" which    ! !00024U05
!             equates to current^release^d ( "50" ) and "00" which   ! !00024U06
!             equates to previous^release^d ( "40" ).  Release 6.0   ! !00024U07
!             requires support for an additional external message    ! !00024U08
!             format ( "60" ).  Now the VERSION NUMBER will only     ! !00024U09
!             designate the release of the external message format,  ! !00024U0A
!             not the BASE24 release number.                         ! !00024U0B
! Fix:        Modified code to support multiple external message     ! !00024U0C
!             formats.  Modified code to reference                   ! !00024U0D
!             pct.options.version^num strictly when dealing with     ! !00024U0E
!             external message formats and to reference base24^rel^g ! !00024U0F
!             strictly when dealing with the release of the BASE24   ! !00024U0G
!             network.  Removed all references to defines            ! !00024U0H
!             current^release^d and previous^release^d and replaced  ! !00024U0I
!             them with the following new defines that were created  ! !00024U0J
!             to reflect the new versioning scheme:                  ! !00024U0K
!             Added defines:  release^6^frmt^d = "60"                ! !00024U0L
!                             release^5^frmt^d = "50"                ! !00024U0M
!                             release^4^frmt^d = "40"                ! !00024U0N
! Dependency: Apply fixes to BABICIG, BABICIS, BICIDDLS, RQBICIS,    ! !00024U0O
!             ATBICIS, PSBICIS and run MAKE.                         ! !00024U0P
! Reference:  WO #010129-01.                                         ! !00024U0Q
                                                                       !00024V00
! 16APR2001   DAH/1602-kjw/571   jds/1802                             !!00024V01
! Symptom:    Reversals sent to the network are rejected with an      !!00024V02
!             error in Field 15 (Settlement Date).                    !!00024V03
! Problem:    The interface is sending reversals to the network with  !!00024V04
!             Field 15 set to spaces.  This occurs when a reversal is !!00024V05
!             generated because a request sent to the network times-  !!00024V06
!             out.  Timeout processing is setting Field 15 to spaces  !!00024V07
!             instead of a valid settlement date.  This causes the    !!00024V08
!             network to reject the reversal.                         !!00024V09
! Fix:        Set the SEM Settlement Date to the correct network      !!00024V0A
!             settlement date for reversals.                          !!00024V0B
!             Modified procs: pos^tim^out^01^outbound^rqst            !!00024V0C
! Dependency: Apply fix to PSBICIS and remake.                        !!00024V0D
! Reference:  Retro of SW5F518 from Case #331022.                     !!00024V0E
                                                                       !00024W00
! 13JUN2001   jds/1802                                                !!00024W01
! Symptom:    The process was dumping when trying to add tokens that  !!00024W02
!             were already present.                                   !!00024W03
! Problem:    When formatting external messages to internal format the!!00024W04
!             acquirer routing token, transaction profile token and   !!00024W05
!             transaction description token needed to be deleted.     !!00024W06
! Fix:        Moved the code that calls pos_del_tkns to occur before  !!00024W07
!             the call to hiswpstm_txn_alwd_acq.                      !!00024W08
!             Procs Modified:  pos^frmt^sem^to^stm^0200               !!00024W09
!                              pos^frmt^sem^to^stm^0220               !!00024W0A
!                              pos^frmt^sem^to^stm^0402               !!00024W0B
! Dependency: Apply fix to PSBICIS, ATBICIS and run MAKE.             !!00024W0C
! Reference:  Case #335406                                            !!00024W0D
                                                                       !00024W0E
! 15JUN2001   jds/1802                                                !!00024W0F
! Symptom:    CSE Token support missing from this switch.             !!00024W0G
! Problem:    Same as symptom.                                        !!00024W0H
! Fix:        Added CSE Token support to this switch.                 !!00024W0I
! Dependency: Restore release 6.0 files, and modify the appropriate   !!00024W0J
!             CUSTMACS flags and run MAKE.                            !!00024W0K
! Reference:  Case #335556.                                           !!00024W0L
                                                                       !00024W0M
! 22JUN2001   jds/1802                                                !!00024W0N
! Symptom:    When sending a reversal an invalid destination message  !!00024W0O
!             was generated.                                          !!00024W0P
! Problem:    The parameters for the call to hiswsem_rvsl_txn_rte_pos !!00024W0Q
!             were not in the proper order. Also uninitialized        !!00024W0R
!             pointers existed that could cause global zero to be     !!00024W0S
!             overwritten.                                            !!00024W0T
! Fix:        Realigned the parameters for the call to                !!00024W0U
!             hiswsem_rvsl_txn_rte_pos. Correctly defined variable    !!00024W0V
!             auth_dest.                                              !!00024W0W
!             Procs modified:  pos^0420^reversal                      !!00024W0X
!                              pos^failed^0x10^sem^resp               !!00024W0Y
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024W0Z
! Reference:  Case #335979.                                           !!00024W10
                                                                       !00024X00
! 02AUG2001   jds/1802                                                !!00024X01
! Symptom:    BIC ISO currently maps an external response code of "01"!!00024X02
!             to an internal response code of "088".                  !!00024X03
! Problem:    The external response code of "01" should be mapped to  !!00024X04
!             an internal response code of "101" issue call.          !!00024X05
! Fix:        Modified the response table to map a "01" external      !!00024X06
!             response code to a "101" internal response code.        !!00024X07
!             Procs modified:  pos^frmt^sem^to^pstm^0210              !!00024X08
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024X09
! Reference:  Case #335811.                                           !!00024X0A
                                                                       !00024Y00
! 06AUG2001   DOO/1693                                                !!00024Y01
! Symptom:    The interface abends when processing a PSTM 0210        !!00024Y02
!             response message.                                       !!00024Y03
! Problem:    The test on the internal field PSTM.DATA^FLAG in the    !!00024Y04
!             0200 request message to determine if the USER-DATA field!!00024Y05
!             is included in the internal message is incorrect.  It   !!00024Y06
!             assumes that the former is an integer.  Consequently,   !!00024Y07
!             the test always returns true.  When the USER-DATA field !!00024Y08
!             does not exist, the length of the PSTM will be incorrect!!00024Y09
!             causing memory to be overwritten and the interface to   !!00024Y0A
!             abend.                                                  !!00024Y0B
! Fix:        Modified the code to check if the value of the internal !!00024Y0C
!             field PSTM.DATA^FLAG is not equal to "0" which implies  !!00024Y0D
!             that the USER-DATA field is appended to the message.    !!00024Y0E
!             Only when this condition is met does the code           !!00024Y0F
!             recalculate the length of the PSTM.                     !!00024Y0G
!             Modified Procedure: PSTM^0200^REQUEST                   !!00024Y0H
! Dependency: Apply fix to PSBICIS and remake.                        !!00024Y0I
! Reference:  Case #337316.                                           !!00024Y0J
                                                                       !00024Z00
! 24AUG2001   RAF/100     cal/283                                     !!00024Z01
! Symptom:    Transactions are not being alternate routed when the    !!00024Z02
!             transaction has been Sproute routed to BICI and the     !!00024Z03
!             Bic link is down.                                       !!00024Z04
! Problem:    The interface is not checking if a transaction has been !!00024Z05
!             Sproute routed when looking for alternate destinations. !!00024Z06
!             Because of this, the transaction is not being alternate !!00024Z07
!             routed correctly.                                       !!00024Z08
! Fix:        Modified the interface to check for Sproute routed      !!00024Z09
!             transactions, pstm.auth^ind = "F", when determining if  !!00024Z0A
!             a transaction qualifies for alternate routing.          !!00024Z0B
!             Modified procs: pstm^0200^route.                        !!00024Z0C
! Dependency: Apply fix to PSBICIS and remake.                        !!00024Z0D
! Reference:  Retro of scn SW5P529 for Case #336172.                  !!00024Z0E
                                                                       !00024Z0F
! 24AUG2001   CHH/174     cal/283                                     !!00024Z0G
! Symptom:    Pre-authorization/completion with Cashback Support.     !!00024Z0H
! Problem:    None.                                                   !!00024Z0I
! Fix:        Modified code to pass amount 2 from the POS internal    !!00024Z0J
!             message when there is a cashback transaction using      !!00024Z0K
!             pre-authorizations or completions.                      !!00024Z0L
!             Procs modified:   POS^FRMT^SEM^TO^PSTM^AMT,             !!00024Z0M
!                               PSTM^FRMT^B24^TO^POS^AMT.             !!00024Z0N
! Dependency: Apply fixes to PSBICIS the re-Make.                     !!00024Z0O
! Reference:  Retro of scn SW5P578 for Case #336877.                  !!00024Z0P
                                                                       !00024Z0Q
                                                                       !00024a00
! 08JAN2002   JJD/615                                                ! !00024a01
! Symptom:    Uplift DUKPT to Release 6.0                            ! !00024a02
! Problem:    None.                                                  ! !00024a03
! Fix:        Added support for the Derived Unique Key Per           ! !00024a04
!             Transaction (DUKPT) security management scheme.        ! !00024a05
!             Modified Proc: pstm^frmt^b24^to^pos^0200               ! !00024a06
! Dependency: Apply fix to PSBICIS and reMAKE.                       ! !00024a07
! Reference:  WO #011003-04                                          ! !00024a08
                                                                       !00024b00
! 19FEB2002   jds/1802                                                !!00024b01
! Symptom:    The extenal message did not have the correct approval   !!00024b02
!             code when the appoval code was blanks.                  !!00024b03
! Problem:    The sem approval code field was only 6 bytes and it was !!00024b04
!             being mapped to the pstm approval code field of 8 bytes.!!00024b05
!             If blanks were moved in it did not fill the whole       !!00024b06
!             extenal field and RTAU could not read it correctly.     !!00024b07
! Fix:        Initialize the PSTM approval code field to blanks prior !!00024b08
!             to moving the sem approval code field to the PSTM.      !!00024b09
!             Proc modified:   pos^frmt^sem^to^pstm^0210              !!00024b0A
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024b0B
! Reference:  Case #343643.                                           !!00024b0C
                                                                       !00024c00
! 26JUN2002   CHH/174                                                 !!00024c01
! Symptom:    MAC verification fails on transactions from co-network  !!00024c02
!             when the security device type is TSS.                   !!00024c03
! Problem:    BIC ISO Interface always MACs MAC key change messages   !!00024c04
!             using the key being changed.  TSS, on the other hand,   !!00024c05
!             always verifies MACs using the inbound key unless told  !!00024c06
!             which key direction should be used.  BIC ISO Interface  !!00024c07
!             doesn't provide this information to TSS.                !!00024c08
! Fix:        Added code to explicitly pass the key direction in the  !!00024c09
!             call to UTIL^MAC^VERIFY.                                !!00024c0A
!             Procs modified:                                         !!00024c0B
!                 pos^util^sem^expand                                 !!00024c0C
! Dependency: Apply fixes to BABICIS, ATBICIS, PSBICIS and            !!00024c0D
!             re-Make.  Replace BABILOGM.                             !!00024c0E
! Reference:  Case #349666                                            !!00024c0F
                                                                       !00024d00
! 08OCT2002   kjw/571                                                 !!00024d01
! Symptom:    Field 95 is missing in purchase adjustments.            !!00024d02
! Problem:    When collapsing an external message field 95 is toggled !!00024d03
!             on if it contains zeroes, but bit for the secondary     !!00024d04
!             bitmap may not be on. If the secondary bitmap bit is not!!00024d05
!             toggled on field 95 cannot be sent.                     !!00024d06
! Fix:        Added code to toggle on secondary bitmap when field 95  !!00024d07
!             is toggled on.                                          !!00024d08
!             Procs modified:                                         !!00024d09
!                 pos^util^sem^collapse                               !!00024d0A
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024d0B
! Reference:  Case #350245                                            !!00024d0C
                                                                       !00024d0D
                                                                       !00024e00
! 25NOV2002   DOO/1693                                                !!00024e01
! Symptom:    Multiple Currency, Format 2, Discretionary Data, and    !!00024e02
!             Switch Token Enhancements.                              !!00024e03
! Problem:    None.                                                   !!00024e04
! Fix:        1.  Added Multiple Currency compatibility support.      !!00024e05
!             Modified procs: POS^UTIL^UPDT^SETL^TTLS                 !!00024e06
!                             PSTM^FRMT^B24^TO^POS^AMT                !!00024e07
!             2.  Added Format 2 file support.                        !!00024e08
!             Modified procs: (coming up)                             !!00024e09
!             3.  Added Switch Token Support                          !!00024e0A
!             Modified procs: POS^0200^REQUEST                        !!00024e0B
!                             POS^0210^RESPONSE                       !!00024e0C
!                             POS^0220^ADVICE                         !!00024e0D
!                             POS^0402^REQUEST                        !!00024e0E
!                             POS^0420^REVERSAL                       !!00024e0F
!                             POS^FAILED^0X10^SEM^RESP                !!00024e0G
!                             PSTM^0200^DENY                          !!00024e0H
!                             PSTM^0200^ROUTE                         !!00024e0I
! Dependency: Apply fixes to DDLFICFE, RQICFES, SCRNICFE, BICIDDLM,   !!00024e0J
!             BICIDDLS, BABICIS, BABICIG, ATBICIS, and PSBICIS and    !!00024e0K
!             re-MAKE.  Replace BABILOGM.                             !!00024e0L
! Reference:  WO #020627-01                                           !!00024e0M
                                                                       !00024e0N
                                                                       !00024f00
! 08JAN2003   DOO/1693                                                !!00024f01
! Symptom:    CAF and PBF totals are not being updated correctly for  !!00024f02
!             Multiple Currency transactions.  The amounts fields are !!00024f03
!             still set to zeroes when the transaction is sent to the !!00024f04
!             authorization process.                                  !!00024f05
! Problem:    When the Multiple Currency field on ICFE screen 3 is set!!00024f06
!             to "Y", the code skips the procedure that does the      !!00024f07
!             currency conversion for single currency transactions.   !!00024f08
!             This procedure also sets the amount fields.             !!00024f09
! Fix:        Modified the code to only skip the code that does the   !!00024f0A
!             currency conversion rather than the entire procedure.   !!00024f0B
!             Modified procs: POS^FRMT^SEM^TO^PSTM^AMT                !!00024f0C
!                             PSTM^FRMT^B24^TO^POS^AMT                !!00024f0D
! Dependency: Apply fixes ATBICIS and PSBICIS and re-MAKE.            !!00024f0E
! Reference:  Case #357509                                            !!00024f0F
                                                                       !00024g00
! 06FEB2003   ahs/3152   gg/724                                       !!00024g01
! Symptom:    The interface dumps due to token expansion errors.      !!00024g02
! Problem:    When the interface is moving data from the PSTM to the  !!00024g03
!             suspense buffer, it was incorrectly moving half the     !!00024g04
!             data because it used the word length instead of byte    !!00024g05
!             length.  Consequently, a part of the token at the end   !!00024g06
!             of the PSTM message was not moved to the suspense       !!00024g07
!             buffer.  The suspense buffer would contain garbage and  !!00024g08
!             the token expansion procs would fail.  The same         !!00024g09
!             problem also occurs when moving the data from the       !!00024g0A
!             suspense buffer to the PSTM.                            !!00024g0B
! Fix:        Modified the interface to move the correct amount of    !!00024g0C
!             data.                                                   !!00024g0D
!             Modified procs: pos^0210^response                       !!00024g0E
!                             pstm^0200^request                       !!00024g0F
! Dependency: Apply fixes to PSBICIS and re-MAKE.                     !!00024g0G
! Reference:  (retro of SCN SW5P726 from Case #346333)                !!00024g0H
                                                                       !00024g0I
! 06FEB2003   ahs/3152   gg/724                                       !!00024g0J
! Symptom:    Incorrect number of bytes moved to the suspense buffer  !!00024g0K
!             from a POS internal request message.                    !!00024g0L
! Problem:    The interface used the length of the susp.msg field     !!00024g0M
!             for the move operation.  This field is defined as a     !!00024g0N
!             binary 16, repeated 1990 times.  Therefore the length   !!00024g0O
!             of susp.msg actually equals two bytes, resulting in only!!00024g0P
!             the first two bytes of the internal message to be       !!00024g0Q
!             stored in the suspense record.                          !!00024g0R
! Fix:        Modified the interface to use the XPNET message length  !!00024g0S
!             (msg^length) to determine the actual length of the      !!00024g0T
!             message to move to the suspense buffer.  This length    !!00024g0U
!             also includes any tokens added to the message.          !!00024g0V
!             Modified proc: pstm^0200^request                        !!00024g0W
! Dependency: Apply fixes to PSBICIS and re-MAKE.                     !!00024g0X
! Reference:  (retro of SCN SW5P741 from Case #346333)                !!00024g0Y
                                                                       !00024g0Z
! 06FEB2003   ahs/3152   gg/724                                       !!00024g0a
! Symptom:    Some acquired Laser card transactions are automatically !!00024g0b
!             reversed by the interface.                              !!00024g0c
! Problem:    Laser transactions do not send P-22 (POS Entry Mode) in !!00024g0d
!             the 0210 reply message.  The interface relies on this   !!00024g0e
!             field and/or checking the external message track2       !!00024g0f
!             discretionary data to set the first character of the    !!00024g0g
!             track2 to "M" for manual entry, if applicable.  Since   !!00024g0h
!             P-22 is not included, this card entry character could   !!00024g0i
!             not be set based on it.  The check for track2           !!00024g0j
!             discretionary data consisting of only the expiration    !!00024g0k
!             date should have set the first character of the track2  !!00024g0l
!             to "M", but was not executed because the code prior     !!00024g0m
!             checked for non-blank track1 data instead of non-blank  !!00024g0n
!             track2 data.   Since track2 is part of the prikey and   !!00024g0o
!             the response track2 did not match the request track2,   !!00024g0p
!             the interface was unable to locate the suspended        !!00024g0q
!             request so a reversal was generated and sent to the     !!00024g0r
!             co-network.                                             !!00024g0s
! Fix:        Modified the interface to check for non-blank track2    !!00024g0t
!             data.                                                   !!00024g0u
!             Modified proc:  pos^frmt^sem^to^pstm^acct               !!00024g0v
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024g0w
! Reference:  (retro of SCN SW5P747 from Case #347996)                !!00024g0x
                                                                       !00024g0y
                                                                       !00024h00
! 11APR2003   RAF/100                                                 !!00024h01
! Symptom:    Manually entered cards are not marked as such on the    !!00024h02
!             PTLF.                                                   !!00024h03
! Problem:    The interface is using field 22 (POS entry Mode) to     !!00024h04
!             determine if a card is manually entered in an external  !!00024h05
!             response message.  But this field is not mandatory in   !!00024h06
!             this message.  When it is not sent, the card is not     !!00024h07
!             marked as a manually entered one.                       !!00024h08
! Fix:        Modified the interface to check the original request    !!00024h09
!             message to determine if a card is manually entered on   !!00024h0A
!             external response messages.                             !!00024h0B
!             Modified proc:  pos^frmt^sem^to^pstm^acct.              !!00024h0C
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024h0D
! Reference:  Case #360932.                                           !!00024h0E
                                                                       !00024h0F
                                                                       !00024i00
! 21MAY2003   BN/517                                                  !!00024i01
! Symptom:    Some amount fields are not converted to the correct     !!00024i02
!             currency when multiple currencies are involved in       !!00024i03
!             the transaction path.                                   !!00024i04
! Problem:    Amount fields were not being converted when P-50 is     !!00024i05
!             not present even though a conversion is required.       !!00024i06
!             Added extra error checking on currency codes.           !!00024i07
! Fix:        Modified procs:                                         !!00024i08
!                 pos^frmt^sem^to^pstm                                !!00024i09
!                 pos^frmt^sem^to^pstm^0200                           !!00024i0A
!                 pos^frmt^sem^to^pstm^amt                            !!00024i0B
!                 pstm^frmt^b24^to^pos^0200                           !!00024i0C
!                 pstm^frmt^b24^to^pos^amt                            !!00024i0D
! Dependency: Apply fix to ATBICIS and PSBICIS and re-MAKE.           !!00024i0E
! Reference:  Case #363396                                            !!00024i0F
                                                                       !00024i0G
                                                                       !00024j00
! 04JUN2003   BN/517                                                  !!00024j01
! Symptom:    Enhancement to support Irish Reciprocity.               !!00024j02
! Problem:    None.                                                   !!00024j03
! Fix:        Enhanced mapping of Institution ID values.              !!00024j04
!             Modified procs:                                         !!00024j05
!                 pos^frmt^sem^to^pstm                                !!00024j06
!                 pos^frmt^sem^to^pstm^0210                           !!00024j07
!                 pos^frmt^sem^to^pstm^amt                            !!00024j08
!                 pstm^frmt^b24^to^pos^0210                           !!00024j09
!                 pstm^frmt^b24^to^pos^sem                            !!00024j0A
!             Added procs:                                            !!00024j0B
!                 pos^util^frmt^enhanced^rc                           !!00024j0C
!                 pos^util^orig^crncy^tkn^add                         !!00024j0D
! Dependency: Apply fix to ATBICIS, BABICIG, BABICIS, BICIDDLS,       !!00024j0E
!             PSBICIS and re-MAKE.                                    !!00024j0F
! Reference:  WO #030504-06                                           !!00024j0G
                                                                       !00024j0H
                                                                       !00024k00
! 03SEP2003   DOO/1693                                                !!00024k01
! Symptom:    1. The interface dumps with Trap #2 when adding the     !!00024k02
!             switch token on a failed response.                      !!00024k03
!             2. The interface adds the switch token when processing a!!00024k04
!             reversal request from the interchange.                  !!00024k05
! Problem:    1. The internal message buffer, PSTM, is initialized to !!00024k06
!             spaces or possibly junk.  As result when the interface  !!00024k07
!             attempts to calculate the length of the PSTM it fails   !!00024k08
!             because the offset to the allowed services is never     !!00024k09
!             found.                                                  !!00024k0A
!             2. The switch token is already in the internal message  !!00024k0B
!             so there is no need to add it again.                    !!00024k0C
! Fix:        1. Removed the code that adds the switch token on a     !!00024k0D
!             failed message response.                                !!00024k0E
!             2. Removed the code that adds the switch token when     !!00024k0F
!             processing a reversal request from the interchange.     !!00024k0G
!             Modified procs: POS^0420^REVERSAL                       !!00024k0H
!                             POS^FAILED^0X10^SEM^RESP                !!00024k0I
! Dependency: Apply fixes to ATBICIS, BABICIS, and PSBICIS and run    !!00024k0J
!             MAKE.                                                   !!00024k0K
! Reference:  Case #367372                                            !!00024k0L
                                                                       !00024k0M
                                                                       !00024l00
! 15OCT2003   BN/517                                                  !!00024l01
! Symptom:    Enhancement to Support Irish Reciprocity.               !!00024l02
! Problem:    None.                                                   !!00024l03
! Fix:        Utilise settlement amount fields for Additional         !!00024l04
!             Amounts (P-54) and Replacement Amounts (S-95).          !!00024l05
!             Modified procs:                                         !!00024l06
!                 pos^frmt^sem^to^pstm^amt                            !!00024l07
!                 pos^util^orig^crncy^tkn^add                         !!00024l08
!                 pstm^frmt^b24^to^pos^amt                            !!00024l09
! Dependency: Apply fix to ATBICIS, DDLGISO, PSBICIS and re-MAKE.     !!00024l0A
! Reference:  WO #030504-06                                           !!00024l0B
                                                                       !00024l0C
                                                                       !00024m00
! 15OCT2003   BN/517                                                  !!00024m01
! Symptom:    Default value is used to set receiving institution id   !!00024m02
!             field in PSTM on incoming requests/advices from the     !!00024m03
!             co-network, which is also done by POS Router/Auth.      !!00024m04
! Problem:    Default value processing for receiving institution id   !!00024m05
!             field is already performed by POS Router/Auth.          !!00024m06
! Fix:        Remove code that sets default value for receiving       !!00024m07
!             institution id field in the PSTM on incoming request/   !!00024m08
!             advices from the co-network.                            !!00024m09
!             Modified proc:                                          !!00024m0A
!                 pos^frmt^sem^to^pstm                                !!00024m0B
! Dependency: Apply fix to ATBICIS, PSBICIS and re-MAKE.              !!00024m0C
! Reference:  Case #370417                                            !!00024m0D
                                                                       !00024m0E
                                                                       !00024n00
! 29DEC2003   engelk                                                  !!00024n01
! Symptom:    Interface dumped with trap 1839 while attempting to     !!00024n02
!             delete the BA token.                                    !!00024n03
! Problem:    The PSTM user data was not taken into account when      !!00024n04
!             initializing the buffer which left a token eye catcher  !!00024n05
!             in the buffer.                                          !!00024n06
! Fix:        Sourced in the user^buf definition and modified the     !!00024n07
!             PSTM initialization to include its length.              !!00024n08
!             Procs modified:  pos^frmt^sem^to^pstm                   !!00024n09
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024n0A
! Reference:  Case #366596.                                           !!00024n0B
                                                                       !00024o00
! 11FEB2004   shahb                                                   !!00024o01
! Symptom:    The transaction is not sent to the alternate authorizer !!00024o02
!             when using SPROUTE routing if the primary authorizer is !!00024o03
!             unavailable.                                            !!00024o04
! Problem:    The correct authorization indicators in the PSTM RTE    !!00024o05
!             substructure are not being checked and reset correctly. !!00024o06
! Fix:        If the transaction has not been routed to the interface !!00024o07
!             via a second RTAU module, the interface will check and  !!00024o08
!             reset pstm.rte.auth^ind.                                !!00024o09
!             Procs modified: pstm^0200^route                         !!00024o0A
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024o0B
! Reference:  Case #374073                                            !!00024o0C
                                                                       !00024p00
! 30MAR2004   wielerk                                                 !!00024p01
! Symptom:    Dynamic key Management is working incorrectly with      !!00024p02
!             MAC turned on.                                          !!00024p03
! Problem:    The utilities that format the message to the secure     !!00024p04
!             device use a literal with a value of 16 to assign the   !!00024p05
!             MAC key. For keys of 32 bytes, this causes an invalid   !!00024p06
!             MAC key to be used.                                     !!00024p07
! Fix:        Modified the module to pass the MAC key length which is !!00024p08
!             configured to the secure utilities.                     !!00024p09
!             Procs Modified: pos^util^xlate^mac^generate             !!00024p0A
! Dependency: Apply fix to BABICIS, ATBICIS, PSBICIS, BAHISOS,        !!00024p0B
!             ATHISOS, PSHISOS, HISWUTLS, and SECUTILS                !!00024p0C
!             and run MAKE.                                           !!00024p0D
! Reference:  Case #369610.                                           !!00024p0E
                                                                       !00024p0F
                                                                       !00024q00
! 13JUL2004   frederr                                                 !!00024q01
! Symptom:    Transactions are not being forwarded by the interface.  !!00024q02
! Problem:    If the 6.0 interface is run in a 5x network, the        !!00024q03
!             multi-currency flag is set to 'N'.  When this flag is   !!00024q04
!             set to 'N' the interface does not allow transactions    !!00024q05
!             with different external and internal currency codes to  !!00024q06
!             pass.  These checks should only be done in a 6x         !!00024q07
!             network.                                                !!00024q08
! Fix:        Modified the interface to only do currency code checks  !!00024q09
!             when the interface is being used in a 6x network.       !!00024q0A
!             Procs Modified:  pos^frmt^sem^to^pstm^0200              !!00024q0B
!                              pos^frmt^sem^to^pstm^amt               !!00024q0C
!                              pstm^frmt^b24^to^pos^0200              !!00024q0D
!                              pstm^frmt^b24^to^pos^amt               !!00024q0E
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024q0F
! Reference:  Case #381358.                                           !!00024q0G
                                                                       !00024q0H
                                                                       !00024r00
! 16MAY2005   HayesE                                                  !!00024r01
! Symptom:    Balance enquiry transactions with negative amount are   !!00024r02
!             being rejected.                                         !!00024r03
! Problem:    If the settlement currency and transaction currency     !!00024r04
!             are different, an attempt is made to convert the        !!00024r05
!             negative amount from ascii to fixed, using proc         !!00024r06
!             ascii^fixed^, which does not handle negative amounts.   !!00024r07
!                                                                     !!00024r08
! Fix:        Modified the code to remove the negative symbol from    !!00024r09
!             the amount field, set an indicator that the amount is   !!00024r0A
!             negative, then revert to a negative amount after the    !!00024r0B
!             conversion.                                             !!00024r0C
!             Procs Modified:  pos^frmt^sem^to^pstm^amt               !!00024r0D
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024r0E
! Reference:  Case #393369.                                           !!00024r0F
                                                                       !00024s00
! 02JUN2005   wielerk                                                 !!00024s01
! Symptom:    Reversals sent for late responses are rejected by the   !!00024s02
!             co-network.                                             !!00024s03
! Problem:    The bitmap for the 0420 indicates fields 17,22 and 25   !!00024s04
!             are turned on but these fields are not returned in the  !!00024s05
!             late response. The fields are sent with spaces although !!00024s06
!             DDLs indicate numeric fields.                           !!00024s07
! Fix:        Modified the code to send zeroes in reversals if fields !!00024s08
!             17,22 or 25 are not present in the response.            !!00024s09
!             Procs Modified:  pos^0210^deny                          !!00024s0A
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024s0B
! Reference:  Case #393038.                                           !!00024s0C
                                                                       !00024s0D
                                                                       !00024t00
! 08JUN2005   MurdocK                                                 !!00024t01
! Symptom:    BICI interface dumps when it receives chip top-up       !!00024t02
!             message.                                                !!00024t03
! Problem:    Incorrect number of bytes moved from the suspense       !!00024t04
!             buffer to a POS internal request message.               !!00024t05
! Fix:        Modified the move of the susp.msg to the pstm to move   !!00024t06
!             the correct length.                                     !!00024t07
!             Procs Modified:  pos^0210^response                      !!00024t08
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024t09
! Reference:  Case #396255.                                           !!00024t0A
                                                                       !00024u00
! 08JUN2005   wielerk                                                 !!00024u01
! Symptom:    Customer canceled reversals do not always get sent to   !!00024u02
!             the correct BICI interface if more than one is          !!00024u03
!             configured.                                             !!00024u04
! Problem:    The interface is not placing net.myname in the correct  !!00024u05
!             PSTM.RTE fields when the 0200 is received.              !!00024u06
! Fix:        Modified the interface to set the correct PSTM.RTE      !!00024u07
!             fields so it can be returned in the PSTM 0210.          !!00024u08
!             Procs Modified:  pstm^0200^request                      !!00024u09
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024u0A
! Reference:  Case #394047.                                           !!00024u0B
                                                                       !00024v00
! 05JUL2005   gordonj                                                 !!00024v01
! Symptom:    Sending wrong data in P-5 and P-50 in SEM 0420 for SPDH !!00024v02
!             customer cancelled reversal.                            !!00024v03
! Problem:    Cannot rely on the SPDH process being able to fill the  !!00024v04
!             setl^crncy^cde and setl^conv^rate in the PSTM reversal  !!00024v05
!             with the values from the original STM response.  For a  !!00024v06
!             customer-cancelled reversal, the PSTM setl^crncy^cde    !!00024v07
!             from SPDH may be the same as the orig^crncy^cde so the  !!00024v08
!             interface needs do the necessary conversion.            !!00024v09
! Fix:        Modified the interface to apply the PCT currency code   !!00024v0A
!             and conversion rate unconditionally for PSTM reversal   !!00024v0B
!             advices.                                                !!00024v0C
!             Procs Modified:  pstm^frmt^b24^to^pos^amt               !!00024v0D
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024v0E
! Reference:  Case #393353.                                           !!00024v0F
                                                                       !00024w00
! 12JUL2005   gordonj                                                 !!00024w01
! Symptom:    BE token formatted using transaction currency rather    !!00024w02
!             than original SEM token data for incoming 0220 advice.  !!00024w03
! Problem:    If the psem.crncy^cde <> local^crncy^cde^g then the     !!00024w04
!             BE token is already added to the PSTM before the SEM    !!00024w05
!             token data (P-63) is processed, and the token does not  !!00024w06
!             get updated.                                            !!00024w07
! Fix:        When processing SEM token data, before invoking         !!00024w08
!             hiswtkn^frmt^ext^tkn^to^int^tkn first set the relevant  !!00024w09
!             flag for PSTM 0220 (like for PSTM 0420) to ensure that  !!00024w0A
!             tokens which already exist get updated.                 !!00024w0B
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024w0C
! Reference:  Case #395065.                                           !!00024w0D
                                                                       !00024w0E
                                                                       !00024x00
! 15AUG2005   frederr                                                 !!00024x01
! Symptom:    POS Swiped transactions are being sent inbound with the !!00024x02
!             1st position of Track 2 set to a "M".  This indicates a !!00024x03
!             manually entered transaction.                           !!00024x04
! Problem:    PSBICIS is checking the discretionary data portion of   !!00024x05
!             track 2 (DE-35) to determine if a transaction is        !!00024x06
!             manually entered or swiped.  If the track 2             !!00024x07
!             discretionary data contains only the expiration date,   !!00024x08
!             then the interface is modifying the PSTM's Track 2 to   !!00024x09
!             have a "M" in position 1.                               !!00024x0A
! Fix:        Modified the interface to not check the discretionary   !!00024x0B
!             data of track 2 to decide if a card is manually entered.!!00024x0C
!             Proc Modified:  pos^frmt^sem^to^pstm^acct.              !!00024x0D
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024x0E
! Reference:  Case #399426.                                           !!00024x0F
                                                                       !00024x0G
                                                                       !00024y00
! 06OCT2005   MurdocK                                                 !!00024y01
! Symptom:    (1) POS pre-auth response declined with PSTM response   !!00024y02
!                 code "76".                                          !!00024y03
!             (2) Pre-auth logged to PTLF with invalid transaction    !!00024y04
!                 code "10".                                          !!00024y05
! Problem:    (1) POS pre-auth was declined because currency          !!00024y06
!                 conversion caused the approved amount to be less    !!00024y07
!                 than the requested amount.                          !!00024y08
!             (2) Tran code for pre-auths should be "11".             !!00024y09
! Fix:        (1) Modified check for a pre-auth approved for a        !!00024y0A
!                 lesser amount.                                      !!00024y0B
!                 Modified pre^auth^flag to be declared as INT.       !!00024y0C
!             (2) Modified call to pos^frmt^sem^to^pstm^tran in       !!00024y0D
!                 proc pos^0210^deny.                                 !!00024y0E
!             Procs Modified:  pos^frmt^sem^to^pstm^amt               !!00024y0F
!                              pos^0210^response                      !!00024y0G
!                              pos^0210^deny                          !!00024y0H
! Dependency: Apply fix to PSBICIS and re-MAKE.                       !!00024y0I
! Reference:  Case #395678.                                           !!00024y0J
                                                                       !00024y0K
                                                                       !00024z00
! 14OCT2005   steffesj                                                !!00024z01
! Symptom:    Mobile Top-Up POS Acquiring Integration Enhancement     !!00024z02
! Problem:    None.                                                   !!00024z03
! Fix:        Added support for new reversal code "40" (Split Routing !!00024z04
!             Enabled; Secondary Service Not Approved).  It will map  !!00024z05
!             to the ISO value of "U6".                               !!00024z06
!             Procs modified:                                         !!00024z07
!                 pos^frmt^sem^to^pstm^0420                           !!00024z08
!                 pstm^frmt^b24^to^pos^0420                           !!00024z09
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024z0A
!             Refer to BA60UD09.SCNMTOPP for a complete listing of    !!00024z0B
!             dependencies.                                           !!00024z0C
! Reference:  WO #041224-01                                           !!00024z0D
                                                                       !00024z0E
                                                                       !00024#00
! 01DEC2005   frederr                                                 !!00024#01
! Symptom:    The PSTM's original data fields are not being populated !!00024#02
!             on reversal messages.                                   !!00024#03
! Problem:    The interface is not populating PSTM original data      !!00024#04
!             fields on reversal messages.                            !!00024#05
! Fix:        Modified the interface to populate the PSTM original    !!00024#06
!             data fields when the ILF is expanded.                   !!00024#07
!             Proc modified:  pos^util^ilf^expand.                    !!00024#08
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024#09
! Reference:  Case #403080.                                           !!00024#0A
                                                                       !00024$00
! 05DEC2005   wielerk                                                 !!00024$01
! Symptom:    Stand-in not working after applying SCN SW09414.        !!00024$02
! Problem:    The interface was setting routing fields prior to any   !!00024$03
!             stand-in logic being executed. This prevented RTAU from !!00024$04
!             attempting stand-in authorization.                      !!00024$05
! Fix:        Modified the interface to set the routing fields after  !!00024$06
!             receiving the external response allowing the stand-in   !!00024$07
!             to take place when appropriate.                         !!00024$08
!             Proc Modified:  pos^0210^response                       !!00024$09
!                             pstm^0200^request                       !!00024$0A
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024$0B
! Reference:  Case #400172.                                           !!00024$0C
                                                                       !00024$0D
                                                                       !00024#0B
                                                                       !00024v0G
                                                                       !00024u0C
                                                                       !00024t0B
                                                                       !00024r0G
                                                                       !00024o0D
                                                                       !00024n0C
                                                                       !00024f0G
                                                                       !00024c0G
                                                                       !00024b0D
                                                                       !00024a09
                                                                       !00024Y0K
                                                                       !00024X0B
                                                                       !00024W11
                                                                       !00024V0F
                                                                       !00024U0R
                                                                       !00024T0B
                                                                       !00024S0T
                                                                       !00024R0E
                                                                       !00024Q0D
                                                                       !00024N0B
                                                                       !00024M8A
                                                                       !00024S0U
                                                                       !00024%00
! 03JAN2006   sharana                                                 !!00024%01
! Symptom:    Incorrect conversion of amount in advise reversal       !!00024%02
!             (Message type 0420) transaction where setup supports    !!00024%03
!             the conversion of currency between two co-networks.     !!00024%04
! Problem:    Reversal transaction was converting pstm.tran.amt-1     !!00024%05
!             using pstm.tran.mult^crncy.auth^conv^rate rate. It      !!00024%06
!             should use pct.crncy.sell^rate.                         !!00024%07
! Fix:        Call to sub^convert^fixed^amt was modified to pass      !!00024%08
!             pct.crncy.sell^rate for multi currency reversal         !!00024%09
!             transaction.                                            !!00024%0A
!             Procs modified: pos^frmt^sem^to^pstm^amt                !!00024%0B
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024%0C
! Reference:  Case #399473                                            !!00024%0D
                                                                       !00024%0E
                                                                       !00024&00
! 09FEB2006   jadhavu                                                 !!00024&01
! Symptom:    Response codes are mapped incorrectly.                  !!00024&02
! Problem:    Base24 referral response codes 101 issue call interface !!00024&03
!             is mapping as 02 refer to card issuer special condition.!!00024&04
! Fix:        Modified the interface to map referral response code 101!!00024&05
!             issue call to 01 refer to card issuer.                  !!00024&06
!             Proc Modified:  pstm^frmt^b24^to^pos^0210               !!00024&07
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024&08
! Reference:  Case #405966.                                           !!00024&09
                                                                       !00024&0A
                                                                       !00024*00
! 21MAR2006   wielerk                                                 !!00024*01
! Symptom:    CAF/PBF balance updates not processing correctly after  !!00024*02
!             applying SCN SW0A028.                                   !!00024*03
! Problem:    RTAU requires PSTM.RTE.PRI to be equal AUTHH to update  !!00024*04
!             CAF/PBF. If transaction is approved online via BIC,     !!00024*05
!             PSTM.RTE.PRI is set to net.myname preventing balance    !!00024*06
!             updates.                                                !!00024*07
! Fix:        Removed code which sets PSTM.RTE.PRI when formatting a  !!00024*08
!             response back to BASE24.                                !!00024*09
!             Proc Modified:  pos^0210^response                       !!00024*0A
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024*0B
! Reference:  Case #408926.                                           !!00024*0C
                                                                       !00024*0D
                                                                       !00024+00
! 24MAR2006   engelk                                                  !!00024+01
! Symptom:    1)  In PSTM request messages, the original tran time    !!00024+02
!                 contained part of the original tran date in the     !!00024+03
!                 last 2 bytes.                                       !!00024+04
!             2)  In PSTM 0420 reversal messages, the original tran   !!00024+05
!                 data is formatted incorrectly:                      !!00024+06
!                 a)  the original tran date contains the YYMM of the !!00024+07
!                     actual tran date                                !!00024+08
!                 b)  the first two bytes of the transaction sequence !!00024+09
!                     number are overwritten by the last two bytes of !!00024+0A
!                     the actual tran date                            !!00024+0B
!                 c)  the original base24 post date contains the YYMM !!00024+0C
!                     of the posting date and the PSTM's reason for   !!00024+0D
!                     chargeback contains the DD of the posting date  !!00024+0E
! Problem:    1)  When the PSTM's tran time was loaded based upon the !!00024+0F
!                 ISO SEM's tran time (P-12), a move was performed for!!00024+0G
!                 the maximum of the lengths of the two fields.       !!00024+0H
!                 However, the SEM tran time is only 6 bytes long and !!00024+0I
!                 the PSTM's original tran time was 8 bytes long.     !!00024+0J
!             2)  When the ILF record for the transaction is          !!00024+0K
!                 retrieved, the original data date fields are filled !!00024+0L
!                 in based upon the tran date and the posting date    !!00024+0M
!                 stored on the ILF.  The dates stored on the ILF     !!00024+0N
!                 are in YYMMDD format and the dates in the original  !!00024+0O
!                 data field are in MMDD format.  Also, these moves   !!00024+0P
!                 were done for the maximum of the lengths of the two !!00024+0Q
!                 fields.                                             !!00024+0R
! Fix:        1)  Modified the code to do a move for the minimum of   !!00024+0S
!                 the lengths of the two tran time fields.            !!00024+0T
!             2)  Modified the code to move the tran and posting      !!00024+0U
!                 dates into the original date fields after skipping  !!00024+0V
!                 the YY and using the length of the shorter field.   !!00024+0W
!             Changed all of the move for the maximum of the lengths  !!00024+0X
!             of the two fields to moves for the minimum when moving  !!00024+0Y
!             data into the original data fields.                     !!00024+0Z
!             Procs modified:  pos^0210^deny                          !!00024+0a
!                              pos^frmt^sem^to^pstm                   !!00024+0b
!                              pos^frmt^sem^to^pstm^0210              !!00024+0c
!                              pos^util^ilf^expand                    !!00024+0d
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024+0e
! Reference:  Case #409740                                            !!00024+0f
                                                                       !00024+0g
                                                                       !00024-00
! 29MAR2006   humphrk                                                 !!00024-01
! Symptom:    Offline PIN transactions are being declined with        !!00024-02
!             response code 096 (Pin Required).                       !!00024-03
! Problem:    The interface does not indicate whether a PIN has       !!00024-04
!             already been verified for POS transactions.             !!00024-05
! Fix:        Set pstm.pin^tries to "Z" and fill psem.pin with pad    !!00024-06
!             characters to indicate that a PIN was entered.          !!00024-07
!             Proc Modified: pos^frmt^sem^to^pstm^0200                !!00024-08
!                            pstm^frmt^b24^to^pos^0200                !!00024-09
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024-0A
! Reference:  Case #409505.                                           !!00024-0B
                                                                       !00024-0C
                                                                       !00024:00
! 30MAR2006   wielerk                                                 !!00024:01
! Symptom:    None.                                                   !!00024:02
! Problem:    Not all "use" statements have matching "drop"           !!00024:03
!             statements.                                             !!00024:04
! Fix:        Modified module to replace unmatched "use/drop"         !!00024:05
!             statements with locally defined INT variables.          !!00024:06
!             Proc Modified: pos^^input^from^process                  !!00024:07
!                            pos^frmt^sem^to^pstm^0220                !!00024:08
!                            pos^frmt^sem^to^pstm^0420                !!00024:09
!                            pos^init^get^lconf^info                  !!00024:0A
!                            pstm^frmt^b24^to^pos^0220                !!00024:0B
! Dependency: Apply fix to PSBICIS.  Run MAKE.                        !!00024:0C
! Reference:  Case #409838.                                           !!00024:0D
                                                                       !00024:0E
                                                                       !00024;00
! 26APR2006   pansars                                                 !!00024;01
! Symptom:    BICI Interface formats Voice authorization transactions !!00024;02
!             as normal purchase transctions.                         !!00024;03
! Problem:    For CRT auth transactions pstm.term^typ should be set   !!00024;04
!             to "99". There is no specific condition in the code to  !!00024;05
!             set this value.                                         !!00024;06
! Fix:        Added some code to set pstm.term^typ to "99" for CRT    !!00024;07
!             auth transactions.                                      !!00024;08
!             Procs modified: pos^frmt^sem^to^pstm                    !!00024;09
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024;0A
! Reference:  Case #408952.                                           !!00024;0B
                                                                       !00024;0C
                                                                       !00024<00
! 17JUL2006   frederr                                                 !!00024<01
! Symptom:    BICI is rejecting inbound financial traffic due to an   !!00024<02
!             invalid MAC.                                            !!00024<03
! Problem:    The interface is always using the outbound MAC key      !!00024<04
!             when checking the MAC for inbound traffic.              !!00024<05
! Fix:        Modified the code to use the inbound MAC key when       !!00024<06
!             checking the MAC for inbound traffic.                   !!00024<07
!             Procs modified: pos^util^sem^expand.                    !!00024<08
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024<09
! Reference:  Case #415762.                                           !!00024<0A
                                                                       !00024<0B
                                                                       !00024=00
! 18JUL2006   SharanA                                                 !!00024=01
! Symptom:    Interchange response code was not properly carried to   !!00024=02
!             device for POS acquiring transaction.                   !!00024=03
! Problem:    The pstm.tran.ichg^resp was getting populated with      !!00024=04
!             blank if psem.pri^rsrvd2^prvt.pos.ichg^resp are blank   !!00024=05
!             hence for SPDH device the ISO Response Code (data field !!00024=06
!             X) is blank. Also for ichg^resp = "00" there is no      !!00024=07
!             corresponding response code.                            !!00024=08
! Fix:        Added some code to populate pstm.tran.ichg^resp with    !!00024=09
!             psem.resp^cde if psem.pri^rsrvd2^prvt.pos is blank.     !!00024=0A
!             Also move "01" to pstm.tran.ichg^resp if it is "00".    !!00024=0B
!             Procs modified: pos^frmt^sem^to^pstm^0210               !!00024=0C
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024=0D
! Reference:  Case #416503.                                           !!00024=0E
                                                                       !00024=0F
                                                                       !00024>00
! 11OCT2006   frederr                                                 !!00024>01
! Symptom:    Denied external 0220 messages are being forwarded to    !!00024>02
!             BASE24 as approved 0220 messages.                       !!00024>03
! Problem:    The interface is overwriting the response code in the   !!00024>04
!             0220 with zeroes when configuring the ACK back to the   !!00024>05
!             co-network.  This causes the internal 0220 to be sent   !!00024>06
!             with an approved response code.  Denied 0220's should   !!00024>07
!             not be sent to BASE24 at this time.                     !!00024>08
! Fix:        Modified the interface to check if the 0220 is denied   !!00024>09
!             before the ACK is configured and sent to the co-network.!!00024>0A
!             If the 0220 is denied then the interface will set a     !!00024>0B
!             flag that it will check after the ACK is sent.  If this !!00024>0C
!             is true then the 0220 will be dropped after the ACK is  !!00024>0D
!             sent.                                                   !!00024>0E
!             Proc modified: pos^0220^advice.                         !!00024>0F
! Dependency: Apply fix to PSBICIS and run MAKE.                      !!00024>0G
! Reference:  Case #418643.                                           !!00024>0H
                                                                       !00024>0I
                                                                       !00024|00
! 07DEC2006   engelk                                                  !!00024|01
! Symptom:    Userdata was not returned from the ILF expand.          !!00024|02
! Problem:    No attempt was made to restore the userdata.  Userdata, !!00024|03
!             if present, is placed after the last POS service in the !!00024|04
!             PSTM.                                                   !!00024|05
! Fix:        Modified the code to pass the number of services to     !!00024|06
!             hiswilf^expand when expanding the PSTM found on the ILF.!!00024|07
!             The HISWUTLS procedure will use this information to     !!00024|08
!             restore the user data at the end of the services.       !!00024|09
!             Proc modified: pos^util^ilf^expand                      !!00024|0A
! Dependency: Apply fixes to HISWUTLS and PSBICIS.  Run Make.         !!00024|0B
! Reference:  Case #425835.                                           !!00024|0C
                                                                       !00024|0D
                                                                       !00024|0E
                                                                       !00024|0F
                                                                       !00024@00
! 07MAR2007   bracewm                                                 !!00024@01
! Symptom:    Reversals that originate from SPDH are being sent to    !!00024@02
!             the Host with field 90 blank.                           !!00024@03
! Problem:    The ILF contains the original data elements in the 0210 !!00024@04
!             logged in the original response. Field 90 is set up in  !!00024@05
!             SEM before the ILF has been read, so it contains blanks.!!00024@06
! Fix:        Modified the code to retrieve the original data elements!!00024@07
!             from the ILF, and to place them in the SEM, via a new   !!00024@08
!             structure, the ORIG^PSTM.                               !!00024@09
!             Procs modified: pstm^0420^reversal                      !!00024@0A
!                             pstm^frmt^b24^to^pos^0420               !!00024@0B
! Dependency: Apply fixes to PSBICIS and run Make.                    !!00024@0C
! Reference:  Case #427983.                                           !!00024@0D
                                                                       !00024@0E
                                                                       !00024\00
! 24APR2007   SharanA                                                 !!00024\01
! Symptom:    Pre-Auth holds not being added to the CAF/PBF.          !!00024\02
! Problem:    The pstm.pre^auth^hld is not being populated correctly  !!00024\03
!             with the hold time in ICFE when the co-network does not !!00024\04
!             send in values for the pre-auth hold interval / time in !!00024\05
!             field 126 or does not send field 126 at all.            !!00024\06
! Fix:        Modified the code to initialize the binary field        !!00024\07
!             pstm.tran.pre^auth^hld to zeros so that the condition is!!00024\08
!             met and hold time values from ICFE are moved to this    !!00024\09
!             field.                                                  !!00024\0A
!             Proc modified: pos^frmt^sem^to^pstm                     !!00024\0B
! Dependency: Apply fixes to PSBICIS and run Make.                    !!00024\0C
! Reference:  Case #431055.                                           !!00024\0D
                                                                       !00024\0E
                                                                       !00024]00
! 05JUN2007   engelk                                                  !!00024]01
! Symptom:    Interface dumps while processing a PSTM reversal from   !!00024]02
!             RTAU.                                                   !!00024]03
! Problem:    The interface retrieves the original PSTM from the ILF  !!00024]04
!             to fill bit 90, orig data, in the SEM reversal it       !!00024]05
!             formats.  However, no space was defined to contain the  !!00024]06
!             PSTM from the ILF.  Therefore, when the POS portion of  !!00024]07
!             of the ILF was expanded, memory was overwritten.        !!00024]08
! Fix:        Modified the code to provide a structure into which the !!00024]09
!             PSTM from the ILF could be expanded.                    !!00024]0A
!             Procs modified:  pstm^0420^reversal                     !!00024]0B
! Dependency: Apply fix to PSBICIS and run Make.                      !!00024]0C
! Reference:  Case #435153.                                           !!00024]0D
                                                                       !00024]0E
                                                                       !00024^00
! 25JUN2007   bracewm                                                 !!00024^01
! Symptom:    BASE24 goes into an infinite loop under the following   !!00024^02
!             conditions:                                             !!00024^03
!             The SPROUTE is configured for SPDH acquired transactions!!00024^04
!             where no CPF/IDF routing occurs, to send to two BIC     !!00024^05
!             processes configured as primary and alternate           !!00024^06
!             destinations. Both BIC processes are started, but       !!00024^07
!             logged off. A POS transaction comes into BASE24 via     !!00024^08
!             SPDH, and is SPROUTE routed to the primary BIC process. !!00024^09
! Problem:    The primary BIC interface cannot deliver the transaction!!00024^0A
!             to its station, so it sends it to the alternate BIC     !!00024^0B
!             process.  The alternate BIC Interface cannot deliver the!!00024^0C
!             transaction to its station, so it sends it to the       !!00024^0D
!             primary destination, add infinitum.                     !!00024^0E
! Fix:        Modified the code to check that if we are the alternate !!00024^0F
!             BIC destination and we should be authorizing the        !!00024^0G
!             transaction, but cannot, to deny the transaction with a !!00024^0H
!             a response code of POS^RESPONSE^DPC^DOWN^L.             !!00024^0I
!             Procs modified:  pstm^0200^route.                       !!00024^0J
! Dependency: Apply fix to PSBICIS and run Make.                      !!00024^0K
! Reference:  Case #435935.                                           !!00024^0L
                                                                       !00024^0M
                                                                       !00024`00
! 04JUL2007   bracewm                                                 !!00024`01
! Symptom:    None.                                                   !!00024`02
! Problem:    The transaction code translation from external to       !!00024`03
!             internal and vice versa for merchandise return          !!00024`04
!             adjustments and purchase adjustments are incorrect.     !!00024`05
! Fix:        Modified the code to translate an external tran code of !!00024`06
!             22 to an internal tran code of 21 (Credit Adjustment)   !!00024`07
!             and an external tran code of 02 to an internal tran code!!00024`08
!             of 22 (Debit Adjustment) and vice versa.                !!00024`09
!             Procs modified: pos^frmt^sem^to^pstm^tran               !!00024`0A
!                             pstm^frmt^sem^to^pos^tran.              !!00024`0B
! Dependency: Apply fix to PSBICIS and run Make.                      !!00024`0C
! Reference:  Case #436765.                                           !!00024`0D
                                                                       !00024`0E
                                                                       !00024~00
! 30JUL2007   wielerk                                                 !!00024~01
! Symptom:    SAF error 45 (file full) error messages are displayed   !!00024~02
!             on EMS repeatedly.                                      !!00024~03
! Problem:    When a Base24 acquired request is processed, errors on  !!00024~04
!             the SAF can cause that request to be returned to Base24 !!00024~05
!             for stand-in. This can cause a 0220 to be sent back to  !!00024~06
!             this process. If the SAF error is file full, the 0220   !!00024~07
!             cannot be logged to the SAF yet is approved.            !!00024~08
! Fix:        Modified logic to deny PSTM requests if the SAF error is!!00024~09
!             file full (45) and the process is configured for        !!00024~0A
!             acquirer stand-in.                                      !!00024~0B
!             Proc modified: pstm^0200^request                        !!00024~0C
! Dependency: Apply fix to PSBICIS. Run Make.                         !!00024~0D
! Reference:  Case #438223                                            !!00024~0E
                                                                       !00024(00
                                                                       !00024(01
! 10AUG2007   frederr                                                 !!00024(02
! Symptom:    The PSTM's retl-grp field is not populated when a       !!00024(03
!             PSTM reversal is sent due to a rejected or failed       !!00024(04
!             external 0210 approved message.  Some customers use     !!00024(05
!             this field during settlement.                           !!00024(06
! Problem:    The code uses the ILF internal message when formatting  !!00024(07
!             a PSTM reversal due to a rejected or failed extrenal    !!00024(08
!             0210 approved message.  The PSTM retl-grp is not saved  !!00024(09
!             in the ILF.                                             !!00024(0A
! Fix:        Modified the interface to use DE-48 (additional data)   !!00024(0B
!             from the failed 0210 external message to populate the   !!00024(0C
!             PSTM's retl-grp and retl-regn fields when formating     !!00024(0D
!             a rejected/failed response reversal.                    !!00024(0E
!             Proc modified: pos^failed^0x10^sem^resp.                !!00024(0F
! Dependency: Apply fix to PSBICIS. Run Make.                         !!00024(0G
! Reference:  Case #437141.                                           !!00024(0H
                                                                       !00024(0I
                                                                       !00024)00
! 12OCT2007   MurugiS                                                 !!00024)01
! Symptom:    Track 2 Context Data Removal Enhancement.               !!00024)02
! Problem:    None.                                                   !!00024)03
! Fix:        A new LCONF parameter was added to allow the            !!00024)04
!             BIC process to be configured to mask the track data in  !!00024)05
!             the 0210 response.  It must also support track data     !!00024)06
!             that may have been masked when the transaction is       !!00024)07
!             authorized on BASE24.  Added logic to clear/enable P-2  !!00024)08
!             (PAN) and P-35 (Track data) based on EMF settings.  Also!!00024)09
!             added logic to construct the internal Track data using  !!00024)0A
!             P-2 and P-14 (Expiration Date) if P-35 is absent.       !!00024)0B
!             Procs Modified:                                         !!00024)0C
!                 pos^frmt^sem^to^pstm^0210                           !!00024)0D
!                 pos^frmt^sem^to^pstm^acct                           !!00024)0E
!                 pos^init^get^lconf^info                             !!00024)0F
!                 pos^util^send^pstm                                  !!00024)0G
!                 pstm^frmt^b24^to^pos^0210                           !!00024)0H
!                 pstm^frmt^b24^to^pos^acct                           !!00024)0I
!                 pstm^frmt^b24^to^pos^sem                            !!00024)0J
!             Proc Added:                                             !!00024)0K
!                 pos^util^sem^adjust^trk                             !!00024)0L
! Dependency: Apply fix to BABICIS, BABICIG, and PSBICIS.  Run Make.  !!00024)0M
!             Replace BABILOGM.  Refer to BA60UD0B.SCNTRK for a       !!00024)0N
!             complete listing of dependencies.                       !!00024)0O
! Reference:  WO #051128-01                                           !!00024)0P
                                                                       !00024)0Q
                                                                       !00024{00
! 12DEC2007   frederr                                                 !!00024{01
! Symptom:    The PSTM's interchange response code was incorrectly set!!00024{02
!             to a '01' when the external BICI response code was      !!00024{03
!             '00'.  This caused issues with FID X sent back in the   !!00024{04
!             SPDH response message.                                  !!00024{05
! Problem:    PSBICIS was coded to change the PSTM's interchange      !!00024{06
!             response code to a '01' when it was originally set to   !!00024{07
!             a '00'.                                                 !!00024{08
! Fix:        Deleted the code in the interface that changed the      !!00024{09
!             PSTM's interchange response code from a '00' to a '01'. !!00024{0A
!             Procs Modified:  pos^frmt^sem^to^pstm^0210              !!00024{0B
! Dependency: Apply fix to PSBICIS.  Run Make.                        !!00024{0C
! Reference:  Case #446746.                                           !!00024{0D
                                                                       !00024{0E
                                                                       !00024}00
! 17DEC2007   wielerk                                                 !!00024}01
! Symptom:    BIC ISO will invoke ABEND if an error is encountered    !!00024}02
!             processing token data from de-126 ( secndry rsrvd prvt )!!00024}03
! Problem:    When Base24 was designed to utilize tokens the decision !!00024}04
!             was made to create a dump file if certain errors were   !!00024}05
!             detected. Now that token processing has matured, the    !!00024}06
!             decision has been made that incorrectly formatted data  !!00024}07
!             in de-126 should cause the transaction to be denied     !!00024}08
!             instead of invoking ABEND.                              !!00024}09
! Fix:        Modified logic to deny external transactions if an error!!00024}0A
!             is encountered processing de-126 token data.            !!00024}0B
!             Proc modified: pos^frmt^sem^to^pstm^0200                !!00024}0C
!                            pos^frmt^sem^to^pstm^0210                !!00024}0D
!                            pos^frmt^sem^to^pstm^0220                !!00024}0E
!                            pos^frmt^sem^to^pstm^0402                !!00024}0F
!                            pos^frmt^sem^to^pstm^0420                !!00024}0G
!                            pos^frmt^sem^to^pstm^acct                !!00024}0H
! Dependency: Apply fix to PSBICIS. Run Make.                         !!00024}0I
! Reference:  Case #441488                                            !!00024}0J
                                                                       !00024}0K
                                                                       !00024000
! 09JAN2008   frederr                                                 !!00024001
! Symptom:    The interface does not add the Switch Common Data Token !!00024002
!             (Token ID = 'BY').  Some Device Handlers use this token !!00024003
!             to send back data to the Device.                        !!00024004
! Problem:    The interface is not coded to add the Switch Common Data!!00024005
!             Token.                                                  !!00024006
! Fix:        Modified the interface to add and update the Switch     !!00024007
!             Common Data Token.                                      !!00024008
!             Procs Modified:  pos^0200^request                       !!00024009
!                              pos^0210^response                      !!0002400A
!                              pos^0220^advice                        !!0002400B
!                              pos^0402^request                       !!0002400C
! Dependency: Apply fix to BABICIS, BABICIG, PSBICIS and ATBICIS.     !!0002400D
!             Replace BABILOGM.  Run Make.                            !!0002400E
! Reference:  Case #447453.                                           !!0002400F
                                                                       !0002400G
                                                                       !00024100
! 30JAN2008   bracewm                                                 !!00024101
! Symptom:    Not all external response codes and adjustment codes    !!00024102
!             for 0220 adjustments are unique, which can lead to      !!00024103
!             confusion.                                              !!00024104
! Problem:    The BASE24 external message defines the same value "94" !!00024105
!             to indicate a duplicate transmission in an 0220         !!00024106
!             adjustment, both in the adjustment code and in the      !!00024107
!             response code.                                          !!00024108
! Fix:        Modified the interface to map the internal adjustment   !!00024109
!             code "16" (duplicate transmission) to an external       !!0002410A
!             adjustment code of "T9" and vice versa.                 !!0002410B
!             Procs Modified:  pos^frmt^sem^to^pstm^0200              !!0002410C
!                              pos^frmt^sem^to^pstm^0220              !!0002410D
!                              pstm^frmt^b24^to^pos^0200              !!0002410E
!                              pstm^frmt^b24^to^pos^0220              !!0002410F
! Dependency: Apply fix to PSBICIS. Run Make.                         !!0002410G
! Reference:  Case #453851.                                           !!0002410H
                                                                       !0002410I
                                                                       !00024200
! 05FEB2008   frederr                                                 !!00024201
! Symptom:    DE-61's (Card Issuer-Category-Response Code Data)       !!00024202
!             response code field contains zeroes in denied response  !!00024203
!             messages.  Zeroes in this field imply that the          !!00024204
!             interchange approved this denied transaction.           !!00024205
! Problem:    The interface initializes the PSTM's interchange        !!00024206
!             response field with zeroes when formatting internal     !!00024207
!             request messages.  The interface then uses this PSTM    !!00024208
!             field to populate DE-61's response code field when      !!00024209
!             formatting an external response message.  If the        !!0002420A
!             authorizing process does not modify the PSTM field, then!!0002420B
!             zeroes will remain in the PSTM field on the internal    !!0002420C
!             response to BICI and thus will end up in DE-61 in the   !!0002420D
!             external response.                                      !!0002420E
! Fix:        Modified the interface to initialize the PSTM's         !!0002420F
!             interchange response field to blanks on internal request!!0002420G
!             messages.                                               !!0002420H
!             Procs Modified: pos^frmt^sem^to^pstm                    !!0002420I
! Dependency: Apply fix to PSBICIS. Run Make.                         !!0002420J
! Reference:  Case #454777.                                           !!0002420K
                                                                       !0002420L
                                                                       !00024300
! 13MAR2008   engelk                                                  !!00024301
! Symptom:    APCF routing does not work for the BASE24 Interface.    !!00024302
! Problem:    The BIC interface deletes the acquirer routing (BA),    !!00024303
!             transaction description (B9), and transaction profile   !!00024304
!             (B8) tokens from the internal message so that they are  !!00024305
!             not sent on from outside BASE24.  However, they need to !!00024306
!             be retained in internal message as they were.  The      !!00024307
!             acquirer routing (BA) token is needed to route the      !!00024308
!             transaction.  The tokens should be deleted from the     !!00024309
!             external message prior to converting the external token !!0002430A
!             buffer data to its internal format.                     !!0002430B
! Fix:        Modified the code to delete these tokens from the       !!0002430C
!             external message so they do not overlay values to be    !!0002430D
!             retained in the internal message.  That way the         !!0002430E
!             acquirer routing (BA) token remains intact for routing  !!0002430F
!             purposes.                                               !!0002430G
!             Procs modified:  pos^frmt^sem^to^pstm^0210              !!0002430H
!             Procs added:     pos^sem^del^tkns                       !!0002430I
! Dependency: Apply fixes to ATBICIS and PSBICIS.  Run Make.          !!0002430J
! Reference:  Case #456509                                            !!0002430K
                                                                       !0002430L
                                                                       !00024400
! 20JUN2008   wielerk                                                 !!00024401
! Symptom:    Pin translation during MAC generation is rejected by    !!00024402
!             Atalla secure device.                                   !!00024403
! Problem:    The BIC interface does not allow double length pin      !!00024404
!             keys to be sent to SECUTILS. The formatting of the      !!00024405
!             "BD" command used literals that only allowed 16 byte    !!00024406
!             pin keys to be sent to Atalla.                          !!00024407
! Fix:        Modified the call to hiswsec^pin^xlate^mac^generate     !!00024408
!             to pass PCT PIN key length.                             !!00024409
!             Procs modified:  pos^util^xlate^mac^generate            !!0002440A
! Dependency: Apply fixes to PSBICIS, BA60SRC.SECUTILS. Run Make.     !!0002440B
! Reference:  Case #468374.                                           !!0002440C
                                                                       !0002440D
                                                                       !00024500
! 24JUL2008   frederr                                                 !!00024501
! Symptom:    CSM's utilizing the defines pos^adj^pur^d and           !!00024502
!             pos^adj^mdse^ret^d are not getting the desired results. !!00024503
! Problem:    The interface was modified by a previous fix on how     !!00024504
!             ISO tran codes '02' (debit adjustment) and '22'         !!00024505
!             (credit adjustment) were mapped in reguards to BASE24   !!00024506
!             PSTM tran codes "21" (purchase adjustment) and '22'     !!00024507
!             (merchandise return adjustment).  The new mappings      !!00024508
!             mapped the ISO '02' to the PSTM's '22' and the ISO      !!00024509
!             '22' to the PSTM's '21'.  These two defines were not    !!0002450A
!             updated in the process.                                 !!0002450B
! Fix:        Modified the define pos^adj^pur^d to map to a '22' and  !!0002450C
!             pos^adj^mdse^ret^d to an '02' per how the ISO tran code !!0002450D
!             now matches the PSTM tran code.                         !!0002450E
! Dependency: Apply fixes to PSBICIS. Run Make.                       !!0002450F
! Reference:  Case #469421.                                           !!0002450G
                                                                       !0002450H
                                                                       !00024600
! 01DEC2008   frederr                                                 !!00024601
! Symptom:    When BICI is the primary and alternate destination and  !!00024602
!             neither process has a station up and logged on, the     !!00024603
!             transaction is left to time out at the Device Handler.  !!00024604
! Problem:    If this BICI process is the alternate destination and it!!00024605
!             has no stations to forward the transaction to, the      !!00024606
!             interface denies the transaction back to the primary    !!00024607
!             destination.  The primary destination will simply drop  !!00024608
!             the denial as it routed the transaction to the alternate!!00024609
!             destination and is not expecting a response for that    !!0002460A
!             transaction.                                            !!0002460B
! Fix:        Modified the interface to send an 0200 back to the      !!0002460C
!             primary authorizing process if this interface is the    !!0002460D
!             alternate destination and has no stations to send a     !!0002460E
!             transaction to.  The auth indicator is set to a '9' to  !!0002460F
!             tell Auth to handle the 0200 as no issuers are up at    !!0002460G
!             that time.                                              !!0002460H
!             Procs modified:  pstm^0200^route.                       !!0002460I
! Dependency: Apply fixes to PSBICIS. Run Make.                       !!0002460J
! Reference:  Case #472493.                                           !!0002460K
                                                                       !0002460L
                                                                       !00024700
! 08DEC2008   engelk                                                  !!00024701
! Symptom:    POS reversals have DE-90 (original message information) !!00024702
!             with a SEM response original message type, instead of a !!00024703
!             SEM request message type.                               !!00024704
! Problem:    When an ILF record was found for a PSTM reversal, it    !!00024705
!             pulled the entire message type from the ILF record      !!00024706
!             instead of pulling the just the first 2 characters.     !!00024707
!             This field cannot be hardcoded as POS requests can be   !!00024708
!             0100 or 0200 messages.                                  !!00024709
! Fix:        Modified the code to pull only the first 2 characters of!!0002470A
!             the message type from the ILF record.  The PSTM is      !!0002470B
!             inialized to ASCII zeroes, so this will result in a     !!0002470C
!             correct and complete original message type which is then!!0002470D
!             loaded into SEM DE-90.                                  !!0002470E
!             Procs modified:  util^ilf^expand                        !!0002470F
! Dependency: Apply fix to PSBICIS and run Make.                      !!0002470G
! Reference:  Case #482595                                            !!0002470H
                                                                       !0002470I
                                                                       !00024800
! 05JAN2009   GangarJ                                                 !!00024801
! Symptom:    Interface is giving a file system error while           !!00024802
!             attempting to update the ILF.                           !!00024803
! Problem:    While formatting a 0412 response message, the interface !!00024804
!             updates the ILF. If the record does not exist in ILF,   !!00024805
!             then it inserts a new record. There exists a logic      !!00024806
!             to update the ILF record immediately after adding a     !!00024807
!             new record, which results in error.                     !!00024808
! Fix:        Modified the interface to include a return statement    !!00024809
!             after adding a new record, when not found in ILF.       !!0002480A
!             Proc modified: pstm^0412^response                       !!0002480B
! Dependency: Apply fix to PSBICIS. Run Make.                         !!0002480C
! Reference:  Case #485436                                            !!0002480D
                                                                       !0002480E
                                                                       !00024900
! 06JAN2009   wielerk                                                 !!00024901
! Symptom:    The interface cannot execute a "BD" command to Atalla   !!00024902
!             when the MAC key is double length.                      !!00024903
! Problem:    The "BD" command is used for the combined PIN/MAC       !!00024904
!             translate function. When the MAC key is greater than    !!00024905
!             single length, Atalla requires a MAC type to indicate   !!00024906
!             Standard Cypher Block Chaining ( Base24 default ) or    !!00024907
!             Pseudo Cypher Block Chaining.                           !!00024908
! Fix:        Modified the module to pass the global,                 !!00024909
!             PSEUDO-CBC-MAC-TYP^G, when combined MAC/PIN function    !!0002490A
!             is required.                                            !!0002490B
!             Proc modified: pos^util^xlate^mac^generate              !!0002490C
! Dependency: Apply fixes to BABICIG, BABICIS, ATBICIS, PSBICIS,      !!0002490D
!             HISWUTLS, and SECUTILS                                  !!0002490E
!             Run Make.                                               !!0002490F
! Reference:  Case #473928.                                           !!0002490G
                                                                       !0002490H
                                                                       !A0002400
! 02MAR2009   GangarJ                                                 !!A0002401
! Symptom:    The interface is not reversing the cash back amount in  !!A0002402
!             the PSTM reversal message for purchase with cash back   !!A0002403
!             transactions.                                           !!A0002404
! Problem:    The interface is reversing only the purchase amount     !!A0002405
!             instead of the total amount for cash back reversal      !!A0002406
!             transactions. This happens due to the inclusion of DE-95!!A0002407
!             (Replacement amount) in the PSTM reversal message when  !!A0002408
!             pstm.tran.amt^2 (Cash Back Amount) is present.          !!A0002409
! Fix:        Modified the interface to include DE-95 (Replacement    !!A000240A
!             amount) only for PSTM adjustment reversal transactions  !!A000240B
!             and not to include DE-95 for a PSTM cash back, preauth  !!A000240C
!             cash back or preauth completion with cash back when     !!A000240D
!             pstm.tran.amt^2 (Cash Back Amount) is present.          !!A000240E
!             Proc modified: pstm^frmt^b24^to^pos^amt                 !!A000240F
! Dependency: Apply fix to PSBICIS. Run Make.                         !!A000240G
! Reference:  Case #484839.                                           !!A000240H
                                                                       !A000240I
                                                                       !B0002400
! 20MAY2009   bensone                                                 !!B0002401
! Symptom:    Process code mapping from internal to external is not   !!B0002402
!             correct.  The interface is rejecting the transaction.   !!B0002403
! Problem:    Base24 can not be configured to send an account type    !!B0002404
!             of zeros out through a BICI interface.                  !!B0002405
! Fix:        Add LCONF parameter (POS-B24-TO-POS-ACCT-TYP-SUPPRS)    !!B0002406
!             to allow customer to suppress the internal to external  !!B0002407
!             mapping of account type in the processing code.         !!B0002408
!             Procs modified: pos^init^get^lconf^info                 !!B0002409
!                             pstm^frmt^b24^to^pos^tran               !!B000240A
! Dependency: Apply fixes to BABICIG, BABICIS and PSBICIS.  Run Make. !!B000240B
! Reference:  Case #490796.                                           !!B000240C
                                                                       !B000240D
                                                                       !C0002400
! 26MAY2009   wielerk                                                 !!C0002401
! Symptom:    Advice adjustments with non-zero value in de-39 ( resp  !!C0002402
!             code ) are not passed to Base24.                        !!C0002403
! Problem:    Adjustment transactions use de-39 to initialize         !!C0002404
!             PSTM.RVSL^CDE, not to indicate a denied advice.         !!C0002405
! Fix:        Modified logic to allow an adjustment to contain a      !!C0002406
!             non-zero value in de-39.                                !!C0002407
!             Procs modified: pos^0220^advice                         !!C0002408
! Dependency: Apply fix to PSBICIS.  Run Make.                        !!C0002409
! Reference:  Case #495689.                                           !!C000240A
                                                                       !C000240B
                                                                       !D0002400
! 27JUL2009   engelk                                                  !!D0002401
! Symptom:    Because an encrypted PIN has a remote chance of         !!D0002402
!             resulting in a PIN block of all Fs, an encrypted PIN    !!D0002403
!             may be treated as a pre-verified PIN.                   !!D0002404
! Problem:    Since it is possible for an encrypted PIN to result in  !!D0002405
!             a value of all Fs, this value should not be used to     !!D0002406
!             identify a pre-verified PIN.  The same is true for any  !!D0002407
!             hexadecimal repeated character.                         !!D0002408
! Fix:        Added an LCONF param, PRE-VERIFIED-PIN-PAD-CHAR, so     !!D0002409
!             the value to be repeated in the PIN block field to      !!D000240A
!             identify a pre-verified PIN is configurable.  The       !!D000240B
!             default will remain "F", but it is suggested that this  !!D000240C
!             LCONF param be set to a value which is not a valid      !!D000240D
!             hexadecimal character (other than 0-9 and A-F).  The    !!D000240E
!             BAS24 interface to which this BASE24 interface connects !!D000240F
!             must also be modified to identify the new pre-verified  !!D000240G
!             PIN block.                                              !!D000240H
!             Procs modified:  pos^frmt^sem^to^pstm^0200              !!D000240I
!                              pstm^frmt^b24^to^pos^0200              !!D000240J
! Dependency: Apply fixes to BABICIG, BABICIS, and PSBICIS.  Run      !!D000240K
!             Make.                                                   !!D000240L
! Reference:  Case #503398                                            !!D000240M
                                                                       !D000240N
                                                                       !E0002400
! 30SEP2009   wielerk                                                 !!E0002401
! Symptom:    A missing, non-required LCONF param prevents a BIC ISO  !!E0002402
!             process from initializing on Itanium hardware.          !!E0002403
! Problem:    The define, item^req^, which is used to indicate a      !!E0002404
!             flag to determine if a param is required had an         !!E0002405
!             incorrect offset. This caused the define to point to    !!E0002406
!             the correct location only for the first param. The      !!E0002407
!             newest param is not required, but on an Itanium         !!E0002408
!             machine the define appeared to be true causing the      !!E0002409
!             process to require the param to initialize.             !!E000240A
! Fix:        Modified the define item^req^ to correct the offset     !!E000240B
!             value.                                                  !!E000240C
!             Procs modified:  pos^init^get^lconf^info                !!E000240D
! Dependency: Apply fixes to PSBICIS and SW60ATBI.ATBICIS.  Run Make. !!E000240E
! Reference:  Case #508036.                                           !!E000240F
                                                                       !E000240G
                                                                       !F0002400
! 06NOV2009   engelk                                                  !!F0002401
! Symptom:    None.                                                   !!F0002402
! Problem:    Code put in place to identify SEM pre-verified PINs     !!F0002403
!             incorrectly assigned "Z" to pin^tries.                  !!F0002404
! Fix:        Modified code to move a "Z" to pin^tries when the       !!F0002405
!             co-network verified the PIN.                            !!F0002406
!             Proc modified: pos^frmt^sem^to^pstm^0200                !!F0002407
! Dependency: Apply fixes to ATBICIS and PSBICIS.  Run Make.          !!F0002408
! Reference:  Case #508338                                            !!F0002409
                                                                       !F000240A
                                                                       !G0002400
! 24FEB2010   wielerk                                                 !!G0002401
! Symptom:    DE-42( card accept id code ) is present is SEM 0420,    !!G0002402
!             but PSTM.CRD^ACCPT^ID^NUM contains zeroes.              !!G0002403
! Problem:    The PSTM field is not stored on the ILF and when the    !!G0002404
!             PSTM is restored from the ILF, the field is set to      !!G0002405
!             zeroes.                                                 !!G0002406
! Fix:        Modified code to set PSTM.CRD^ACCPT^ID^NUM from de-42   !!G0002407
!             after the ILF has been restored.                        !!G0002408
!             Proc modified: pos^frmt^sem^to^pstm^0420                !!G0002409
! Dependency: Apply fix to PSBICIS.  Run Make.                        !!G000240A
! Reference:  Case #1022281.                                          !!G000240B
                                                                       !G000240C
                                                                       !H0002400
! 06APR2010   wielerk                                                 !!H0002401
! Symptom:    When the process is configured to mask track data,      !!H0002402
!             external reversals are not matched.                     !!H0002403
! Problem:    Base24 documentation indicates that as part of track    !!H0002404
!             masking, external reversals need not provide de-35      !!H0002405
!             ( Track2 ). The module does not build the ILF prikey    !!H0002406
!             using de-2 ( PAN ) as required.                         !!H0002407
! Fix:        Modified code to check for the presence of de-35 before !!H0002408
!             using it to build the ILF prikey. Added logic to check  !!H0002409
!             for the presence of de-2 when building the ILF prikey.  !!H000240A
!             Proc modified: pos^frmt^sem^to^prikey                   !!H000240B
! Dependency: Apply fixes to ATBICIS, PSBICIS.  Run Make.             !!H000240C
! Reference:  Case #1067948.                                          !!H000240D
                                                                       !H000240E
                                                                       !I0002400
! 08JUL2010   saderc                                                  !!I0002401
! Symptom:    A PTLF record is not being logged in rare cases for     !!I0002402
!             transactions.                                           !!I0002403
! Problem:    Routers logic checks for a msg^pro^1 value of 1978      !!I0002404
!             to determine whether to proceed to a device handler.    !!I0002405
!             However, it is possible that a 'real' process would be  !!I0002406
!             assigned a process number of 1978.  If a DH is not used,!!I0002407
!             the transaction will be dropped. This issue was         !!I0002408
!             initially addressed back in 2009 for case #495169 when  !!I0002409
!             the generic simulator process number was changed to     !!I000240A
!             18259. There were several processes updated per this    !!I000240B
!             case. Unfortunately, the BIC process was not updated at !!I000240C
!             that time.                                              !!I000240D
! Fix:        Modify the value used to identify the generic simulator !!I000240E
!             process to 18259.                                       !!I000240F
!             Procs modified: pos^^input^from^process                 !!I000240G
!                             pos^^input^from^station                 !!I000240H
!                             pos^util^send^pstm                      !!I000240I
! Dependency: Apply fix to PSBICIS. Run Make.                         !!I000240J
! Reference:  Case #1083234                                           !!I000240K
                                                                       !I000240L
                                                                       !J0002400
! 22JUL2010   saderc                                                  !!J0002401
! Symptom:    ISO response code "13" (invalid amount) mapped to Base24!!J0002402
!             response code "069" (bad message edit) incorrectly.     !!J0002403
! Problem:    The interface is mapping ISO response code "13" to      !!J0002404
!             Base24 response code "069". It should be mapped to      !!J0002405
!             Base24 response code "205" (invalid advance amount).    !!J0002406
! Fix:        Modify the interface to map ISO response code "13" to   !!J0002407
!             Base24 response code "205". Also, added, modified and   !!J0002408
!             deleted some additional response codes as required.     !!J0002409
!             Below are the other modifications made to the ISO to    !!J000240A
!             Base24 mapping:                                         !!J000240B
!             1. Added a mapping for ISO response code "10" to Base24 !!J000240C
!                response code "000" (partial approval).              !!J000240D
!             2. Changed the mapping for ISO response code "T7" from  !!J000240E
!                Base24 response code "071" to "251" (purchase with   !!J000240F
!                cash back).                                          !!J000240G
!             Below are the modifications made to the Base24 to ISO   !!J000240H
!             mapping:                                                !!J000240I
!             1. Deleted the mapping for Base24 response code "071"   !!J000240J
!                (invalid routing to authorization).                  !!J000240K
!             2. Changed the mapping for Base24 response code "090"   !!J000240L
!                from ISO response code "O1" to "O0" (referral file   !!J000240M
!                full).                                               !!J000240N
!             Procs modified: pos^frmt^sem^to^pstm^0210               !!J000240O
!                             pstm^frmt^b24^to^pos^0210               !!J000240P
! Dependency: Apply fix to PSBICIS. Run Make.                         !!J000240Q
! Reference:  Case #1083635                                           !!J000240R
                                                                       !J000240S
                                                                       !K0002400
! 01APR2011   wielerk                                                 !!K0002401
! Symptom:    POS transactions without PINs generate EMS message      !!K0002402
!             #9122 from Secutils indicating invalid params when      !!K0002403
!             performing combined MAC and PIN translation.            !!K0002404
! Problem:    The global flag that controls the combined MAC and PIN  !!K0002405
!             translation is not turned off if a transaction is       !!K0002406
!             denied before being collapsed. This allows subsequent   !!K0002407
!             transactions without PINs to be passed to Secutils for  !!K0002408
!             MAC/PIN translation.                                    !!K0002409
! Fix:        Modified code to set the param comb^pin^mac^xlate^g to  !!K000240A
!             false to prevent unintended usage.                      !!K000240B
!             Procs modified: pos^util^sem^collapse                   !!K000240C
!                             pstm^frmt^b24^to^pos^0200               !!K000240D
! Dependency: Apply fixes to ATBICIS, PSBICIS.  Run Make.             !!K000240E
! Reference:  Case #1121906.                                          !!K000240F
                                                                       !K000240G
                                                                       !L0002400
! 05APR2011   wielerk                                                 !!L0002401
! Symptom:    Interface not forwarding de-95 ( repl amount ) when     !!L0002402
!             transaction is an adjustment and de-95 is zeroes.       !!L0002403
! Problem:    The interface is toggling de-95 off when it is zero     !!L0002404
!             filled according to standard BIC ISO processing.        !!L0002405
!             This is not correct for adjustment transactions that    !!L0002406
!             attempt a full adjustment of transaction amount.        !!L0002407
! Fix:        Modify the interface to pass PSTM when available and    !!L0002408
!             to utilize $param checks so the PSTM is only used when  !!L0002409
!             it is passed. Also added logic to toggle de-95 on by    !!L000240A
!             interrogating SEM fields when PSTM is not available.    !!L000240B
!             Procs modified: pos^util^sem^collapse                   !!L000240C
!                             pstm^0220^advice                        !!L000240D
!                             pstm^0402^request                       !!L000240E
!                             pstm^0420^reversal                      !!L000240F
! Dependency: Apply fix to PSBICIS. Run Make.                         !!L000240G
! Reference:  Case #1122373.                                          !!L000240H
                                                                       !L000240I
                                                                       !M0002400
! 09AUG2011   PalummR                                                 !!M0002401
! Symptom:    Reversals from Commerce Gateway do not match ILF        !!M0002402
!             originals and are not processed by Base24.              !!M0002403
! Problem:    Commerce Gateway was expecting to provide matching      !!M0002404
!             information in original data fields and was             !!M0002405
!             modifying transaction time for reversals.  ISO BIC      !!M0002406
!             interface does not use original data to match BIC       !!M0002407
!             acquired reversals so these reversals did not pass      !!M0002408
!             the interface.                                          !!M0002409
! Fix:        Modified logic to attempt to use original data time     !!M000240A
!             if the first read of the ILF fails.                     !!M000240B
!             Proc modified pos^0420^reversal                         !!M000240C
! Dependency: Apply fix to PSBICIS and run Make.                      !!M000240D
! Reference:  Case #1154720                                           !!M000240E
                                                                       !M000240F
                                                                       !N0002400
! 07NOV2011   saderc                                                  !!N0002401
! Symptom:    The interface is moving the settlement currency in P-5  !!N0002402
!             to the PSTM when Multiple Currency processing is        !!N0002403
!             configured.                                             !!N0002404
! Problem:    At present, the interface just checks for the settlement!!N0002405
!             currency being present as the condition for using the   !!N0002406
!             settlement currency. Because the settlement amount can  !!N0002407
!             be converted to/from only one other currency using the  !!N0002408
!             buy/sell rates on the ICF(E), it's not possible to      !!N0002409
!             convert amounts to/from the settlement currency, if more!!N000240A
!             than one transaction currency (other than the settlement!!N000240B
!             currency itself) is supported in the message. So, the   !!N000240C
!             settlement amounts should not be processed if the system!!N000240D
!             supports Multiple Currency.                             !!N000240E
! Fix:        The interface was modified to check the new define      !!N000240F
!             use^setl^crncy^amts^d when determining which currency   !!N000240G
!             should be used during issuer processing. Also, there was!!N000240H
!             code added to support a negative amount if the value in !!N000240I
!             P-4 (tran amount) is negative. The utility              !!N000240J
!             all^ascii^fixed^ is now being used to convert P-4 (tran !!N000240K
!             amount) and P-5 (settlement amount) since it handles    !!N000240L
!             negative amounts.                                       !!N000240M
!             Procs modified: pos^frmt^sem^to^pstm^amt                !!N000240N
!                             pstm^frmt^b24^to^pos^amt                !!N000240O
! Dependency: Apply fixes to BABICIG, ATBICIS and PSBICIS. Run Make.  !!N000240P
! Reference:  Case #1168450                                           !!N000240Q
                                                                       !N000240R
                                                                       !O0002400
! 07MAR2012   wielerk                                                 !!O0002401
! Symptom:    The interface is not recognizing the response code value!!O0002402
!             "10" when processing lesser amount approvals mandated by!!O0002403
!             international interchanges.                             !!O0002404
! Problem:    The interface is not passing indication of lesser or    !!O0002405
!             greater amount approval for issuer or acquirer and only !!O0002406
!             formatted lesser amounts when Base24 is the acquirer.   !!O0002407
! Fix:        The interface was modified to pass the POS Data1 token  !!O0002408
!             when Base24 is the acquirer and to interrogate the token!!O0002409
!             if passed when Base24 is the issuer.                    !!O000240A
!             Logic was also modified to pass lesser or greater       !!O000240B
!             amounts in 0210 messages if configured.                 !!O000240C
!             Procs modified: pos^0210^response                       !!O000240D
!                             pos^frmt^sem^to^pstm^0200               !!O000240E
!                             pos^frmt^sem^to^pstm^0210               !!O000240F
!                             pos^frmt^sem^to^pstm^amt                !!O000240G
!                             pstm^frmt^b24^to^pos^0200               !!O000240H
!                             pstm^frmt^b24^to^pos^0210               !!O000240I
! Dependency: Apply fix to PSBICIS. Run Make.                         !!O000240J
! Reference:  Case #1191554 ( for  #1168674 )                         !!O000240K
                                                                       !O000240L
                                                                       !P0002400
! 14MAR2012   wielerk                                                 !!P0002401
! Symptom:    DE-18( merchant type ) is present is SEM 0420, but      !!P0002402
!             PSTM.RETL^SIC^CDE contains zeroes.                      !!P0002403
! Problem:    The PSTM field is not stored on the ILF and when the    !!P0002404
!             PSTM is restored from the ILF, the field is set to      !!P0002405
!             zeroes.                                                 !!P0002406
! Fix:        Modified code to set PSTM.RETL^SIC^CDE from de-18 after !!P0002407
!             the ILF has been restored.                              !!P0002408
!             Proc modified: pos^frmt^sem^to^pstm^0420                !!P0002409
! Dependency: Apply fix to PSBICIS.  Run Make.                        !!P000240A
! Reference:  Case #1192258.                                          !!P000240B
                                                                       !P000240C
!********************************************************************! !00024~0F
?PAGE "RPQ CHANGES"
!*********************************************************************
!-                                                                   *
!- RPQ History:                                                      *
!-                                                                   *
!-   RPQ        Description                                          *
! ------------  -----------------------------------------------------*
!* RPQ #220:    Special Response Code for Timeout and Line Down      *
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        99/03/23                                             *
!* Description: Credibanco wants to have a more clear way to         *
!*              identify the response code.                          *
!*              So  if the denied is for a timeout   we move 086     *
!*              and if the denied is for a line down we move 963-new *
!*                                                                   *
!*                PROCS MODIFIED: PSTM^0200^ROUTE                    *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #240     Special Response Code for Invalid Mac                *
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        30/MAR/99                                            *
!* Description: This process will be modified to basically change the*
!*              original response code "074" for a "964".            *
!*              That will finally be converted to a ISO 93 resp cde  *
!*              This because Credibanco needed the response codes    *
!*              this way.                                            *
!*                                                                   *
!* Modified Procs:    POS^FAILED^0X00^SEM^RQST                       *
!*                    POS^FRMT^SEM^TO^PSTM^0210                      *
!*                    PSTM^FRMT^B24^TO^POS^0210                      *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #270     Determine Card Type for Interchange Card Transactions*
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        06/MAY/99                                            *
!* Description: When a transaction is routed to BIC the card type is *
!*              not set when the card was not found in the CPF file  *
!*              so Credibanco decided to determine the Card Type     *
!*              base on the service code and only for the transaction*
!*              routed to the BIC Interchange.                       *
!*                                                                   *
!* Modified Procs:    POS^^INPUT^FROM^PROCESS                        *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #290     New fields included in the ILF for BIC               *
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        18/JUL/99                                            *
!* Description: Credibanco for Compensation Pourposes required a     *
!*              two new fields saved into the ILF use by BIC         *
!*                   - retl-sic-cde     x(4)                         *
!*                   - crd-accpt-id-num x(11)                        *
!*                                                                   *
!* Modified Procs:    POS^UTIL^ILF^COMPRESS                          *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #500     Send Additional Amount in Request Transactions       *
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        07/SEP/99                                            *
!* Description: This process will be modified to send the additional *
!*              amount field on request transactions.                *
!*              Redeban requires to get this field for all the       *
!*              request transactions. This field contains the tip of *
!*              the transaction.                                     *
!*                                                                   *
!* Modified Procs:    PSTM^FRMT^B24^TO^POS^AMT                       *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*   RPQ #25 : Bill Payment                                          *
!*   Author  : MCD / 2269 / VER 5.1.21                               *
!*   Date    : 11/29/1999                                            *
!*   Description: This RPQ offers Bill payment services through POS  *
!*                terminals, CRT Authorization networks and ATM/POS  *
!*                Issuer environments.  This RPQ allows clients to   *
!*                pay 10 different vendor types (water, electricity, *
!*                cellular, cable, insurance, etc.), in 6 Columbian  *
!*                cities.                                            *
!*                                                                   *
!*   Procs Modified:  POS^^INITIALIZATION                            *
!*                    POS^FRMT^SEM^TO^PSTM^0200                      *
!*                    POS^FRMT^SEM^TO^PSTM^0420                      *
!*                    PSTM^FRMT^B24^TO^STM^0210                      *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*   RPQ #25A: Bill Payment                                          *
!*   Author  : < CREDIBANCO >                                        *
!*   Date    : 23/MAR/00                                             *
!*   Description: Some more new response codes were added.           *
!*                                                                   *
!*   Procs Modified:  PSTM^FRMT^B24^TO^POS^0210                      *
!*                    POS^FRMT^SEM^TO^PSTM^0200                      *
!*                    POS^FRMT^SEM^TO^PSTM^0420                      *
!*                                                                   *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #26B     Send Additional Amount in Request Transactions       *
!* Author:      Mauricio Plascencia - MPI (Astech)                   *
!* Date:        07/SEP/99                                            *
!* Description: This process will be modified to send the additional *
!*              amount field on request transactions.                *
!*              Redeban requires to get this field for all the       *
!*              request transactions. This field contains the tip of *
!*              the transaction.                                     *
!*                                                                   *
!* Modified Procs:    PSTM^FRMT^B24^TO^POS^AMT                       *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!*              RPQ's to PSHISOQS ver 5.1                            *
!* RPQ #27:     Handle Transactions with IVA                         *
!* Author:      < CREDIBANCO M >                                     *
!* Date:        30/JAN/01                                            *
!* Summary:     Modification to handle the IVA amount                *
!*              The IVA amount is received in the P-48 de Hypercom   *
!*              and moved to the USER-DATA area to be written        *
!*              in the PTLF and                                      *
!*              send in the field   P-47 of ISO to the AUTH host     *
!*              that requires it.                                    *
!*                                                                   *
!*  Procs Modified:   PSTM^FRMT^B24^TO^POS^SEM                       *
!*                    POS^FRMT^SEM^TO^PSTM                           *
!*                                                                   *
!*  Procs Added:                                                     *
!*                                                                   *
!*********************************************************************
! ------------  ---------------------------------------------------  *
!*                                                                   *
!*              RPQ's to PSHISOQS ver 6.0                            *
!* RPQ #A1010   Inoperabilidad                                       *
!* Author:      KS de Colombia                                       *
!* Date:        30/JAN/01                                            *
!* Summary:     Ajuste intercambio transacciones Interchange         *
!*                                                                   *
!*  Procs Modified:   PSTM^FRMT^B24^TO^POS^ACCT                      *
!*                                                                   *
!*  Procs Added:                                                     *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!*              RPQ's to PSHISOQS ver 6.0                            *
!* RPQ #A2020   Ajuste Token C0 transacciones no presenciales        *
!* Author:      KS de Colombia                                       *
!* Date:        20/JUN/13                                            *
!* Summary:     Cambiar campo de CVC en transacciones no presenciales*
!*              cuando el CVC viene en blancos, cambiar por XXX      *
!*                                                                   *
!*  Procs Modified:   PSTM^FRMT^B24^TO^POS^ACCT                      *
!*                                                                   *
!*  Procs Added:                                                     *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!*              RPQ's to PSHISOQS ver 5.1                            *
!* RPQ #C0001   Incluir manejo de codigo de respuesta 255            *
!* Author:      KS de Colombia                                       *
!* Date:        09/AGO/2013                                          *
!* Summary:     Codigo de respuesta para CVV2 invalido se incluye    *
!*              en tabla de codigos de respuesta para mensajes 0210  *
!*              de respuesta.                                        *
!*                                                                   *
!*  Procs Modified:   PSTM^FRMT^B24^TO^POS^0210                      *
!*                                                                   *
!*  Procs Added:                                                     *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #BE001   Bolsillo Electronico                                 *
!* Author:      KS de Colombia ( MPI )                               *
!* Date:        05/SEP/2015                                          *
!* Summary:     Ajuste a campo P-22 de salida y token "C0", para     *
!*              bolsillo Electronico. P-22 = 017 y P-25 = 00         *
!*                                                                   *
!*  Procs Modified:   pstm^frmt^b24^to^pos^acct                      *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #BE002   Bolsillo Electronico                                 *
!* Author:      KS de Colombia ( MPI )                               *
!* Date:        10/MAR/2016                                          *
!* Summary:     Se elimina el ajuste echo por este RPQ               *
!*                                                                   *
!*  Procs Modified:   pstm^frmt^b24^to^pos^acct                      *
!*                                                                   *
! ------------  ---------------------------------------------------  *
!*                                                                   *
!* RPQ #COF     Proyecto COF                                         *
!* Author:      KS de Colombia ( MPI )                               *
!* Date:        01/SEP/2020                                          *
!* Summary:     Se incluye "10" en control de p-22                   *
!*              de entrada para modo Manual                          *
!*                                                                   *
!*  Procs Modified:   pos^0420^reversal                              *
!*                    pos^frmt^sem^to^pstm^acct                      *
!*                                                                   *
!*********************************************************************
                                                                       !00024~0G
?nocode                                                                !00024M8C
name psbici;                                                           !00024M8D
                                                                       !00024M8E
!*===================================================================*!
!* BEGIN RPQ #27 - Handle Transactions with IVA                      *!
!---------------------------------------------------------------------!
?nolist, source =pssrc_psddltal( user^data^d )
?nolist, source =pshpdh_hpddltal( privfield )
!---------------------------------------------------------------------!
!* END   RPQ #27 - Handle Transactions with IVA                      *!
!*===================================================================*!

?PAGE "                  - Global Variables"                           !00024M8F
?nolist, source =BASRC_PSTKNID( pstkn^globals )                        !00024M8G
?list                                                                  !00024M8H
!  basrc_pstknid!                                                      !00024M8I
                                                                       !00024W12
?nolist, source =bacse_pstkcid( pscstkn^globals )                      !00024W13
?list                                                                  !00024W14
?nolist, source =swbabi_babicig                                        !00024M8J
?list                                                                  !00024M8K
!  swbabi_babicig!                                                     !00024M8L
                                                                       !00024M8M
!*=================================================================*!
!  BEGIN RPQ #25 - Bill Payment                       MCD / 2269    !
!-------------------------------------------------------------------!
? nolist, source =basrc_rpqtknid(
? rpqtkn^globals
? )
! rpqtkn^globals
! )
!-------------------------------------------------------------------!
!  END  RPQ #25 - Bill Payment                        MCD / 2269    !
!*=================================================================*!
?section pos^globals                                                   !00024M8N
?PAGE "                  - pos^globals"                                !00024M8O
block pos^globals;                                                     !00024M8P
                                                                       !00024M8Q
?PAGE "                  - Global Structs"                             !00024M8R
                                                                       !00024e0O
                                                                       !00024n0D
                                                                       !O000240M
?nolist, source =basrc_baddltal(                                       !O000240N
?  addr^ver^tkn,                                                       !O000240O
?  emf,                                                                !O000240P
?  evt^msg^severity^constants,                                         !O000240Q
?  file_format_constants,                                              !O000240R
?  ilf,                                                                !O000240S
?  lconf,                                                              !O000240T
?  lconf^key,                                                          !O000240U
?  pos^data1^tkn,                                                      !O000240V
?  pos^data1^tknx,                                                     !O000240W
?  ps50^tkn,                                                           !O000240X
?  RPQ^BILL^PYMT^TKN,                                     ! RPQ
?  rpq^p42^tkn,                                           ! RPQ #ID001
?  pstm,                                                               !O000240Y
?  ps51^tkn,                                              ! RPQ #A1010
?  si^pcs^rqst,                                                        !O000240Z
?  si^pcs^resp,                                                        !O000240a
?  tkn,                                                                !O000240b
?  track1^tkn,                                                         !O000240c
?  user^data )                                                         !O000240d
                                                                       !O000240e
                                                                       !O000240f
                                                                       !O000240g
                                                                       !00024n0T
                                                                       !00024n0U
                                                                       !00024n0V
                                                                       !00024e0e
                                                                       !00024e0f
?list                                                                  !00024M94
!  addr^ver^tkn,!                                                      !00024M95
!  emf,!                                                               !00024M96
                                                                       !00024e0g
!  evt^msg^severity^constants,                                        !!00024e0h
!  file_format_constants,                                             !!00024e0i
                                                                       !00024e0j
!  ilf,!                                                               !00024M97
!  lconf,!                                                             !00024M98
!  lconf^key,!                                                         !00024M99
                                                                       !O000240h
!  pos^data1^tkn,                                                     !!O000240i
!  pos^data1^tknx,                                                    !!O000240j
                                                                       !O000240k
!  ps50^tkn,!                                                          !00024M9A
!  pstm,!                                                              !00024M9B
!  si^pcs^rqst,!                                                       !00024M9C

!*===================================================================*!
!   BEGIN RPQ #25 - Bill Payment                      MCD / 2269      !
!---------------------------------------------------------------------!
!  rpq^bill^pymt^tkn,!
!---------------------------------------------------------------------!
!   END   RPQ #25 - Bill Payment                      MCD / 2269      !
!*===================================================================*!
!  rpq^p42^tkn,                                          !! RPQ #ID001
!*===================================================================*!
!   BEGIN RPQ #A1010 - Inoperabilidad                 KS  2013-10-17  !
!---------------------------------------------------------------------!
!  ps51^tkn,!
!---------------------------------------------------------------------!
!   END   RPQ #A1010 - Inoperabilidad                 KS  2013-10-17  !
!*===================================================================*!

!  si^pcs^resp,!                                                       !00024M9D
!  tkn,!                                                               !00024M9E
                                                                       !00024S0V
!  track1^tkn ,!                                                       !00024S0W
                                                                       !00024n0W
!  user^data!                                                          !00024n0X
                                                                       !00024n0Y
                                                                       !00024M9G
                                                                       !00024M9H
                                                                       !00024M9I
                                                                       !00024M9J
                                                                       !00024M9K
define                                                                 !00070
   all^ascii^double^ ( s, n ) = all^ascii^double ( s, $len( s ), n )#, !00071
   all^ascii^fixed^  ( s, n ) = all^ascii^fixed  ( s, $len( s ), n )#, !00072
   all^ascii^integer^( s, n ) = all^ascii^integer( n, s, $len( s ) )#; !00073
                                                                       !00074
?page "PSTM defines and literals"                                      !00075
                                                                       !00076
                                       ! Base24 messages              !!00077
                                                                       !00078
define  pstm^request^d                 = "0200"#,                      !00079
        pstm^response^d                = "0210"#,                      !00080
        pstm^force^post^d              = "0220"#,                      !00081
        pstm^tran^advice^d             = "0220"#,                      !00082
        pstm^tran^advice^dup^d         = "0221"#,                      !00083
        pstm^ack^advice^d              = "0230"#,                      !00084
        pstm^rvsl^request^d            = "0402"#,                      !00085
        pstm^rvsl^response^d           = "0412"#,                      !00086
        pstm^rvsl^advice^d             = "0420"#;                      !00087
                                                                       !00088
define  pstm^stat^no^err^d             = "00"#,                        !00089
        pstm^stat^timeout^d            = "11"#,                        !00090
        pstm^stat^line^down^d          = "12"#;                        !00091
                                                                       !00092
define  no^compl^req^d                =  "0"#,                         !00093
        compl^req^d                   =  "1"#,                         !00094
        offline^compl^d               =  "2"#;                         !00095
                                                                       !00096
                                       ! Account codes                !!00097
                                                                       !00098
define  b24^checking^d                 = "01"#,                        !00099
        b24^savings^d                  = "11"#,                        !00100
        b24^credit^card^d              = "31"#;                        !00101
                                                                       !00102
define  return^card^d                  =  "0" #,                       !00103
        capture^card^d                 =  "1" #,                       !00104
        start^sent^d                   =  ";" #,                       !00105
                                                                       !00105M00
        track1^start^sent^d            =  "%" #,                       !00105M01
                                                                       !00105M02
        fld^sep^d                      =  "=" #,                       !00106
        end^sent^d                     =  "?" #;                       !00107
                                                                       !00108
                                       ! External 0100 message defines!!00109
                                                                       !00110
define  pstm^^purchase^d               =  "10"#,                       !00111
        pstm^^pre^auth^pur^d           =  "11"#,                       !00112
        pstm^^pre^auth^compl^d         =  "12"#;                       !00113
                                                                       !00114
                                       ! Transaction Codes            !!00115
                                                                       !00116
define  pstm^pur^d( x )            =    ( x.tran.tran^cde = "10" ) #,  !00117
        pstm^pre^auth^d( x )       =    ( x.tran.tran^cde = "11" ) #,  !00118
        pstm^pre^auth^compl^d( x ) =    ( x.tran.tran^cde = "12" ) #,  !00119
        pstm^mail^phone^d( x )     =    ( x.tran.tran^cde = "13" ) #,  !00120
        pstm^mdse^ret^d( x )       =    ( x.tran.tran^cde = "14" ) #,  !00121
        pstm^cash^adv^d( x )       =    ( x.tran.tran^cde = "15" ) #,  !00122
        pstm^crd^verify^d( x )     =    ( x.tran.tran^cde = "16" ) #,  !00123
        pstm^inquiry^d( x )        =    ( x.tran.tran^cde = "17" ) #,  !00124
        pstm^cash^back^d( x )      =    ( x.tran.tran^cde = "18" ) #,  !00125
        pstm^check^verify^d( x )   =    ( x.tran.tran^cde = "19" ) #,  !00126
        pstm^check^garant^d( x )   =    ( x.tran.tran^cde = "20" ) #,  !00127
        pstm^adj^pur^d( x )        =    ( x.tran.tran^cde = "21" ) #,  !00128
        pstm^adj^mdse^ret^d ( x )  =    ( x.tran.tran^cde = "22" ) #,  !00129
        pstm^adj^cash^adv^d ( x )  =    ( x.tran.tran^cde = "23" ) #,  !00130
        pstm^adj^cash^back^d ( x ) =    ( x.tran.tran^cde = "24" ) #;  !00131
                                                                       !00132
                                                                       !00132Z00
define   pre^auth^cash^back^d( x )      = ( x.tran.tran^cde = "11" and !00132Z01
                                            x.tran.amt^2 > 0f ) #;     !00132Z02
define   pre^auth^comp^cash^back^d( x ) = ( x.tran.tran^cde = "12" and !00132Z03
                                            x.tran.amt^2 > 0f ) #;     !00132Z04
                                                                       !00132Z05
                                                                       !00132K00
                                                                       !00132K01
                                                                       !00132L00
define  pstm^approved^d( x )  = ( x.tran.resp^cde.byte[0]  < "050")#,  !00132L01
                                                                       !00132L02
                                                                       !00132L03
                                                                       !00132L04
        pstm^bal^avail^d( x ) = ( x.tran.resp^cde.byte[1]  = "00" )#,  !00132K03
        pstm^cap^test^d( x )  = ( x.tran.resp^cde.byte[0]  = "9"  )    !00132K04
                              and (x.tran.resp^cde.byte[1] <="09")#;   !00132K05
                                                                       !00132K06
                                                                       !00141
define  pstm^adjustments^d( x ) = ( ( x.tran.tran^cde > "20" ) and     !00142
                                    ( x.tran.tran^cde < "25" ) )#;     !00143
                                                                       !00144
                                         ! Response codes             !!00145
                                                                       !00146
literal pstm^resp^no^err^l               =  000,                       !00147
        pstm^resp^apprv^no^bal^l         =  001,                       !00148
        pstm^resp^inv^pin^l              =  201,                       !00149
        pstm^resp^inv^tran^l             =  055,                       !00150
        pstm^resp^inv^amt^l              =  061,                       !00151
        pstm^resp^inv^sharing^l          =  053,                       !00152
        pstm^resp^referral^l             =  100,                       !00153
        pstm^resp^inv^service^l          =  105,                       !00154
                                                                       !00154O00
        pstm^resp^timeout^l              =  113,                       !00154O01
                                                                       !00154O02
        pstm^resp^frmt^err^l             =  069,                       !00155
        pstm^resp^decline^l              =  050,                       !00156
                                                                       !00156K00
        pstm^resp^expired^card^l         =  051,                       !00156K01
        pstm^resp^unable^to^auth^l       =  074,                       !00156K02
        pstm^resp^low^fund^err^l         =  076;                       !00156K03

!@==========================================================*!
!@ BEGIN RPQ #240 Special Response Code for Invalid MAC

literal pstm^invalid^mac^error^l         =  964;

!@ END   RPQ #240 Special Response Code for Invalid MAC
!@*=========================================================*!
                                                                       !00156K04
                                                                       !00157K00
                                                                       !00157K01
                                                                       !00157K02
                                                                       !00158
                                         ! Status Codes               !!00159
                                                                       !00160
literal pstm^stat^no^err^l               =  00,                        !00161
        pstm^stat^timeout^l              =  11,                        !00162
        pstm^stat^line^down^l            =  12;                        !00163
                                                                       !00164
                                         ! Reversal Codes             !!00165
                                                                       !00166
literal pstm^rvsl^no^err^l               =  00,                        !00167
        pstm^rvsl^timeout^l              =  01,                        !00168
        pstm^rvsl^cmd^reject^l           =  02,                        !00169
        pstm^rvsl^auth^not^avail^l       =  03,                        !00170
        pstm^rvsl^cust^cancelled^l       =  08,                        !00171
        pstm^rvsl^hardware^err^l         =  10,                        !00172
        pstm^rvsl^sys^err^l              =  19,                        !00173
                                                                       !00173K00
        pstm^rvsl^suspect^rvsl^l         =  20,                        !00173K01
        pstm^rvsl^mac^failure^l          =  21;                        !00173K02
                                                                       !00173K03
                                                                       !00174K00
                                                                       !00174K01
                                                                       !00175
?page "ISO dependent defines and literals"                             !00176
define  pos^approved^d( x )   = (                                      !00177
        (x.isopsem.resp^cde = "00" ) or ( x.isopsem.resp^cde = "11") or
        (x.isopsem.resp^cde = "08" ) or ( x.isopsem.resp^cde >= "76" and
         x.isopsem.resp^cde <= "81") )#;                               !00182
                                                                       !00183
define  pos^inquiry^d( x )   =   ( x.isopsem.proc^cde = "31" )#;       !00184
                                                                       !00185
define  pos^adjustment^d( x ) =  ( ( x.isopsem.proc^cde = "02" ) or    !00186
                                   ( x.isopsem.proc^cde = "22" ) or    !00187
                                   ( x.isopsem.proc^cde = "14" ) or    !00188
                                   ( x.isopsem.proc^cde = "19" ) )#;   !00189
                                                                       !00190
define  pos^normal^pur^d( x )         =  ( x.isopsem.proc^cde = "00" )#,
        pos^mail^phone^d( x )         =  ( x.isopsem.proc^cde = "80" )#,
        pos^mdse^ret^d( x )           =  ( x.isopsem.proc^cde = "20" )#,
        pos^cash^adv^d( x )           =  ( x.isopsem.proc^cde = "01" )#,
        pos^crd^verify^d( x )         =  ( x.isopsem.proc^cde = "81" )#,
        pos^bal^inq^d( x )            =  ( x.isopsem.proc^cde = "31" )#,
        pos^pur^w^cash^back^d( x )    =  ( x.isopsem.proc^cde = "09" )#,
        pos^check^verify^d( x )       =  ( x.isopsem.proc^cde = "04" )#,
        pos^check^garant^d( x )       =  ( x.isopsem.proc^cde = "03" )#,
                                                                       !00190500
                                                                       !00190501
        pos^adj^mdse^ret^d( x )       =  ( x.isopsem.proc^cde = "02" )#,
        pos^adj^pur^d( x )            =  ( x.isopsem.proc^cde = "22" )#,
                                                                       !00190506
        pos^adj^cash^adv^d( x )       =  ( x.isopsem.proc^cde = "14" )#,
        pos^adj^pur^w^cash^back^d( x ) =  ( x.isopsem.proc^cde = "19" )#;
                                                                       !00190K00
                                                                       !00190K01
define  pstm^lgth^d( x ) = ( $offset( x.srvcs ) +                      !00190K02
                             $len( x.srvcs ) *                         !00190K03
                             x.num^services )#;                        !00190K04
                                                                       !00190K05
                                                                       !00217
                                                                       !00217K00
                                                                       !00217U00
                                                                       !00217U01
                                                                       !00217K02
define                                                                 !00217K03
                                                                       !00217K04
                                                                       !00218K00
                                                                       !00218K01
        pos^proprietary^d             = "00"#;                         !00219
                                                                       !00220
                                                                       !00220D00
        !!                                                             !00220D01
        ! Address verification defines/literal!                        !00220D02
        !!                                                             !00220D03
define  av^addr^typ^d                 = "98"#, ! 98=AV data present!   !00220D04
        av^data^item^cde^d            = "01"#, ! 01=AV data item code! !00220D05
        av^retry^stat^d               = "R"#;  !  R=AV retry status!   !00220D06
                                                                       !00220D07
literal av^data^item^lgth^l           = 33; ! Length of AV data item!  !00220D08
                                                                       !00220D09
                                                                       !00220D0A
literal pos^tran^cde^lgth^l           = 5;                             !00221
                                                                       !00222
                                                                       !00222K00
literal num^pos^msgs^l                = 12;                            !00222K01
                                                                       !00222K02
                                                                       !00222K03
                                      ! Response codes                !!00223
                                                                       !00224
literal pos^resp^no^err^l             = 00,                            !00225
        pos^resp^cant^process^l       = 05,                            !00226
        pos^resp^inv^tran^l           = 12,                            !00227
        pos^resp^inv^amt^l            = 13,                            !00228
        pos^resp^frmt^err^l           = 30,                            !00229
        pos^resp^inv^pin^l            = 55,                            !00230
                                                                       !00230L00
        pos^cutover^in^prog^l         = 90,                            !00230L01
                                                                       !00230L02
                                                                       !00230K00
        pos^response^dpc^down^l       = 91,                            !00230K01
        pos^resp^system^err^l         = 96;                            !00230K02
                                                                       !00230K03
                                                                       !00231K00
                                                                       !00231K01
                                                                       !00232
                                      ! External reversal codes       !!00233
                                                                       !00234
literal pos^rvsl^ok^l                 = 00,                            !00235
        pos^rvsl^cancelled^l          = 17,                            !00236
        pos^rvsl^frmt^err^l           = 20,                            !00237
        pos^rvsl^partial^amt^l        = 32,                            !00238
                                                                       !00238H00
        pos^rvsl^support^err^l        = 40,                            !00238H01
                                                                       !00238H02
        pos^rvsl^timeout^l            = 68,                            !00239
        pos^rvsl^auth^not^avail^l     = 82;                            !00240
                                                                       !00241
                                                                       !00242
?PAGE "POS Global data Table"                                          !00243
!                                                                     !!00244
! POS global data stuctures                                           !!00245
!                                                                     !!00246
                                                                       !00247K00
struct   pos^tbl^def( * );                                             !00247K01
                                                                       !00247K02
    begin                                                              !00248
    string  pbit^map[ 0:15 ];                                          !00249
    string  sbit^map[ 0:15 ];                                          !00250
                                                                       !00251
    string  preq^map[ 0:15 ];                                          !00252
    string  sreq^map[ 0:15 ];                                          !00253
                                                                       !00254
    string  popt^map[ 0:15 ];                                          !00255
    string  sopt^map[ 0:15 ];                                          !00256
                                                                       !00257
                                                                       !00257K00
    string  pmac^map^in [ 0:15 ];                                      !00257K01
    string  pmac^map^out[ 0:15 ];                                      !00257K02
    string  smac^map^in [ 0:15 ];                                      !00257K03
    string  smac^map^out[ 0:15 ];                                      !00257K04
                                                                       !00257K05
    string  tkn^grp[ 0:3 ];                                            !00257K06
    string  full^mac^in;                                               !00257K07
    string  full^mac^out;                                              !00257K08
    int     mac^in^req;                                                !00257K09
                                                                       !00257K0A
    int     tran^ctr;                                                  !00258
    struct  tran^tbl( tran^def ) [ 0:max^tran^cdes^l - 1 ];            !00259
    end;                                                               !00260
                                                                       !00261
                                                                       !00262K00
struct   pos^def( * );                                                 !00262K01
                                                                       !00262K02
    begin                                                              !00263
    struct  p0100( pos^tbl^def );                                      !00264
    struct  p0110( pos^tbl^def );                                      !00265
    struct  p0120( pos^tbl^def );                                      !00266
    struct  p0130( pos^tbl^def );                                      !00267
    struct  p0200( pos^tbl^def );                                      !00268
    struct  p0210( pos^tbl^def );                                      !00269
    struct  p0220( pos^tbl^def );                                      !00270
    struct  p0230( pos^tbl^def );                                      !00271
    struct  p0402( pos^tbl^def );                                      !00272
    struct  p0412( pos^tbl^def );                                      !00273
    struct  p0420( pos^tbl^def );                                      !00274
    struct  p0430( pos^tbl^def );                                      !00275
    end;                                                               !00276
                                                                       !00277
                                                                       !00277K00
struct p63^addr^def( * );                                              !00277K01
    begin                                                              !00277K02
    string  addr^lgth[ 0:1 ];                                          !00277K03
    string  addr^cde[ 0:1 ];                                           !00277K04
    string  addr[ 0:19 ];                                              !00277K05
    string  zip^cde[ 0:8 ];                                            !00277K06
    end;                                                               !00277K07
                                                                       !00277K08
int(32)      pos^tkn^tbl     := -1d;                                   !00277K09
                                                                       !00277K0A
                                                                       !00277K0B
int     .ext pos( pos^def );                                           !00278
                                                                       !00279K00
                                                                       !00279K01
                                                                       !00279K02
                                                                       !00351
struct .pos^pct( pos^pct^def );                                        !00352
                                                                       !00353
int      pos^id^cde^g        := 2;                                     !00354
                                                                       !00355
int      pos^specific^ctr^g  := 0,                                     !00356
         pos^userdata^lgth^g := 0;                                     !00357
                                                                       !00358
string   pos^acct^type^g[ 0:0 ],                                       !00359
         pos^tran^cde^g[ 0:4 ];                                        !00360
                                                                       !00361
string  .pos^userdata^g[ 0:199 ];                                      !00362
                                                                       !00363
end block;                                                             !00364
                                                                       !00364M00
                                                                       !00364M01
?PAGE "                  - Forwards and Externals"                     !00364M02
                                                                       !00364e00
?NOLIST, SOURCE =SYSTEM_EXTDECS0(                                      !00364e01
?  GETPOOL,                                                            !00364e02
?  JULIANTIMESTAMP,                                                    !00364e03
?  NUMIN,                                                              !00364e04
?  SEGMENT_USE_ )                                                      !00364e05
                                                                       !00364e06
                                                                       !00364e07
                                                                       !00364e08
?LIST                                                                  !00364S06
                                                                       !00364e09
                                                                       !00364e0A
!  GETPOOL,!                                                           !00364S08
!  JULIANTIMESTAMP,!                                                   !00364S09
!  NUMIN,!                                                             !00364S0A
!  SEGMENT_USE_ )!                                                     !00364S0B
                                                                       !00364e0B
?nolist, source =oklib_oklibte(                                        !00364e0C
?  lib_file_rec_addr,                                                  !00364e0D
?  lib_hash_tbl_find,                                                  !00364e0E
?  )                                                                   !00364e0F
                                                                       !00364e0G
                                                                       !00364e0H
                                                                       !00364e0I
?list                                                                  !00364S0F
                                                                       !00364e0J
!  lib_file_rec_addr,                                                 !!00364e0K
                                                                       !00364e0L
!  lib_hash_tbl_find,                                                ! !00364S0G
!  )                                                                 ! !00364S0H
                                                                       !00364S0I
                                                                       !00364S0J
                                                                       !00364S0K
                                                                       !00364M0D
?nolist, source =rdebug_dumpext( programmatic^dump )                   !00364M0E
?list                                                                  !00364M0F
!  rdebug_dumpext( programmatic^dump )!                                !00364M0G
                                                                       !00364e0M
?nolist, source =spannet_skelexts(                                     !00364e0N
?  initialize^message,                                                 !00364e0O
?  logmessage^,                                                        !00364e0P
?  log^message,                                                        !00364e0Q
?  log^message^                                                        !00364e0R
?  netwrite )                                                          !00364e0S
                                                                       !00364e0T
                                                                       !00364e0U
                                                                       !00364e0V
?list                                                                  !00364M0M
!  initialize^message!                                                 !00364M0N
!  logmessage^,!                                                       !00364M0O
!  log^message,!                                                       !00364M0P
                                                                       !00364e0W
!  log^message^,                                                      !!00364e0X
                                                                       !00364e0Y
!  netwrite )!                                                         !00364M0Q
?nolist, source =aciutils_utilexts(                                    !00364M0R
?  all^ascii^double,                                                   !00364M0S
?  all^ascii^fixed,                                                    !00364M0T
?  all^ascii^integer,                                                  !00364M0U
?  ascii^double,                                                       !00364M0V
?  ascii^fixed,                                                        !00364M0W
?  ascii^integer,                                                      !00364M0X
?  binary^hexchar,                                                     !00364M0Y
?  binary^hexcharx,                                                    !00364M0Z
?  compare^ascii^yymmdd,                                               !00364N00
?  clearbit,                                                           !00364M10
?  delete^this^timer,                                                  !00364M11
?  find^specific^timer,                                                !00364M12
?  fixed^ascii,                                                        !00364M13
?  hexchar^binary,                                                     !00364M14
?  hexchar^binaryx,                                                    !00364M15
?  hexchar^integer,                                                    !00364M16
?  integer^ascii,                                                      !00364M17
?  julian^to^yymmdd,                                                   !00364M18
?  setbit,                                                             !00364M19
?  testbit,                                                            !00364M1A
?  translate,                                                          !00364M1B
?  yymmdd^to^julian )                                                  !00364M1C
?list                                                                  !00364M1D
!  all^ascii^double,!                                                  !00364M1E
!  all^ascii^fixed,!                                                   !00364M1F
!  all^ascii^integer,!                                                 !00364M1G
!  ascii^fixed,!                                                       !00364M1H
!  ascii^double,!                                                      !00364M1I
!  ascii^integer,!                                                     !00364M1J
!  binary^hexchar,!                                                    !00364M1K
!  binary^hexcharx,!                                                   !00364M1L
!  clearbit,!                                                          !00364M1M
                                                                       !00364N01
!  compare^ascii^yymmdd,!                                              !00364N02
                                                                       !00364N03
!  fixed^ascii,!                                                       !00364M1N
!  hexchar^binary,!                                                    !00364M1O
!  hexchar^binaryx,!                                                   !00364M1P
!  hexchar^integer,!                                                   !00364M1Q
!  integer^ascii,!                                                     !00364M1R
!  julian^to^yymmdd,!                                                  !00364M1S
!  setbit,!                                                            !00364M1T
!  testbit,!                                                           !00364M1U
!  translate,!                                                         !00364M1V
!  yymmdd^to^julian )!                                                 !00364M1W
                                                                       !00364S0L
?nolist, source =balib_balibte(                                        !00364S0M
?  lib_apcfemt_retrv,                                                  !00364S0N
?  lib_ipcfemt_retrv,                                                  !00364S0O
?  lib_iso_proc_cde_xlate )                                            !00364S0P
?list                                                                  !00364S0Q
!  lib_apcfemt_retrv,                                                ! !00364S0R
!  lib_ipcfemt_retrv,                                                ! !00364S0S
!  lib_iso_proc_cde_xlate )                                          ! !00364S0T
?nolist, source =basrc_bautile(                                        !00364S0U
?  abend^,                                                             !00364S0V
?  bu_apcfemt_retrv,                                                   !00364S0W
?  bu_extmem_alloc,                                                    !00364S0X
?  bu_extmem_dalloc,                                                   !00364S0Y
?  bu_ipcfemt_retrv,                                                   !00364S0Z
?  bu_map_b24_to_iso_pro_cde,                                          !00364S10
?  bu_segment_select,                                                  !00364S11
?  extract^track1^info,                                                !00364S12
?  get^tkn^mem^rec,                                                    !00364S13
?  lconf^read,                                                         !00364S14
?                                                                      !00364)00
?  supprs_trk1_discr_data                                              !00364)01
?  supprs_trk2_discr_data                                              !00364)02
?                                                                      !00364)03
?  tkn^add^info,                                                       !00364S15
?  tkn^get^info,                                                       !00364S16
?  tkn^del^info )                                                      !00364S17
?list                                                                  !00364S18
!  abend^,                                                           ! !00364S19
!  bu_apcfemt_retrv,                                                 ! !00364S1A
!  bu_extmem_alloc,                                                  ! !00364S1B
!  bu_extmem_dalloc,                                                 ! !00364S1C
!  bu_ipcfemt_retrv,                                                 ! !00364S1D
!  bu_map_b24_to_iso_pro_cde,                                        ! !00364S1E
!  bu_segment_select,                                                ! !00364S1F
!  extract^track1^info,                                              ! !00364S1G
!  get^tkn^mem^rec,                                                  ! !00364S1H
!  lconf^read,                                                       ! !00364S1I
                                                                       !00364)04
!  supprs_trk1_discr_data                                             !!00364)05
!  supprs_trk2_discr_data                                             !!00364)06
                                                                       !00364)07
!  tkn^add^info,                                                     ! !00364S1J
!  tkn^get^info,                                                     ! !00364S1K
!  tkn^del^info )                                                    ! !00364S1L
?nolist, source =basrc_bautils(                                        !00364S1M
?  emt_notes                                                           !00364S1N
?  )                                                                   !00364S1O
?list                                                                  !00364S1P
!  emt_notes                                                         ! !00364S1Q
!  )                                                                 ! !00364S1R
?nolist, source =basrc_hiswutle(                                       !00364S1S
?  hiswfile^keyposition,                                               !00364S1T
?  hiswfile^read,                                                      !00364S1U
?  hiswfile^update,                                                    !00364S1V
?  hiswilf^compress,                                                   !00364S1W
?  hiswilf^expand,                                                     !00364S1X
?  hiswmem^init,                                                       !00364S1Y
?  hiswpstm_txn_alwd_acq,                                              !00364S1Z
?  hiswpstm_txn_alwd_iss,                                              !00364S20
?  hiswsec^pin^xlate^mac^generate,                                     !00364S21
?  hiswsem_rvsl_txn_rte_pos,                                           !00364S22
?  hiswtkn^calc^seg^size,                                              !00364S23
?  hiswtkn^init^grp^tbl,                                               !00364S24
?  hiswtkn^init^mem^tbl,                                               !00364S25
?  hiswtkn^frmt^ext^tkn^to^ext^tkn,                                    !00364S26
?  hiswtkn^frmt^ext^tkn^to^int^tkn,                                    !00364S27
?  hiswtkn^frmt^int^tkn^to^ext^tkn,                                    !00364S28
?  hiswtkn^get^tkn,                                                    !00364S29
?  hiswtkn^set^acq^rte,                                                !00364S2A
?  hiswtkn^set^ps50^tkn,                                               !00364S2B
?  hiswtkn^set^txn^descr,                                              !00364S2C
?  hiswtkn^set^txn^prfl,                                               !00364S2D
?  hiswutil_acq_txn_rte,                                               !00364S2E
?  hiswutil^calc^intrn^msg^lgth,                                       !00364S2F
?                                                                      !00364)08
?  hiswutil^exp^dat^yymm,                                              !00364)09
?                                                                      !00364)0A
?  hiswutil^extract^track2^info,                                       !00364S2G
?  hiswutil^mmdd^to^yymmdd,                                            !00364S2H
?  hiswutil^pos^service^allowed,                                       !00364S2I
?  hiswutil^pos^trans^allowed,                                         !00364S2J
?  hiswutil^posting^date,                                              !00364S2K
?  hiswutil^weekend^or^holiday )                                       !00364S2L
?list                                                                  !00364S2M
!  hiswfile^keyposition,!                                              !00364S2N
!  hiswfile^read,!                                                     !00364S2O
!  hiswfile^update,!                                                   !00364S2P
!  hiswilf^compress,!                                                  !00364S2Q
!  hiswilf^expand,!                                                    !00364S2R
!  hiswmem^init,!                                                      !00364S2S
!  hiswpstm_txn_alwd_acq,!                                             !00364S2T
!  hiswpstm_txn_alwd_iss,!                                             !00364S2U
!  hiswsec^pin^xlate^mac^generate,!                                    !00364S2V
!  hiswsem_rvsl_txn_rte_pos,!                                          !00364S2W
!  hiswtkn^calc^seg^size,!                                             !00364S2X
!  hiswtkn^init^grp^tbl,!                                              !00364S2Y
!  hiswtkn^init^mem^tbl,!                                              !00364S2Z
!  hiswtkn^frmt^ext^tkn^to^ext^tkn,!                                   !00364S30
!  hiswtkn^frmt^ext^tkn^to^int^tkn,!                                   !00364S31
!  hiswtkn^frmt^int^tkn^to^ext^tkn,!                                   !00364S32
!  hiswtkn^get^tkn,!                                                   !00364S33
!  hiswtkn^set^acq^rte,!                                               !00364S34
!  hiswtkn^set^ps50^tkn,!                                              !00364S35
!  hiswtkn^set^txn^descr,!                                             !00364S36
!  hiswtkn^set^txn^prfl,!                                              !00364S37
!  hiswutil_acq_txn_rte,!                                              !00364S38
!  hiswutil^calc^intrn^msg^lgth,!                                      !00364S39
                                                                       !00364)0B
!  hiswutil^exp^dat^yymm,!                                             !00364)0C
                                                                       !00364)0D
!  hiswutil^extract^track2^info,!                                      !00364S3A
!  hiswutil^mmdd^to^yymmdd,!                                           !00364S3B
!  hiswutil^pos^service^allowed,!                                      !00364S3C
!  hiswutil^pos^trans^allowed,!                                        !00364S3D
!  hiswutil^posting^date,!                                             !00364S3E
!  hiswutil^weekend^or^holiday )!                                      !00364S3F
                                                                       !00364S3G
                                                                       !00364S3H
                                                                       !00364S3I
                                                                       !00364e0Z
?nolist, source =swbabi_babicie(                                       !00364e0a
?                                                                      !00364000
?  util^add^swi^cmn^data^tkn,                                          !00364001
?                                                                      !00364002
?  util^add^swi^tkn,                                                   !00364e0b
?  util^emf^bit^map,                                                   !00364e0c
?  util^emf^get,                                                       !00364e0d
?  util^emf^ims^cde,                                                   !00364e0e
?  util^frmt^ext^pin^to^int^pin,                                       !00364e0f
?  util^frmt^inst^id,                                                  !00364e0g
?  util^frmt^int^pin^to^ext^pin,                                       !00364e0h
?  util^gmt^ascii,                                                     !00364e0i
?  util^hdr^expand,                                                    !00364e0j
?  util^hdr^verify,                                                    !00364e0k
?  util^ilf^add,                                                       !00364e0l
?  util^ilf^dat,                                                       !00364e0m
?  util^ilf^get,                                                       !00364e0n
?  util^ilf^updt,                                                      !00364e0o
?  util^ims^get,                                                       !00364e0p
?  util^itf^updt,                                                      !00364e0q
?  util^link^status,                                                   !00364e0r
?  util^mac^generate,                                                  !00364e0s
?  util^mac^verify,                                                    !00364e0t
?  util^saf^add,                                                       !00364e0u
?  util^saf^delete,                                                    !00364e0v
?  util^sem^adjust,                                                    !00364e0w
?  util^sem^collapse,                                                  !00364e0x
?  util^sem^expand,                                                    !00364e0y
?  util^send^reject,                                                   !00364e0z
?  util^send^sem,                                                      !00364e10
?  util^station^avail,                                                 !00364e11
?  util^station^index,                                                 !00364e12
?  util^station^status,                                                !00364e13
?  util^suspend^tran^add,                                              !00364e14
?  util^suspend^tran^delete,                                           !00364e15
?  util^timer^delete,                                                  !00364e16
?  util^timer^insert,                                                  !00364e17
?  util^timer^find )                                                   !00364e18
                                                                       !00364e19
                                                                       !00364e1A
                                                                       !00364e1B
?list                                                                  !00364M4L
                                                                       !00364003
!  util^add^swi^cmn^data^tkn,                                         !!00364004
                                                                       !00364005
                                                                       !00364e1C
!  util^add^swi^tkn,                                                  !!00364e1D
                                                                       !00364e1E
!  util^emf^bit^map,!                                                  !00364M4M
!  util^emf^get,!                                                      !00364M4N
!  util^emf^ims^cde,!                                                  !00364M4O
!  util^frmt^inst^id,!                                                 !00364M4P
!  util^gmt^ascii,!                                                    !00364M4Q
!  util^hdr^expand,!                                                   !00364M4R
!  util^hdr^verify,!                                                   !00364M4S
!  util^ilf^add,!                                                      !00364M4T
!  util^ilf^dat,!                                                      !00364M4U
!  util^ilf^get,!                                                      !00364M4V
!  util^ilf^updt,!                                                     !00364M4W
!  util^ims^get,!                                                      !00364M4X
!  util^itf^updt,!                                                     !00364M4Y
!  util^link^status,!                                                  !00364M4Z
!  util^mac^generate,!                                                 !00364M50
!  util^mac^verify,!                                                   !00364M51
!  util^saf^add,!                                                      !00364M52
!  util^saf^delete,!                                                   !00364M53
!  util^sem^adjust,!                                                   !00364M54
!  util^sem^collapse,!                                                 !00364M55
!  util^sem^expand,!                                                   !00364M56
!  util^send^reject,!                                                  !00364M57
!  util^send^sem,!                                                     !00364M58
!  util^station^avail,!                                                !00364M59
!  util^station^index,!                                                !00364M5A
!  util^station^status,!                                               !00364M5B
!  util^suspend^tran^add,!                                             !00364M5C
!  util^suspend^tran^delete,!                                          !00364M5D
!  util^timer^delete,!                                                 !00364M5E
!  util^timer^insert,!                                                 !00364M5F
!  util^timer^find )!                                                  !00364M5G
?nolist, source =swpsbi_psbicie                                        !00364M5H
?list                                                                  !00364M5I
!  swpsbi_psbicie!                                                     !00364M5J
                                                                       !00364M5K
?section pos^^failed^message                                           !00364M5L
                                                                       !00365M00
                                                                       !00365M01
?page "                                        - pos^^failed^message"  !00508
!#####################################################################!!00509
!#                                                                   #!!00510
!#                       POS^^FAILED^MESSAGE                         #!!00511
!#                                                                   #!!00512
!#    NARRATIVE :  THIS PROCEDURE HANDLES ALL FAILED MESSAGES        #!!00513
!#       FROM THE NETWORK FOR BASE24-pos.                            #!!00514
!#                                                                   #!!00515
!#    INPUT PARAMETERS :                                             #!!00516
!#       MSG           : FAILED MESSAGE                              #!!00517
!#       MTP           : MESSAGE TEXT POINTER                        #!!00518
!#                                                                   #!!00519
!#    OUTPUT PARAMETERS:                                             #!!00520
!#                                                                   #!!00521
!#####################################################################!!00522
proc  pos^^failed^message( msg, mtp );                                 !00523
int     .msg;                                                          !00524
string  .mtp;                                                          !00525
    begin                                                              !00526
    wlform( trace, "T - pos^^failed^message" )                         !00527
                                                                       !00528
    struct .sem( sem^def );                                            !00529
                                                                       !00530
    int    .pstm( pstm^def ) := wordaddr( @mtp ),                      !00531
                                                                       !00531K00
            reject,                                                    !00531K01
                                                                       !00531K02
            sta^x,                                                     !00532
            trace^num,                                                 !00533
           .userbuf( timer^userbuf^def );                              !00534
                                                                       !00535
    if  trace^g.<pos^l> then                                           !00536
        call logmessage^( 1010,, @trace, net.myname, 0, @pos^prod^g ); !00537
                                                                       !00538
    if  util^station^index( msg^sym^source, sta^x ) then               !00539
        begin                                                          !00540
        call pos^util^sem^expand( sem, mtp, msg^length );              !00541
        call ascii^integer^( psem.trace^num, trace^num );              !00542
                                                                       !00542K00
        call ascii^integer^( psem.stat, reject );                      !00542K01
                                                                       !00542K02
                                                                       !00543
        if  sem^reject^d( psem ) then                                  !00544
            begin                                                      !00545
            psem.typ.byte[0] := "0";                                   !00546
                                                                       !00547
                                                                       !00547K00
                                                                       !00547K01
            if  psem.typ = tran^repeat^d or                            !00547K02
                psem.typ = auth^repeat^d or                            !00547K03
                psem.typ = rvsl^repeat^d or                            !00547K04
                psem.typ = rvsl^request^d or                           !00547K05
                                                                       !00547K06
                psem.typ = rvsl^request^repeat^d or                    !00552
                psem.typ = rvsl^response^d then                        !00553
                begin                                                  !00554
                !                                                     !!00555
                ! Rejected saf message; delete from file              !!00556
                !                                                     !!00557
                                                                       !00557K00
                if  @userbuf := util^timer^find( time^saf^l,           !00557K01
                                           trace^num,,, true ) then    !00557K02
                    begin                                              !00557K03
                    if reject <> key^sync^err^l      and               !00557K04
                       reject <> sec^device^failed^l then              !00557K05
                        begin                                          !00557K06
                        call util^saf^delete(                          !00557K07
                                      userbuf.nmm^prikey.sta^x );      !00557K08
                        return;                                        !00557K09
                        end                                            !00557K0A
                    else                                               !00557K0B
                        begin                                          !00557K0C
                        set( pct.saf.pending, false );                 !00557K0D
                        decrement( pct.sta[ sta^x ].pending );         !00557K0E
                        end;                                           !00557K0F
                    end;                                               !00557K0G
                                                                       !00557K0H
                                                                       !00558K00
                                                                       !00558K01
                                                                       !00558K02
                return;                                                !00564
                end;                                                   !00565
            end;                                                       !00566
                                                                       !00567
                                                                       !00567K00
        if  psem.typ = tran^request^d or                               !00567K01
            psem.typ = auth^request^d then                             !00567K02
            call pos^failed^0x00^sem^rqst( msg, mtp, sem, reject )     !00567K03
        else                                                           !00567K04
        if  psem.typ = tran^response^d or                              !00567K05
            psem.typ = auth^response^d then                            !00567K06
            call pos^failed^0x10^sem^resp( msg, mtp, sem, reject )     !00567K07
        else                                                           !00567K08
        if  psem.typ = tran^advice^d         or                        !00567K09
            psem.typ = auth^advice^d         or                        !00567K0A
            psem.typ = rvsl^advice^d         or                        !00567K0B
            psem.typ = rvsl^request^d        or                        !00567K0C
            psem.typ = rvsl^request^repeat^d then                      !00567K0D
            call pos^failed^0xxx^sem^advice( msg, mtp, sem, reject );  !00567K0E
                                                                       !00567K0F
                                                                       !00570K00
                                                                       !00570K01
                                                                       !00570K02
        end                                                            !00580
    else                                                               !00581
    if  pstm.typ = pstm^request^d  then                                !00582
        call pos^failed^0x00^pstm^rqst( msg, mtp, pstm )               !00583
    else                                                               !00584
                                                                       !00584E00
    if  pstm.typ = pstm^response^d  then                               !00584E01
        call pos^failed^0x10^pstm^resp( msg, mtp, pstm )               !00584E02
    else                                                               !00584E03
                                                                       !00584E04
        call log^message( 1011, pos^id^cde^g , mtp, $min( msg^length,  !00585
            max^logger^l ), net.myname, 2, @pos^prod^g );              !00586
                                                                       !00587
    end;                                                               !00588
?section pos^^initialization                                           !00589
?page "                                        - pos^^initialization"  !00590
!#####################################################################!!00591
!#                                                                   #!!00592
!#                        POS^^INITIALIZATION                        #!!00593
!#                                                                   #!!00594
!#    NARRATIVE : THIS IS THE MAIN PROCEDURE FOR INITIALIZATION.     #!!00595
!#       IT WILL RETURN TRUE OR FALSE DEPENDING UPON THE SUCCESS OF  #!!00596
!#       INITIALIZATION.                                             #!!00597
!#                                                                   #!!00598
!#    INPUT PARAMETERS:                                              #!!00599
                                                                       !00599K00
!#       WARMBOOT     : BOOLEAN FLAG SPECIFIES IF INITIALIZATION IS  #!!00599K01
!#                      THE RESULT OF A WARMBOOT COMMAND             #!!00599K02
                                                                       !00599K03
                                                                       !00600K00
                                                                       !00600K01
!#                                                                   #!!00601
!#    OUTPUT PARAMETERS:                                             #!!00602
!#                                                                   #!!00603
!#####################################################################!!00604
int proc pos^^initialization( warmboot );                              !00605
int  warmboot;                                                         !00606
    begin                                                              !00607
    wlform( ext^mem, "FAILURE to INITIALIZE Extended memory: Error #" )
    wlform( get^mem, "FAILURE to ALLOCATE Memory for Pos Table" )      !00610
                                                                       !00611
    struct   .emf( emf^def );                                          !00612
                                                                       !00613
    int(32)   seg^size;                                                !00614
                                                                       !00615
                                                                       !00615K00
    int      .tkn^grps[ 0:( ( ( num^pos^msgs^l + 1 ) *                 !00615K01
                            $len( emf.tkn^grp ) ) + 2 ) - 1 ];         !00615K02
                                                                       !00615K03
                                                                       !00615K04
    if  not pos^init^get^lconf^info( lconf^num^g ) then                !00616
        return false;                                                  !00617
                                                                       !00618
    call hiswutil^posting^date( pos^post^dat^g, pos^cutover^tim^g );   !00619
                                                                       !00620
    if  not warmboot then                                              !00621
        begin                                                          !00622
                                                                       !00623K00
                                                                       !00623K01
        seg^size := $dbl( $len( pos^def ) );                           !00624
                                                                       !00625
        if  ( @pos := getpool( mem^hdr, seg^size ) ) <= 0d then        !00626
            begin                                                      !00627
            call logmessage^( 1015,, @get^mem, net.myname, 3,          !00628
                @pos^prod^g, @seg^size );                              !00629
            return false;                                              !00630
            end;                                                       !00631
        end;                                                           !00632
                                                                       !00633
    init( pos, 00, wlen( pos ) );                                      !00634
                                                                       !00635
    ! Default Primary Bit Maps                                        !!00636
                                                                       !00637
                                                                       !00637K00
    pos.p0100.pbit^map     ':='    "B23C842128E1901B";                 !00637K01
    pos.p0100.preq^map     ':='    "B238800128A18018";                 !00637K02
    pos.p0100.popt^map     ':='    "0004042000401003";                 !00637K03
    pos.p0100.pmac^map^in  ':='    "B238040128819018";                 !00637K04
    pos.p0100.pmac^map^out ':='    "B238040128819018";                 !00637K05
                                                                       !00637K06
    pos.p0110.pbit^map     ':='    "B23E84012EC0801B";                 !00637K07
    pos.p0110.preq^map     ':='    "B23A80012E808018";                 !00637K08
    pos.p0110.popt^map     ':='    "0004040000400003";                 !00637K09
    pos.p0110.pmac^map^in  ':='    "B23804012E808018";                 !00637K0A
    pos.p0110.pmac^map^out ':='    "B23804012E808018";                 !00637K0B
                                                                       !00637K0C
    pos.p0120.pbit^map     ':='    "B23C84212EE1801B";                 !00637K0D
    pos.p0120.preq^map     ':='    "B23880012EA18018";                 !00637K0E
    pos.p0120.popt^map     ':='    "0004042000400003";                 !00637K0F
    pos.p0120.pmac^map^in  ':='    "B23804012E818018";                 !00637K0G
    pos.p0120.pmac^map^out ':='    "B23804012E818018";                 !00637K0H
                                                                       !00637K0I
    pos.p0130.pbit^map     ':='    "B22004012A80800B";                 !00637K0J
    pos.p0130.preq^map     ':='    "322000012A808008";                 !00637K0K
    pos.p0130.popt^map     ':='    "8000040000000003";                 !00637K0L
    pos.p0130.pmac^map^in  ':='    "B22004012A808008";                 !00637K0M
    pos.p0130.pmac^map^out ':='    "B22004012A808008";                 !00637K0N
                                                                       !00637K0O
!********************************************************************!
!  BEGIN RPQ #25 - Bill Payment                      MCD / 2269      !
!--------------------------------------------------------------------!
--* pos.p0200.pbit^map     ':='    "B23C84A12AF1941B";                 !00637K0P
    pos.p0200.pbit^map     ':='    "B23C84A12AF1949B";
    pos.p0200.preq^map     ':='    "B238800128A18018";                 !00637K0Q
--* pos.p0200.popt^map     ':='    "000404A002501403";                 !00637K0R
    pos.p0200.popt^map     ':='    "000404A002501483";
!--------------------------------------------------------------------!
!  END RPQ #25 - Bill Payment                        MCD / 2269      !
!********************************************************************!
    pos.p0200.pmac^map^in  ':='    "B23804012A919418";                 !00637K0S
    pos.p0200.pmac^map^out ':='    "B23804012A919418";                 !00637K0T
                                                                       !00637K0U
!********************************************************************!
!  BEGIN RPQ #25 - Bill Payment                     MCD / 2269       !
!--------------------------------------------------------------------!
--* pos.p0210.pbit^map     ':='    "B23E84812ED0841B";                 !00637K0V
    pos.p0210.pbit^map     ':='    "B23E84812ED1849B";
    pos.p0210.preq^map     ':='    "B23A80012E808018";                 !00637K0W
--* pos.p0210.popt^map     ':='    "0004048000500403";                 !00637K0X
    pos.p0210.popt^map     ':='    "0004048000510483";
!--------------------------------------------------------------------!
!  END RPQ #25  - Bill Payment                      MCD / 2269       !
!********************************************************************!

    pos.p0210.pmac^map^in  ':='    "B23804012E908418";                 !00637K0Y
    pos.p0210.pmac^map^out ':='    "B23804012E908418";                 !00637K0Z
                                                                       !00637K10
    pos.p0220.pbit^map     ':='    "B23C84A12EF1841B";                 !00637K11
    pos.p0220.preq^map     ':='    "B23880012EA18018";                 !00637K12
    pos.p0220.popt^map     ':='    "000404A000500403";                 !00637K13
    pos.p0220.pmac^map^in  ':='    "B23804012E918418";                 !00637K14
    pos.p0220.pmac^map^out ':='    "B23804012E918418";                 !00637K15
                                                                       !00637K16
    pos.p0230.pbit^map     ':='    "B22004812A80800B";                 !00637K17
    pos.p0230.preq^map     ':='    "322000010A808008";                 !00637K18
    pos.p0230.popt^map     ':='    "8000048000000003";                 !00637K19
    pos.p0230.pmac^map^in  ':='    "B22004012A808008";                 !00637K1A
    pos.p0230.pmac^map^out ':='    "B22004012A808008";                 !00637K1B
                                                                       !00637K1C
    pos.p0402.pbit^map     ':='    "B23C84012AE1801B";                 !00637K1D
    pos.p0402.preq^map     ':='    "B23880012AA18018";                 !00637K1E
    pos.p0402.popt^map     ':='    "0004040000400003";                 !00637K1F
    pos.p0402.pmac^map^in  ':='    "B23804012A818018";                 !00637K1G
    pos.p0402.pmac^map^out ':='    "B23804012A818018";                 !00637K1H
                                                                       !00637K1I
    pos.p0412.pbit^map     ':='    "B23804012A80800B";                 !00637K1J
    pos.p0412.preq^map     ':='    "B23800012A808008";                 !00637K1K
    pos.p0412.popt^map     ':='    "0000040000000003";                 !00637K1L
    pos.p0412.pmac^map^in  ':='    "B23804012A808008";                 !00637K1M
    pos.p0412.pmac^map^out ':='    "B23804012A808008";                 !00637K1N
                                                                       !00637K1O

!*==================================================================*!
!  BEGIN RPQ #25 - Bill Payment                     MCD / 2269       !
!--------------------------------------------------------------------!
--* pos.p0420.pbit^map     ':='    "B23E84812EE1841B";                 !00637K1P
    pos.p0420.pbit^map     ':='    "B23E84812EE1849B";
    pos.p0420.preq^map     ':='    "B23A80012EA18018";                 !00637K1Q
--* pos.p0420.popt^map     ':='    "0004048000400403";                 !00637K1R
    pos.p0420.popt^map     ':='    "0004048000400483";
!--------------------------------------------------------------------!
!  END RPQ #25  - Bill Payment                      MCD / 2269       !
!*==================================================================*!

    pos.p0420.pmac^map^in  ':='    "B23804012E818418";                 !00637K1S
    pos.p0420.pmac^map^out ':='    "B23804012E818418";                 !00637K1T
                                                                       !00637K1U
    pos.p0430.pbit^map     ':='    "B22004812A80800B";                 !00637K1V
    pos.p0430.preq^map     ':='    "B22000012A808008";                 !00637K1W
    pos.p0430.popt^map     ':='    "0000048000000003";                 !00637K1X
    pos.p0430.pmac^map^in  ':='    "B22004012A808008";                 !00637K1Y
    pos.p0430.pmac^map^out ':='    "B22004012A808008";                 !00637K1Z
                                                                       !00637K20
    ! Default Secondary Bit Maps!                                      !00637K21
                                                                       !00637K22
    pos.p0100.sbit^map     ':='    "00000000000000BD";                 !00637K23
    pos.p0100.sreq^map     ':='    "000000000000009C";                 !00637K24
    pos.p0100.sopt^map     ':='    "0000000000000021";                 !00637K25
    pos.p0100.smac^map^in  ':='    "0000000000000080";                 !00637K26
    pos.p0100.smac^map^out ':='    "0000000000000080";                 !00637K27
    pos.p0100.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K28
    pos.p0100.mac^in^req    :=     128;                                !00637K29
                                                                       !00637K2A
    pos.p0110.sbit^map     ':='    "00000000140000CD";                 !00637K2B
    pos.p0110.sreq^map     ':='    "0000000010000080";                 !00637K2C
    pos.p0110.sopt^map     ':='    "000000000400004D";                 !00637K2D
    pos.p0110.smac^map^in  ':='    "0000000004000080";                 !00637K2E
    pos.p0110.smac^map^out ':='    "0000000004000080";                 !00637K2F
    pos.p0110.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K2G
    pos.p0110.mac^in^req    :=     128;                                !00637K2H
                                                                       !00637K2I
    pos.p0120.sbit^map     ':='    "00000000140000FD";                 !00637K2J
    pos.p0120.sreq^map     ':='    "000000000000009C";                 !00637K2K
    pos.p0120.sopt^map     ':='    "0000000014000061";                 !00637K2L
    pos.p0120.smac^map^in  ':='    "0000000004000080";                 !00637K2M
    pos.p0120.smac^map^out ':='    "0000000004000080";                 !00637K2N
    pos.p0120.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K2O
    pos.p0120.mac^in^req    :=     128;                                !00637K2P
                                                                       !00637K2Q
    pos.p0130.sbit^map     ':='    "0000000004000005";                 !00637K2R
    pos.p0130.sreq^map     ':='    "0000000000000000";                 !00637K2S
    pos.p0130.sopt^map     ':='    "0000000004000005";                 !00637K2T
    pos.p0130.smac^map^in  ':='    "0000000004000000";                 !00637K2U
    pos.p0130.smac^map^out ':='    "0000000004000000";                 !00637K2V
    pos.p0130.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K2W
    pos.p0130.mac^in^req    :=     64;                                 !00637K2X
                                                                       !00637K2Y
    pos.p0200.sbit^map     ':='    "00000042000000BD";                 !00637K2Z
    pos.p0200.sreq^map     ':='    "000000000000009C";                 !00637K30
    pos.p0200.sopt^map     ':='    "0000004200000021";                 !00637K31
    pos.p0200.smac^map^in  ':='    "0000000200000080";                 !00637K32
    pos.p0200.smac^map^out ':='    "0000000200000080";                 !00637K33
    pos.p0200.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K34
    pos.p0200.mac^in^req    :=     128;                                !00637K35
                                                                       !00637K36
    pos.p0210.sbit^map     ':='    "00000042140000CD";                 !00637K37
    pos.p0210.sreq^map     ':='    "0000000010000080";                 !00637K38
    pos.p0210.sopt^map     ':='    "000000420400004D";                 !00637K39
    pos.p0210.smac^map^in  ':='    "0000000204000080";                 !00637K3A
    pos.p0210.smac^map^out ':='    "0000000204000080";                 !00637K3B
    pos.p0210.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K3C
    pos.p0210.mac^in^req    :=     128;                                !00637K3D
                                                                       !00637K3E
    pos.p0220.sbit^map     ':='    "00000042140000FD";                 !00637K3F
    pos.p0220.sreq^map     ':='    "000000000000009C";                 !00637K3G
    pos.p0220.sopt^map     ':='    "0000004214000061";                 !00637K3H
    pos.p0220.smac^map^in  ':='    "0000000204000080";                 !00637K3I
    pos.p0220.smac^map^out ':='    "0000000204000080";                 !00637K3J
    pos.p0220.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K3K
    pos.p0220.mac^in^req    :=     128;                                !00637K3L
                                                                       !00637K3M
    pos.p0230.sbit^map     ':='    "0000000004000005";                 !00637K3N
    pos.p0230.sreq^map     ':='    "0000000000000000";                 !00637K3O
    pos.p0230.sopt^map     ':='    "0000000004000005";                 !00637K3P
    pos.p0230.smac^map^in  ':='    "0000000004000000";                 !00637K3Q
    pos.p0230.smac^map^out ':='    "0000000004000000";                 !00637K3R
    pos.p0230.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K3S
    pos.p0230.mac^in^req    :=     64;                                 !00637K3T
                                                                       !00637K3U
    pos.p0402.sbit^map     ':='    "00000042140000FD";                 !00637K3V
    pos.p0402.sreq^map     ':='    "00000000140000FC";                 !00637K3W
    pos.p0402.sopt^map     ':='    "0000004200000001";                 !00637K3X
    pos.p0402.smac^map^in  ':='    "0000000204000080";                 !00637K3Y
    pos.p0402.smac^map^out ':='    "0000000204000080";                 !00637K3Z
    pos.p0402.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K40
    pos.p0402.mac^in^req    :=     128;                                !00637K41
                                                                       !00637K42
    pos.p0412.sbit^map     ':='    "0000000004000085";                 !00637K43
    pos.p0412.sreq^map     ':='    "0000000004000084";                 !00637K44
    pos.p0412.sopt^map     ':='    "0000000000000001";                 !00637K45
    pos.p0412.smac^map^in  ':='    "0000000004000080";                 !00637K46
    pos.p0412.smac^map^out ':='    "0000000004000080";                 !00637K47
    pos.p0412.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K48
    pos.p0412.mac^in^req    :=     128;                                !00637K49
                                                                       !00637K4A
    pos.p0420.sbit^map     ':='    "00000042140000FD";                 !00637K4B
    pos.p0420.sreq^map     ':='    "00000040100000BC";                 !00637K4C
    pos.p0420.sopt^map     ':='    "0000000204000041";                 !00637K4D
    pos.p0420.smac^map^in  ':='    "0000000204000080";                 !00637K4E
    pos.p0420.smac^map^out ':='    "0000000204000080";                 !00637K4F
    pos.p0420.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K4G
    pos.p0420.mac^in^req    :=     128;                                !00637K4H
                                                                       !00637K4I
    pos.p0430.sbit^map     ':='    "0000004004000085";                 !00637K4J
    pos.p0430.sreq^map     ':='    "0000004000000084";                 !00637K4K
    pos.p0430.sopt^map     ':='    "0000000004000001";                 !00637K4L
    pos.p0430.smac^map^in  ':='    "0000000004000080";                 !00637K4M
    pos.p0430.smac^map^out ':='    "0000000004000080";                 !00637K4N
    pos.p0430.tkn^grp      ':='    pct.fiid for $len( pct.fiid );      !00637K4O
    pos.p0430.mac^in^req    :=     128;                                !00637K4P
                                                                       !00637K4Q
                                                                       !00637K4R
                                                                       !00638K00
                                                                       !00638K01
                                                                       !00638K02
    if  emf^name^g <> invalid^name^d then                              !00736
        begin                                                          !00737
        !                                                             !!00738
        ! Get the bit maps and ims codes from the emf                 !!00739
        !                                                             !!00740
                                                                       !00740K00
        init( tkn^grps, "  ", wlen( tkn^grps ) );                      !00740K01
                                                                       !00740K02
                                                                       !00740K03
        emf.prikey ':=' blanks for $len( emf.prikey );                 !00741
        while util^emf^get( emf, $len( emf ), pos^l ) do               !00742
            begin                                                      !00743
                                                                       !00743K00
            if  not pos^init^emf( emf, pos, tkn^grps ) then            !00743K01
                                                                       !00743K02
                                                                       !00744K00
                                                                       !00744K01
                return false;                                          !00745
            end;                                                       !00746
        end;                                                           !00747
                                                                       !00748
                                                                       !00748K00
    !!                                                                 !00748K01
    !make sure the default token group gets added to the table!        !00748K02
    !!                                                                 !00748K03
    call hiswtkn^init^grp^tbl( , pct.fiid,, tkn^grps );                !00748K04
                                                                       !00748K05
    if tkn^num^g > 0           and                                     !00748K06
       pos^tkn^tbl^size^g > 0d and                                     !00748K07
       not warmboot            then                                    !00748K08
        !!                                                             !00748K09
        !load the POS TKN records int extended memory!                 !00748K0A
        !!                                                             !00748K0B
        call hiswtkn^init^mem^tbl( tkn^num^g, mem^hdr,                 !00748K0C
                                   pos^tkn^tbl^size^g, pos^l,          !00748K0D
                                   pos^tkn^tbl, tkn^grps );            !00748K0E
                                                                       !00748K0F
                                                                       !00748K0G
    return true;                                                       !00749
    end;                                                               !00750
?section pos^^input^from^process                                       !00751
?page "                                 - pos^^input^from^process"     !00751K00
!#####################################################################!!00754
!#                                                                   #!!00755
!#                    POS^^INPUT^FROM^PROCESS                        #!!00756
!#                                                                   #!!00757
!#    NARRATIVE : THIS PROCEDURE DETERMINES IF THE MESSAGE TYPE IS   #!!00758
!#       VALID FOR A BASE24 POS INTERNAL MESSAGE.  IF SO, THE        #!!00759
!#       APPROPRIATE BRANCH IS TAKEN TO THE CORRECT PROCEDURE        #!!00760
!#       OTHERWISE FALSE IS RETURNED TO THE CALLING PROCEDURE.       #!!00761
!#                                                                   #!!00762
!#    INPUT PARAMETERS :                                             #!!00763
!#       MSG           : MESSAGE WORD POINTER                        #!!00764
!#       MTP           : MESSAGE TEXT POINTER                        #!!00765
!#                                                                   #!!00766
!#    OUTPUT PARAMETERS:                                             #!!00767
!#                                                                   #!!00768
!#####################################################################!!00769
proc  pos^^input^from^process( msg, mtp );                             !00770
int     .msg;                                                          !00771
string  .mtp;                                                          !00772
    begin                                                              !00773
    wlform( bad^typ, "UNKNOWN PSTM Type \\\\ Received from \s" )       !00774
    wlform( trace,   "T - pos^^input^from^process (type: \\\\)" )      !00775
                                                                       !00776
    define    msg^type( i )  =  msg^types[ ( i ) * 4 ] #;              !00777
                                                                       !00778
    string    msg^types = 'p' := [                                     !00779
                                                                       !00780
              "0200",   ! transaction request                         !!00781
              "0210",   ! transaction response                        !!00782
              "0220",   ! transaction advice                          !!00783
              "0402",   ! transaction reversal request                !!00784
              "0412",   ! transaction reversal response               !!00785
              "0420",   ! transaction reversal                        !!00786
                   0 ];                                                !00787
                                                                       !00788
    struct   .sem( sem^def );                                          !00789
                                                                       !00790:00
    int       i := -1;                                                 !00790:01
                                                                       !00790:02
    int      .pstm( pstm^def ) := wordaddr( @mtp );                    !00791
                                                                       !00792
    if  trace^g.<pos^l> then                                           !00793
        call logmessage^( 1020,, @trace, net.myname, 0,                !00794
            @pos^prod^g, @pstm.typ );                                  !00795
                                                                       !00796
    pos^tran^cde^g ':=' pstm.tran.tran^cde for pos^tran^cde^lgth^l;    !00797
                                                                       !00798
    if  pstm.data^flag <> "0" then                                     !00799
        begin                                                          !00800
        pos^userdata^lgth^g := $min( 200,                              !00801
            pstm.srvcs[ pstm.num^services ].typ.byte[1] );             !00802
                                                                       !00803
                                                                       !00804M00
                                                                       !00804M01
        pos^userdata^g ':=' pstm.srvcs[pstm.num^services].typ.byte[2]  !00805
             for pos^userdata^lgth^g;                                  !00806
        end;                                                           !00807
    !                                                                 !!00808
    !  Verify the message type                                        !!00809
    !                                                                 !!00810
                                                                       !00811:00
    i := -1;                                                           !00811:01
                                                                       !00811:02
    while msg^type( i := i+1 ) and pstm.typ <>                         !00812
          msg^type( i ) for  $len( pstm.typ ) do;                      !00813
                                                                       !00814
    if  not msg^type( i ) then                                         !00815
        begin                                                          !00816
        call logmessage^( 1025, , @bad^typ, msg^sym^source, 2,         !00817
            @pos^prod^g, @pstm.typ, msg^sym^source );                  !00818
        return;                                                        !00819
        end;                                                           !00820
                                                                       !00821
!@*****************************************************************!
!@ BEGIN RPQ #270 Determine Card Type for Interchange Card Trans.
!@----------------------------------------------------------------*!
if pstm.tran.tran^cde.t  = "0" and    ! no card type
   pstm.rte.srv         <> "  " then  ! a service was determine
   Begin

    if pstm.rte.srv = "P"  or     ! proprietary debit
       pstm.rte.srv = "MD" or     ! mastercard debit
       pstm.rte.srv = "VD"  then  ! visa debit
       begin
        pstm.tran.tran^cde.t := "2";   ! debit card
       end
    else
     begin
      pstm.tran.tran^cde.t := "1";     ! credit card
     end;

   End;
!@----------------------------------------------------------------*!
!@ END   RPQ #270 Determine Card Type for Interchange Card Trans.
!@*****************************************************************!

    if  pstm.typ.byte[2] <> "1" then                                   !00822
        begin                                                          !00823
        !                                                             !!00824
        ! Get the POS table and initialize the SEM                    !!00825
        !                                                             !!00826
        if  not pstm^approved^d( pstm ) then                           !00827
            !                                                         !!00828
            ! Don't post denied transactions                          !!00829
            !                                                         !!00830
            return;                                                    !00831
        incr^trace( trace^num^g );                                     !00832
                                                                       !00832M00
                                                                       !I0083200
        if trace^num^g = 18259 then                                    !I0083201
                                                                       !I0083202
            incr^trace( trace^num^g );                                 !00832M02
                                                                       !00832M03
        call pstm^frmt^b24^to^pos^sem( pstm, sem );                    !00833
        end;                                                           !00834
                                                                       !00835
      case i of                                                        !00836
        begin                                                          !00837
                                                                       !00837K00
    !0200! call pstm^0200^request  ( msg, pstm, sem );                 !00837K01
                                                                       !00837K02
                                                                       !00838K00
                                                                       !00838K01
    !0210! call pstm^0210^response ( msg, pstm, sem );                 !00839
    !0220! call pstm^0220^advice   ( msg, pstm, sem );                 !00840
    !0402! call pstm^0402^request  ( msg, pstm, sem );                 !00841
    !0412! call pstm^0412^response ( msg, pstm, sem );                 !00842
    !0420! call pstm^0420^reversal ( msg, pstm, sem );                 !00843
    !????! otherwise                                                   !00844
               call programmatic^dump( 1200 );                         !00845
        end;                                                           !00846
                                                                       !00847
    end;                                                               !00848
?section pos^^input^from^station                                       !00849
?page "                                 - pos^^input^from^station"     !00849K00
!#####################################################################!!00852
!#                                                                   #!!00853
!#                    POS^^INPUT^FROM^STATION                        #!!00854
!#                                                                   #!!00855
!#    NARRATIVE : THIS PROCEDURE DETERMINES WHETHER A MESSAGE WAS    #!!00856
!#       RECEIVED ON A VALID STATION, AND IF SO IT DETERMINES THE    #!!00857
!#       THE TYPE OF MESSAGE RECEIVED AND BRANCHES TO THE            #!!00858
!#       APPROPRIATE PROCEDURE TO PROCESS THE MESSAGE.               #!!00859
!#                                                                   #!!00860
!#    INPUT PARAMETERS:                                              #!!00861
!#       MSG           : MESSAGE WORD POINTER                        #!!00862
!#       MTP           : MESSAGE TEXT POINTER                        #!!00863
                                                                       !00863K00
!#       SEM           : EXPANDED SEM POINTER                        #!!00863K01
                                                                       !00863K02
                                                                       !00863K03
                                                                       !00863K04
                                                                       !00863K05
!#                                                                   #!!00864
!#    OUTPUT PARAMETERS:                                             #!!00865
!#                                                                   #!!00866
!#####################################################################!!00867
                                                                       !00867I00
proc  pos^^input^from^station( msg, mtp, sem );                        !00867I01
                                                                       !00867I02
                                                                       !00868I00
                                                                       !00868I01
int     .msg;                                                          !00869
                                                                       !00869K00
string  .mtp;                                                          !00869K01
int     .sem( sem^def );                                               !00869K02
                                                                       !00869K03
                                                                       !00869K04
                                                                       !00870K00
                                                                       !00870K01
                                                                       !00870K02
    begin                                                              !00871
    wlform( trace,   "T - pos^^input^from^station (typ: \\\\)" )       !00872
                                                                       !00873
    define    msg^type( i )   =   msg^types[ ( i ) * 4 ] #;            !00874
                                                                       !00875
    string    msg^types = 'p' := [                                     !00876
    !                                                                 !!00877
    !    Message                                                      !!00878
    !     Type                                                        !!00879
    !                                                                 !!00880
    !                                                                 !!00881
         "0100",   ! auth request                                     !!00882
         "0110",   ! auth response                                    !!00883
         "0120",   ! auth advice                                      !!00884
         "0121",   ! auth advice repeat                               !!00885
         "0130",   ! auth advice acknowledge                          !!00886
         "0200",   ! request                                          !!00887
         "0210",   ! response                                         !!00888
         "0220",   ! advice                                           !!00889
         "0221",   ! advice repeat                                    !!00890
         "0230",   ! advice acknowledge                               !!00891
         "0402",   ! card issuer reversal request                     !!00892
         "0403",   ! card issuer reversal repeat                      !!00893
         "0412",   ! card issuer reversal response                    !!00894
         "0420",   ! reversal                                         !!00895
         "0421",   ! reversal repeat                                  !!00896
         "0430",   ! reversal acknowledge                             !!00897
              0 ];                                                     !00898
                                                                       !00899
                                                                       !00899K00
                                                                       !00899K01
                                                                       !00899K02
                                                                       !00902
                                                                       !00902K00
    int                                                                !00902K01
                                                                       !00902M00
            mac^in^req,                                                !00902M01
                                                                       !00902M02
                                                                       !00902M03
                                                                       !00902M04
           .sim[ 0:( intrn^msg^lmt^l / 2 ) - 1 ],                      !00902K03
           .pstm( pstm^def ) := @sim,                                  !00902K04
            reject;                                                    !00902K05
                                                                       !00902K06
    string                                                             !00902K07
            full^msg^mac,                                              !00902K08
           .pmac^map[ 0:15 ],                                          !00902K09
           .smac^map[ 0:15 ];                                          !00902K0A
                                                                       !00902K0B
                                                                       !00903K00
                                                                       !00903K01
                                                                       !00904
    if  trace^g.<pos^l> then                                           !00905
        call logmessage^( 1030,, @trace,                               !00906
            net.myname, 0, @pos^prod^g, @mtp[12] );                    !00907
                                                                       !00908
    pos^tran^cde^g ':=' blanks for pos^tran^cde^lgth^l;                !00909
                                                                       !00910
                                                                       !00910K00
    if  reject := pos^util^hdr^verify( mtp, full^msg^mac,              !00910K01
                                       pmac^map, smac^map,             !00910K02
                                       mac^in^req ) then               !00910K03
                                                                       !00910K04
                                                                       !00911K00
                                                                       !00911K01
        call util^send^reject( msg, reject^inv^map^l, reject )         !00912
    else                                                               !00913
                                                                       !00913K00
    if  not pos^util^sem^expand( sem, mtp, msg^length, reject,         !00913K01
                                 full^msg^mac, pmac^map,               !00913K02
                                 smac^map, mac^in^req ) then           !00913K03
        begin                                                          !00913K04
        if reject = key^sync^err^l         or                          !00913K05
           reject = invalid^mac^err^l      or                          !00913K06
           reject = sec^operation^failed^l or                          !00913K07
           reject = sec^device^failed^l    then                        !00913K08
            begin                                                      !00913K09
            call util^send^reject( msg, reject, reject );              !00913K0A
            !!                                                         !00913K0B
            !deny the tran if the message was a response!              !00913K0C
            !!                                                         !00913K0D
            if psem.typ = tran^response^d or                           !00913K0E
               psem.typ = auth^response^d then                         !00913K0F
                call pos^failed^0x00^sem^rqst( msg, mtp, sem,          !00913K0G
                                               reject );               !00913K0H
            end                                                        !00913K0I
        else                                                           !00913K0J
        if reject = bit^64^mac^err^l then                              !00913K0K
            call util^send^reject( msg, reject^inv^map^l, bit^64^l )   !00913K0L
        else                                                           !00913K0M
        if reject = bit^128^mac^err^l then                             !00913K0N
            call util^send^reject( msg, reject^inv^map^l, bit^128^l )  !00913K0O
        else                                                           !00913K0P
            call util^send^reject( msg, reject^fld^lgth^l, reject );   !00913K0Q
        end                                                            !00913K0R
                                                                       !00913K0S
                                                                       !00914K00
                                                                       !00914K01
                                                                       !00914K02
    else                                                               !00916
        begin                                                          !00917
        if  psem.typ.byte[2] = "0" or psem.typ.byte[2] = "2" then      !00918
            !                                                         !!00919
            ! This is a request or advice                             !!00920
            !                                                         !!00921
            begin                                                      !00922
            incr^trace( trace^num^g );                                 !00923
                                                                       !00923M00
                                                                       !I0092300
            if trace^num^g = 18259 then                                !I0092301
                                                                       !I0092302
                incr^trace( trace^num^g );                             !00923M02
                                                                       !00923M03
            call pos^frmt^sem^to^pstm( sem, pstm );                    !00924
                                                                       !00924K00
            set( pstm.entry^tim, juliantimestamp( ) );                 !00924K01
                                                                       !00924K02
            end;                                                       !00927
        !                                                             !!00928
        ! Verify the message type                                     !!00929
        !                                                             !!00930
        use i; i := -1;                                                !00931
        while msg^type( i:=i+1 ) and  psem.typ <>                      !00932
              msg^type( i ) for $len( psem.typ ) do;                   !00933
                                                                       !00934
        if  not msg^type( i ) then                                     !00935
            call util^send^reject( msg, reject^msg^typ^l )             !00936
        else                                                           !00937
            case i of                                                  !00938
              begin                                                    !00939
                                                                       !00939K00
          !0100! call pos^0200^request    ( msg, sem, pstm, mtp );     !00939K01
                                                                       !00939K02
                                                                       !00940K00
                                                                       !00940K01
          !0110! call pos^0210^response   ( msg, sem, pstm );          !00941
          !0120! call pos^0220^advice     ( msg, sem, pstm );          !00942
          !0121! call pos^0220^advice     ( msg, sem, pstm );          !00943
          !0130! call pos^0230^ack        ( msg, sem, pstm );          !00944
                                                                       !00944K00
          !0200! call pos^0200^request    ( msg, sem, pstm, mtp );     !00944K01
                                                                       !00944K02
                                                                       !00945K00
                                                                       !00945K01
          !0210! call pos^0210^response   ( msg, sem, pstm );          !00946
          !0220! call pos^0220^advice     ( msg, sem, pstm );          !00947
          !0221! call pos^0220^advice     ( msg, sem, pstm );          !00948
          !0230! call pos^0230^ack        ( msg, sem, pstm );          !00949
          !0402! call pos^0402^request    ( msg, sem, pstm );          !00950
          !0403! call pos^0402^request    ( msg, sem, pstm );          !00951
          !0412! call pos^0412^response   ( msg, sem, pstm );          !00952
          !0420! call pos^0420^reversal   ( msg, sem, pstm );          !00953
          !0421! call pos^0420^reversal   ( msg, sem, pstm );          !00954
          !0430! call pos^0430^ack        ( msg, sem, pstm );          !00955
          !????! otherwise                                             !00956
                     call programmatic^dump( 1300 );                   !00957
              end;                                                     !00958
        drop i;                                                        !00959
        end;                                                           !00960
                                                                       !00961
    end;                                                               !00962
?section pos^0200^deny                                                 !00963
?page "                                        - pos^0200^deny"        !00964
                                                                       !00965
!#####################################################################!!00966
!#                                                                   #!!00967
!#                        POS^0200^DENY                              #!!00968
!#                                                                   #!!00969
!#    NARRATIVE : THIS PROCEDURE FORMATS AND RETURNS A RESPONSE      #!!00970
!#       DENIAL TO THE CO-NETWORK.                                   #!!00971
!#                                                                   #!!00972
!#    INPUT PARAMETERS :                                             #!!00973
!#       PRIKEY        : POINTER TO TRANSACTION PRIMARY KEY          #!!00974
!#       SEM           : POINTER TO BIC EXTERNAL MESSAGE             #!!00975
                                                                       !00976K00
                                                                       !00976K01
!#       DEST          : STATION TO WHICH THE RESPONSE WILL BE SENT  #!!00977
!#       RESP^CDE      : RESPONSE CODE                               #!!00978
!#       SUB           : ILF SUBSTATE                                #!!00979
!#                                                                   #!!00980
!#    OUTPUT PARAMETERS:                                             #!!00981
!#                                                                   #!!00982
!#####################################################################!!00983
                                                                       !00983K00
proc pos^0200^deny( prikey, sem, dest, resp^cde,                       !00983K01
                    sub, b24^msg )variable;                            !00983K02
                                                                       !00983K03
                                                                       !00984K00
                                                                       !00984K01
int  .prikey( prikey^def );                                            !00985
int  .sem( sem^def );                                                  !00986
int  .dest;                                                            !00987
int   resp^cde;                                                        !00988
int   sub;                                                             !00989
                                                                       !00989K00
int  .b24^msg;                                                         !00989K01
                                                                       !00989K02
    begin                                                              !00990
    wlform( trace, "T - pos^0200^deny ( Response Code: ## )" )         !00991
                                                                       !00991K00
    wlform( mac^fail, "MAC Generation failure on POS \\\\ message " )  !00991K01
                                                                       !00991K02
    string                                                             !00991K03
                .tkn^grp[ 0:3 ];                                       !00991K04
                                                                       !00991K05
    int                                                                !00991K06
            error,                                                     !00991K07
           .sim[ 0:( intrn^msg^lmt^l / 2 ) - 1 ],                      !00991K08
                                                                       !00991S00
            sta^x,                                                     !00991S01
                                                                       !00991S02
                                                                       !00992K00
                                                                       !00992K01
                                                                       !00993K00
           .pstm( pstm^def ) := @sim;                                  !00993K01
                                                                       !00993K02
                                                                       !00994
    if  trace^g.<pos^l> then                                           !00995
        call logmessage^( 1035,, @trace, net.myname,                   !00996
            0, @pos^prod^g, resp^cde );                                !00997
                                                                       !00998
                                                                       !00998K00
                                                                       !00998S00
    call util^station^index( dest, sta^x );                            !00998S01
                                                                       !00998S02
    if not $param( b24^msg ) then                                      !00998K01
        begin                                                          !00998K02
        call pos^frmt^sem^to^pstm( sem, pstm );                        !00998K03
                                                                       !00998S03
        call pos^frmt^sem^to^pstm^0200( sem, pstm, sta^x );            !00998S04
                                                                       !00998S05
        end                                                            !00998K05
    else                                                               !00998K06
        @pstm := @b24^msg;                                             !00998K07
                                                                       !00998K08
                                                                       !00998K09
                                                                       !00999K00
                                                                       !00999K01
                                                                       !00999K02
    movd ( psem.responder,            switch^interface^origin^d );     !01001
    if  psem.typ = auth^request^d then                                 !01002
        begin                                                          !01003
        movd ( psem.typ,                  auth^response^d    );        !01004
        mov^ ( psem.pri^bit^map,          pos.p0110.pbit^map );        !01005
        mov^ ( psem.secndry^bit^map,      pos.p0110.sbit^map );        !01006
        movd ( pstm.typ,                  tran^request^d     );        !01007
                                                                       !01007K00
        movl ( tkn^grp, pos.p0110.tkn^grp, $occurs( tkn^grp ) );       !01007K01
                                                                       !01007K02
        end                                                            !01008
    else                                                               !01009
    if  psem.typ = tran^request^d then                                 !01010
        begin                                                          !01011
        movd ( psem.typ,                  tran^response^d    );        !01012
        mov^ ( psem.pri^bit^map,          pos.p0210.pbit^map );        !01013
        mov^ ( psem.secndry^bit^map,      pos.p0210.sbit^map );        !01014
        movd ( pstm.typ,                  tran^request^d     );        !01015
                                                                       !01015K00
        movl ( tkn^grp, pos.p0210.tkn^grp, $occurs( tkn^grp ) );       !01015K01
                                                                       !01015K02
                                                                       !01015D00
        !!                                                             !01015D01
        ! Set address verification status on denied transaction!       !01015D02
        !!                                                             !01015D03
        movd ( psem.resp^data.pos.addr^vrfy^stat, av^retry^stat^d );   !01015D04
        movd ( psem.resp^data.len,                "02" );              !01015D05
                                                                       !01015D06
        end                                                            !01016
    else                                                               !01017
    if  psem.typ = rvsl^request^d        or                            !01018
        psem.typ = rvsl^request^repeat^d then                          !01019
        begin                                                          !01020
        movd ( psem.typ,                  rvsl^response^d    );        !01021
        mov^ ( psem.pri^bit^map,          pos.p0412.pbit^map );        !01022
        mov^ ( psem.secndry^bit^map,      pos.p0412.sbit^map );        !01023
                                                                       !01023K00
                                                                       !01023M00
        movl ( tkn^grp, pos.p0412.tkn^grp, $occurs( tkn^grp ) );       !01023M01
                                                                       !01023M02
                                                                       !01023M03
                                                                       !01023M04
                                                                       !01023K02
        movd ( pstm.typ,                  rvsl^request^d     );        !01024
        end;                                                           !01025
                                                                       !01026
    mov^ ( psem.xmit^dat^tim,         zeroes              );           !01027
    mov^ ( psem.setl^dat,             pos^post^dat^g[ 2 ] );           !01028
    movd ( psem.resp^cde,             "05"                );           !01029
                                                                       !01029O00
    mov^ ( psem.pri^rsrvd2^prvt.pos.crd^fiid, zeroes      );           !01029O01
    mov^ ( psem.pri^rsrvd2^prvt.pos.crd^ln,  zeroes       );           !01029O02
                                                                       !01029O03
                                                                       !01030O00
                                                                       !01030O01
                                                                       !01030O02
                                                                       !01032
                                                                       !01032K00
    call pos^frmt^sem^to^sem^tkn( sem, tkn^grp );                      !01032K01
                                                                       !01032K02
                                                                       !01032K03
    if  integer^ascii^( psem.resp^cde, resp^cde ) then                 !01033
                                                                       !01033K00
        if ( error := pos^util^send^sem( sem, dest ) ) and             !01033K01
             error <> true then                                        !01033K02
            begin                                                      !01033K03
            call logmessage^( 1037,, @mac^fail, net.myname,            !01033K04
                              2, @pos^prod^g, @psem.typ );             !01033K05
            end;                                                       !01033K06
                                                                       !01033K07
                                                                       !01034K00
                                                                       !01034K01
                                                                       !01035
    call util^ilf^add( pstm.acq^ichg^setl^dat, prikey,                 !01036
        $len( prikey^def ), pos^l, sub,, pstm, sem );                  !01037
    end;                                                               !01038
?section pos^0200^request                                              !01039
?page "                                        - pos^0200^request"     !01040
!#####################################################################!!01041
!#                                                                   #!!01042
!#                        POS^0200^REQUEST                           #!!01043
!#                                                                   #!!01044
!#    NARRATIVE : THIS PROCEDURE RECEIVES A REQUEST FROM A STATION,  #!!01045
!#       FORMATS A PSTM REQUEST, SETS A TIMER AND SENDS THE MESSAGE  #!!01046
!#       TO THE AUTHORIZATION PROCESS.                               #!!01047
!#                                                                   #!!01048
!#    INPUT PARAMETERS:                                              #!!01049
!#       MSG          : POINTER TO MESSAGE                           #!!01050
!#       SEM          : POINTER TO BIC EXTERNAL MESSAGE              #!!01051
!#       PSTM         : POINTER TO BASE24 INTERNAL POS MESSAGE       #!!01052
                                                                       !01052K00
!#       MTP          : POINTER TO THE TEXT PROTION OF THE EXT MSG   #!!01052K01
                                                                       !01052K02
!#                                                                   #!!01053
!#    OUTPUT PARAMETERS:                                             #!!01054
!#                                                                   #!!01055
!#####################################################################!!01056
                                                                       !01056K00
proc pos^0200^request( msg, sem, pstm, mtp );                          !01056K01
                                                                       !01056K02
                                                                       !01057K00
                                                                       !01057K01
int  .msg;                                                             !01058
int  .sem( sem^def );                                                  !01059
int  .pstm( pstm^def );                                                !01060
                                                                       !01060K00
string .mtp;                                                           !01060K01
                                                                       !01060K02
    begin                                                              !01061
                                                                       !01061K00
    wlform( ilf^err, "Transaction denied due to a previous error" ','  !01061K01
            " on the ILF - Correct the problem and warmboot " )        !01061K02
    wlform( saf^err, "Transaction denied due to a previous error" ','  !01061K03
            " on the SAF - Correct the problem and warmboot " )        !01061K04
                                                                       !01061K05
                                                                       !01061K06
                                                                       !01061S00
    string   log_auth_dest_resp := " ";                                !01061S01
                                                                       !01061S02
    struct  .susp( susp^bici^def );                                    !01062
                                                                       !01063
                                                                       !01063S00
    int     .auth_dest[ 0:wordlen( $len( pstm.rte.pri ) ) - 1 ];       !01063S01
    int      fatal_flg := true;                                        !01063S02
                                                                       !01063S03
    int      resp^cde,                                                 !01064
                                                                       !01064L00
            .timer( timer^def ),                                       !01064L01
                                                                       !01064L02
             sta^x;                                                    !01065
                                                                       !01065N00
                                                                       !01065N01
    string .cap^dat^yymmdd [ 0:5 ];                                    !01065N02
                                                                       !01065N03
                                                                       !01066
    if  msg^poss^dup^( msg ) then                                      !01067
        !                                                             !!01068
        ! Drop request                                                !!01069
        !                                                             !!01070
        return;                                                        !01071
                                                                       !01072
    init( susp,                "  ", wlen( susp^bici^def ) );          !01073
    movl( susp.orig^net^pro,   msg^sym^source, 8 );                    !01074
    set ( susp.msg^lgth, msg^length        );                          !01075
                                                                       !01075K00
    movl( susp.msg,      mtp, msg^length );                            !01075K01
                                                                       !01075K02
                                                                       !01076K00
                                                                       !01076K01
                                                                       !01077
    call pos^frmt^sem^to^prikey( sem, susp.prikey.tran^tim );          !01078
    call util^station^index( msg^sym^source, sta^x );                  !01079
                                                                       !01080
                                                                       !01080L00
                                                                       !01080N00
    call hiswutil^mmdd^to^yymmdd( psem.cap^dat, cap^dat^yymmdd );      !01080N01
                                                                       !01080N02
    if  pct.options.ctvr = master^l and                                !01080L01
                                                                       !01080N03
        compare^ascii^yymmdd( cap^dat^yymmdd, 1, pct.ilf.cur.dat ) and !01080N04
                                                                       !01080N05
                                                                       !01080N06
                                                                       !01080N07
                                                                       !01080N08
        ( @timer := find^specific^timer( tcb^g,                        !01080L04
                                         time^setl^interval^l )) then  !01080L05
        begin                                                          !01080L06
        call pos^0200^deny( susp.prikey, sem, msg^sym^source,          !01080L07
            pos^cutover^in^prog^l, sub^down^at^rqst^l );               !01080L08
        return;                                                        !01080L09
        end;                                                           !01080L0A
                                                                       !01080L0B
                                                                       !01080L0C
    if  not util^ilf^dat( psem.cap^dat ) then                          !01081
        begin                                                          !01082
        move ( pstm.acq^ichg^setl^dat, pct.ilf.cur.dat );              !01083
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01084
                                                                       !01084L00
            pos^resp^cant^process^l, sub^fail^pre^auth^l, pstm );      !01084L01
                                                                       !01084L02
                                                                       !01085L00
                                                                       !01085L01
        return;                                                        !01086
        end;                                                           !01087
                                                                       !01088
                                                                       !01089S00
    if  resp^cde := pos^frmt^sem^to^pstm^0200( sem, pstm, sta^x )then  !01089S01
                                                                       !01089S02
        begin                                                          !01090
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01091
                                                                       !01091K00
                            resp^cde, sub^fail^pre^auth^l, pstm );     !01091K01
                                                                       !01091K02
                                                                       !01092K00
                                                                       !01092K01
        return;                                                        !01093
        end;                                                           !01094
                                                                       !01095
                                                                       !01095K00
    if pct.ilf.ferror and pct.ilf.ferror <> feeof then                 !01095K01
        begin                                                          !01095K02
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01095K03
            pos^resp^cant^process^l, sub^sys^err^l );                  !01095K04
        call logmessage^( 1038,, @ilf^err, net.myname,                 !01095K05
                          2, @pos^prod^g );                            !01095K06
        return;                                                        !01095K07
        end;                                                           !01095K08
                                                                       !01095K09
    if pct.saf.ferror and pct.saf.ferror <> feeof then                 !01095K0A
        begin                                                          !01095K0B
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01095K0C
            pos^resp^cant^process^l, sub^sys^err^l );                  !01095K0D
        call logmessage^( 1039,, @saf^err, net.myname,                 !01095K0E
                          2, @pos^prod^g );                            !01095K0F
                                                                       !01095K0G
                                                                       !01096K00
                                                                       !01096K01
                                                                       !01096K02
        return;                                                        !01101
        end;                                                           !01102
                                                                       !01103
                                                                       !01103L00
    if  not pct.status.ctvr^ack then                                   !01103L01
        begin                                                          !01103L02
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01103L03
            pos^cutover^in^prog^l, sub^down^at^rqst^l );               !01103L04
        return;                                                        !01103L05
        end;                                                           !01103L06
                                                                       !01103L07
                                                                       !01103L08
!@==================================================================!
!@ BEGIN  * RPQ   Kirk emergency fix #2   ***  2011-03-24 KW Patch. !
!@------------------------------------------------------------------!

 -- *** This is the statement that I think is the problem
 -- *** I suggest we comment the first 3 conditions.
 -- *** If the problem doesn't occur, then one of these 3 flags
 -- ***  could be corrupted by an uninitialized pointer
 -- ***
 -- *** if the problem still happens after this, then the problem
 -- ***  is in either the timer table or extended memory
 -- ***
 -- *** To find the uninitalized pointer requires both reviewing CSM
 -- ***  source and most likely creating a saveabend/dump when the
 -- ***    problem is occurring, before the stop/start


-- *if  not pct.status.linkup   or not pct.options.issuer or           !01104
                                                                       !01104L00
-- *    not pct.options.pos.present or                                 !01104L01
                                                                       !01104L02
                                                                       !01105L00
                                                                       !01105L01
   IF   not util^suspend^tran^add( susp, $len( susp^bici^def ),        !01106

!@------------------------------------------------------------------!
!@ END    * RPQ   Kirk emergency fix #2   ***  2011-03-24 KW Patch. !
!@==================================================================!

           pos^pct.timers.inbound, time^inbound^rqst^l,                !01107
           trace^num^g, sta^x, pos^l ) then                            !01108
        begin                                                          !01109
        call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,       !01110
            pos^resp^cant^process^l, sub^down^at^rqst^l );             !01111
        return;                                                        !01112
        end;                                                           !01113
                                                                       !01113S00
                                                                       !01113e00
    !                                                                 !!01113e01
    ! Add the switch token                                            !!01113e02
    !                                                                 !!01113e03
    if base24^rel^g >= 5 then                                          !01113e04
        begin                                                          !01113e05
        util^add^swi^tkn( sem, pstm, pos^l, acq^l );                   !01113e06
                                                                       !01113000
        call util^add^swi^cmn^data^tkn( sem,                           !01113001
                                        pstm,                          !01113002
                                        pos^l );                       !01113003
                                                                       !01113004
        end;                                                           !01113e07
                                                                       !01113e08
    if base24^rel^g >= 6 then                                          !01113S01
        begin                                                          !01113S02
        !                                                            ! !01113S03
        ! Release 6.0 and higher. Perform APCF routing               ! !01113S04
        !                                                            ! !01113S05
        if resp^cde := hiswutil_acq_txn_rte( pstm,                     !01113S06
                                             icf^name^g,               !01113S07
                                             apcfemt_seg_id_g,         !01113S08
                                             apcfemt_name_g,           !01113S09
                                             pos^pct.dest,             !01113S0A
                                             msg^sym^source,           !01113S0B
                                             apcf_emt_rec_g,           !01113S0C
                                             auth_dest,                !01113S0D
                                             fatal_flg,                !01113S0E
                                             log_auth_dest_resp ) then !01113S0F
            begin                                                      !01113S0G
            call pos^0200^deny( susp.prikey,                           !01113S0H
                                sem,                                   !01113S0I
                                susp.orig^net^pro,                     !01113S0J
                                pos^resp^cant^process^l,               !01113S0K
                                sub^sys^err^l );                       !01113S0L
            return;                                                    !01113S0M
            end                                                        !01113S0N
        else                                                           !01113S0O
            begin                                                      !01113S0P
            call pos^util^send^pstm( pstm, auth_dest );                !01113S0Q
            end;                                                       !01113S0R
        end ! of base24^rel^g >= 6                                   ! !01113S0S
    else                                                               !01113S0T
        begin                                                          !01113S0U
        call pos^util^send^pstm( pstm, pos^pct.dest.name );            !01113S0V
        end;                                                           !01113S0W
                                                                       !01113S0X
                                                                       !01114S00
                                                                       !01114S01
                                                                       !01114S02
    end;                                                               !01117
?section pos^0210^deny                                                 !01118
?page "                                        - pos^0210^deny"        !01119
!#####################################################################!!01120
!#                                                                   #!!01121
!#                        POS^0210^DENY                              #!!01122
!#                                                                   #!!01123
                                                                       !01123K00
!#    NARRATIVE : THIS PROCEDURE FORMATS AND RETURNS A REVERSAL      #!!01123K01
!#                TO THE CO-NETWORK.                                 #!!01123K02
                                                                       !01123K03
                                                                       !01124K00
                                                                       !01124K01
                                                                       !01124K02
!#                                                                   #!!01126
!#    INPUT PARAMETERS :                                             #!!01127
                                                                       !01127K00
!#       SEM           : POINTER TO THE EXTERNAL MESSAGE             #!!01127K01
                                                                       !01127K02
!#       DEST          : MESSAGE DESTINATION                         #!!01128
!#       RVSL^CDE      : REVERSAL CODE                               #!!01129
                                                                       !01129L00
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!
                                                                       !01129L03
!#                                                                   #!!01130
!#    OUTPUT PARAMETERS:                                             #!!01131
!#                                                                   #!!01132
!#####################################################################!!01133
                                                                       !01133K00
                                                                       !01133L00
proc pos^0210^deny( sem, dest, rvsl^cde, pstm );                       !01133L01
                                                                       !01133L02
                                                                       !01133L03
                                                                       !01133L04
                                                                       !01133K02
                                                                       !01134K00
                                                                       !01134K01
int  .sem( sem^def );                                                  !01135
int  .dest;                                                            !01136
int   rvsl^cde;                                                        !01137
                                                                       !01137L00
int  .pstm( pstm^def );                                                !01137L01
                                                                       !01137L02
                                                                       !01138
    begin                                                              !01139
    wlform( trace, "T - pos^0210^deny ( Reversal Code: ## )" )         !01140
                                                                       !01141
    struct .isem( sem^def );                                           !01142
                                                                       !01143
                                                                       !01144K00
    int     csem^lgth,                                                 !01144K01
            error;                                                     !01144K02
                                                                       !01144K03
                                                                       !01145
                                                                       !01145K00
    string                                                             !01145K01
                .csem := byteaddr( @isem ),                            !01145K02
                .tkn^grp[ 0:3 ];                                       !01145K03
                                                                       !01145K04
                                                                       !01146K00
                                                                       !01146K01
                                                                       !01147
    if  trace^g.<pos^l> then                                           !01148
        call logmessage^( 1040,, @trace, net.myname, 0,                !01149
            @pos^prod^g, rvsl^cde );                                   !01150
                                                                       !01151
                                                                       !01151L00
    if  ( pos^approved^d( sem ) and                                    !01151L01
          ( reverse^bal^inq^g and pos^inquiry^d( sem ) ) ) then        !01151L02
    else                                                               !01151L03
                                                                       !01151L04
    if  not pos^approved^d( sem ) or pos^inquiry^d( sem ) then         !01152
        !                                                             !!01153
        ! Don't rvsl denied or non-monetary transactions              !!01154
        !                                                             !!01155
        return;                                                        !01156
                                                                       !01157
    mov^ ( ssem.b24^orig,                   zeroes                );   !01158
    movl ( ssem.b24^orig.orig^typ,          psem.typ,          2  );   !01159
                                                                       !01160+00
                                                                       !01160+01
    move ( ssem.b24^orig.orig^seq^num,      psem.retrvl^ref^num   );   !01160+02
    move ( ssem.b24^orig.orig^tran^dat,     psem.tran^dat         );   !01160+03
    move ( ssem.b24^orig.orig^tran^tim,     psem.tran^tim         );   !01160+04
    move ( ssem.b24^orig.orig^b24^post^dat, psem.cap^dat          );   !01160+05
                                                                       !01160+06
                                                                       !01164
    movd ( psem.typ,                        rvsl^advice^d         );   !01165
    mov^ ( psem.pri^bit^map,                pos.p0420.pbit^map    );   !01166
    mov^ ( psem.secndry^bit^map,            pos.p0420.sbit^map    );   !01167
    mov^ ( psem.xmit^dat^tim,               zeroes                );   !01168
                                                                       !01168s00
    if sem.isopsem.cap^dat = blanks for                                !01168s01
            $len( sem.isopsem.cap^dat) then                            !01168s02
        begin                                                          !01168s03
        mov^( psem.cap^dat, zeroes );                                  !01168s04
        end;                                                           !01168s05
                                                                       !01168s06
    if sem.isopsem.entry^mde = blanks for                              !01168s07
            $len( sem.isopsem.entry^mde ) then                         !01168s08
        begin                                                          !01168s09
        mov^( psem.entry^mde, zeroes );                                !01168s0A
        end;                                                           !01168s0B
                                                                       !01168s0C
    if sem.isopsem.pt^tran^spcl^cde = blanks for                       !01168s0D
            $len( sem.isopsem.pt^tran^spcl^cde ) then                  !01168s0E
        begin                                                          !01168s0F
        mov^( psem.pt^tran^spcl^cde, zeroes );                         !01168s0G
        end;                                                           !01168s0H
                                                                       !01168s0I
    movd ( psem.crd^accpt^name^loc,                                    !01169
        "** REVERSAL FOR LATE/UNSOL RESPONSE **" );                    !01170
                                                                       !01171
    if  not integer^ascii^( psem.trace^num, incr^trace( trace^num^g ) ) or
        not integer^ascii^( psem.resp^cde, rvsl^cde ) then             !01174
        call programmatic^dump( 1400 );                                !01175
                                                                       !01175L00
    !!                                                                 !01175L01
    !make sure pos^tran^code^g is set correctly!                       !01175L02
    !!                                                                 !01175L03
                                                                       !01175y00
    if  pstm.tran.tran^cde.tc = "10"  and                              !01175y01
        pstm.tran.tran^cde.aa = "00"  then                             !01175y02
        call pos^frmt^sem^to^pstm^tran( sem, pstm );                   !01175y03
                                                                       !01175y04
                                                                       !01175y05
                                                                       !01175y06
                                                                       !01175y07
                                                                       !01175L08
                                                                       !01176L00
                                                                       !01176L01
                                                                       !01176K00
    movl( tkn^grp, pos.p0420.tkn^grp, $occurs( tkn^grp ) );            !01176K01
                                                                       !01176K02
    call pos^frmt^sem^to^sem^tkn( sem, tkn^grp );                      !01176K03
                                                                       !01176K04
    if not ( error := pos^util^sem^collapse( sem, csem,                !01176K05
                                             csem^lgth ) ) then        !01176K06
                                                                       !01176K07
                                                                       !01177K00
                                                                       !01177K01
        call util^saf^add( csem, csem^lgth );                          !01178
    end;                                                               !01179
?section pos^0210^response                                             !01180
?page "                                        - pos^0210^response"    !01181
                                                                       !01182
!#####################################################################!!01183
!#                                                                   #!!01184
!#                        POS^0210^RESPONSE                          #!!01185
!#                                                                   #!!01186
!#    NARRATIVE : THIS PROCEDURE RECEIVES A RESPONSE FROM A STATION. #!!01187
!#       IF A TIMER EXISTS, A PSTM RESPONSE IS FORMATTED AND SENT TO #!!01188
!#       THE AUTHORIZATION PROCESS.                                  #!!01189
!#                                                                   #!!01190
!#    INPUT PARAMETERS:                                              #!!01191
!#       MSG          : MESSAGE WORD POINTER                         #!!01192
!#       SEM          : MESSAGE TEXT POINTER                         #!!01193
                                                                       !01193K00
!#       PSTM         : POINTER TO THE INTERNAL MESSAGE              #!!01193K01
                                                                       !01193K02
!#                                                                   #!!01194
!#    OUTPUT PARAMETERS:                                             #!!01195
!#                                                                   #!!01196
!#####################################################################!!01197
proc pos^0210^response( msg, sem, pstm );                              !01198
int  .msg;                                                             !01199
int  .sem( sem^def );                                                  !01200
int  .pstm( pstm^def );                                                !01201
    begin                                                              !01202
    wlform( bad, "Mismatched Trace number \\\\\\ Received from Co-network" )
                                                                       !01205
                                                                       !01205M00
    struct .susp( susp^bici^def ),                                     !01205M01
           .ilf( ilf^def );                                            !01205M02
    int     fnum,                                                      !01205M03
            ilf^lgth,                                                  !01205M04
            trace^num,                                                 !01205M05
                                                                       !01205M06
                                                                       !01206M00
                                                                       !01206M01
                                                                       !01206M02
            track^lgth,                                                !01209
           .userbuf( timer^userbuf^def );                              !01210
                                                                       !01210H00
                                                                       !01210H01
                                                                       !01210y00
                                                                       !O0121000
                                                                       !O0121001
                                                                       !O0121002
                                                                       !01210y02
                                                                       !01210H03
                                                                       !01210K00
                                                                       !01210K01
!#####################################################################!!01210K02
!#                                                                   #!!01210K03
!#  This subproc will reset the mac.out^cons^err^cnt if the request  #!!01210K04
!#  message was set up to be mac'ed.                                 #!!01210K05
!#                                                                   #!!01210K06
!#####################################################################!!01210K07
subproc reset^mac^cons^err^cnt;                                        !01210K08
                                                                       !01210K09
    begin                                                              !01210K0A
                                                                       !01210K0B
    int                                                                !01210K0C
             bit^map[ 0:7 ];                                           !01210K0D
                                                                       !01210K0E
    if pct.mac.mac^typ = "1" then                                      !01210K0F
        begin                                                          !01210K0G
        if psem.typ = auth^response^d then                             !01210K0H
            begin                                                      !01210K0I
            call hexchar^binaryx( pos.p0100.popt^map,                  !01210K0J
                                  16, bit^map[ 0 ] );                  !01210K0K
            call hexchar^binaryx( pos.p0100.sopt^map,                  !01210K0L
                                  16, bit^map[ 4 ] );                  !01210K0M
            end                                                        !01210K0N
        else                                                           !01210K0O
        if psem.typ = tran^response^d then                             !01210K0P
            begin                                                      !01210K0Q
            call hexchar^binaryx( pos.p0200.popt^map,                  !01210K0R
                                  16, bit^map[ 0 ] );                  !01210K0S
            call hexchar^binaryx( pos.p0200.sopt^map,                  !01210K0T
                                  16, bit^map[ 4 ] );                  !01210K0U
            end;                                                       !01210K0V
                                                                       !01210K0W
        if ( not testbit( bit^map, 0   )   and                         !01210K0X
                 testbit( bit^map, 63  ) ) or                          !01210K0Y
           (     testbit( bit^map, 0   )   and                         !01210K0Z
                 testbit( bit^map, 127 ) ) then                        !01210K10
            begin                                                      !01210K11
            if pct.options.num^keys = "1" then                         !01210K12
                set( pct.mac.in^cons^err^cnt,  0 )                     !01210K13
            else                                                       !01210K14
                set( pct.mac.out^cons^err^cnt, 0 );                    !01210K15
            end;                                                       !01210K16
        end;                                                           !01210K17
    end;                                                               !01210K18
                                                                       !01210K19
                                                                       !01210K1A
                                                                       !01211
    call ascii^integer^( psem.track2.len, track^lgth );                !01212
    call ascii^integer^( psem.trace^num,  trace^num  );                !01213
                                                                       !01214
                                                                       !01214I00
    init( susp,                "  ", wlen( susp^bici^def ) );          !01214I01
    call pos^frmt^sem^to^prikey( sem, susp.prikey.tran^tim );          !01214I02
                                                                       !01214I03
                                                                       !01214I04
    if  not ( @userbuf := util^suspend^tran^delete( susp,              !01215
                                                                       !01215H00
                                                                       !01215I00
           $len( susp^bici^def ), msg, time^outbound^rqst^l ) ) then   !01215I01
                                                                       !01215I02
                                                                       !01215I03
                                                                       !01215I04
                                                                       !01215I05
                                                                       !01215H03
                                                                       !01215H04
                                                                       !01216H00
                                                                       !01216H01
                                                                       !01216H02
        begin                                                          !01218
                                                                       !01218L00
        if  ( pct.options.proto^typ = "03" ) then                      !01218L01
                                                                       !01218L02
           ! return without sending a reversal.  The reversal was     !
           ! sent when the request timed out and the protocol = X.25  !
            begin                                                      !01218L07
            call reset^mac^cons^err^cnt;                               !01218L08
            return;                                                    !01218L09
            end                                                        !01218L0A
        else                                                           !01218L0B
            begin                                                      !01218L0C
                                                                       !01218L0D
        !                                                             !!01219
        ! Transaction timed out, reverse any approved monetary        !!01220
        ! transactions                                                !!01221
        !                                                             !!01222
                                                                       !01222L00
            call pos^0210^deny( sem, msg^sym^source,                   !01222L01
                                pos^rvsl^timeout^l, pstm );            !01222L02
                                                                       !01222L03
                                                                       !01222M00
        ! Update ILF record to reflect reversal of late response      !
            if  updt^ilf^on^late^resp^g and                            !01222M03
                psem.typ = rvsl^advice^d then                          !01222M04
                begin                                                  !01222M05
                if  ( fnum := util^ilf^get( susp.prikey,               !01222M06
                                   $len( susp.prikey ), ilf, ilf^lgth ) ) then
                                                                       !01222M09
                    call util^ilf^updt( fnum, ilf, ilf^lgth,           !01222M0A
                                                   pos^l,,,, sem )     !01222M0B
                else                                                   !01222M0C
                    call util^ilf^add( pct.ilf.cur.dat, susp.prikey,   !01222M0D
                                         $len( susp.prikey ), pos^l,   !01222M0E
                                         sub^timeout^l,,, sem );       !01222M0F
                end;                                                   !01222M0G
                                                                       !01222M0H
                                                                       !01222M0I
            call reset^mac^cons^err^cnt;                               !01222L04
                                                                       !01222L05
            return;                                                    !01222L06
            end;                                                       !01222L07
                                                                       !01222L08
                                                                       !01223L00
                                                                       !01223L01
                                                                       !01223L02
        end;                                                           !01225
                                                                       !01226
                                                                       !01226K00
    call reset^mac^cons^err^cnt;                                       !01226K01
                                                                       !01226K02
                                                                       !01226K03
                                                                       !01227K00
                                                                       !01227g00
                                                                       !01227t00
    pstm.typ ':=' susp.msg for wrds( susp.msg^lgth );                  !01227t01
                                                                       !01227t02
                                                                       !01227g02
                                                                       !01227K02
                                                                       !01228
    if  pstm.data^flag <> "0" then                                     !01229
        begin                                                          !01230
        pos^userdata^lgth^g :=                                         !01231
            pstm.srvcs[pstm.num^services].typ.byte[ 1 ];               !01232
        pos^userdata^g     ':='                                        !01233
            pstm.srvcs[pstm.num^services].typ.byte[ 2 ]                !01234
            for $min( pos^userdata^lgth^g, 200 );                      !01235
        end;                                                           !01236
                                                                       !01237
    if  psem.retrvl^ref^num <> pstm.seq^num for $len( pstm.seq^num ) and
        psem.retrvl^ref^num <> blanks       for $len( pstm.seq^num ) then
        begin                                                          !01242
        !                                                             !!01243
        ! Trace number and sequence number don't match                !!01244
        !                                                             !!01245
        call logmessage^( 1045,, @bad, net.myname, 2,                  !01246
            @pos^prod^g, @psem.trace^num );                            !01247
                                                                       !01247L00
                                                                       !01247L01
        call pos^0210^deny( sem, msg^sym^source,                       !01247L02
                            pos^rvsl^frmt^err^l, pstm );               !01247L03
                                                                       !01247L04
                                                                       !01247L05
        call pstm^0200^deny( susp.prikey, pstm, susp.orig^net^pro,     !01250
            pstm^resp^frmt^err^l, sub^frmt^err^l );                    !01251
        return;                                                        !01252
        end;                                                           !01253
                                                                       !01254
                                                                       !01254H00
                                                                       !O0125400
                                                                       !O0125401
    if  not pos^frmt^sem^to^pstm^0210( sem, pstm ) then                !O0125402
        if pstm.tran.resp^cde = "076" then                             !O0125403
                                                                       !O0125404
            begin                                                      !01254H03
            call pos^0210^deny( sem,                                   !01254H04
                                msg^sym^source,                        !01254H05
                                                                       !01254L00
                                                                       !01254L01
                                pos^rvsl^support^err^l, pstm );        !01254L02
                                                                       !01254L03
                                                                       !01254L04
                                                                       !01254L05
                                                                       !01254L06
                                                                       !01254L07
                                                                       !01254L08
            call pstm^0200^deny( susp.prikey,                          !01254H07
                                 pstm,                                 !01254H08
                                 susp.orig^net^pro,                    !01254H09
                                 pstm^resp^low^fund^err^l,             !01254H0A
                                 sub^frmt^err^l );                     !01254H0B
            return;                                                    !01254H0C
            end                                                        !01254H0D
        else                                                           !01254H0E
            begin                                                      !01254H0F
            call pos^0210^deny( sem,                                   !01254H0G
                                msg^sym^source,                        !01254H0H
                                                                       !01254L09
                                pos^rvsl^frmt^err^l, pstm );           !01254L0A
                                                                       !01254L0B
                                                                       !01254L0C
                                                                       !01254L0D
                                                                       !01254K00
            call pstm^0200^deny( susp.prikey,                          !01254K01
                                                                       !01254K02
                                pstm,                                  !01254H0K
                                susp.orig^net^pro,                     !01254H0L
                                pstm^resp^frmt^err^l,                  !01254H0M
                                sub^frmt^err^l );                      !01254H0N
            return;                                                    !01254H0O
            end;                                                       !01254H0P
                                                                       !01254H0Q
                                                                       !01254H0R
                                                                       !01255H00
                                                                       !01255H01
                                                                       !01255H02
    pstm.exit^tim := userbuf.start^tim;                                !01264
                                                                       !01264K00
    set( pstm.re^entry^tim, juliantimestamp( ) );                      !01264K01
                                                                       !01264K02
                                                                       !01265K00
                                                                       !01265K01
                                                                       !01265e00
    !                                                                 !!01265e01
    ! Add the switch token                                            !!01265e02
    !                                                                 !!01265e03
    if base24^rel^g >= 5 then                                          !01265e04
        begin                                                          !01265e05
        util^add^swi^tkn( sem, pstm, pos^l, iss^l );                   !01265e06
                                                                       !01265000
        call util^add^swi^cmn^data^tkn( sem,                           !01265001
                                        pstm,                          !01265002
                                        pos^l );                       !01265003
                                                                       !01265004
        end;                                                           !01265e07
                                                                       !01265e08
                                                                       !01265*00
                                                                       !01265*01
                                                                       !01265*02
    call pos^util^send^pstm( pstm, susp.orig^net^pro );                !01266
    call util^ilf^add( pstm.iss^ichg^setl^dat, susp.prikey,            !01267
        $len( susp.prikey ), pos^l, sub^ok^l,                          !01268
        susp.orig^net^pro, pstm, sem );                                !01269
    end;                                                               !01270
?section pos^0220^advice                                               !01271
?page "                                        - pos^0220^advice"      !01272
                                                                       !01273
!#####################################################################!!01274
!#                                                                   #!!01275
!#                         POS^0220^ADVICE                           #!!01276
!#                                                                   #!!01277
!#    NARRATIVE : THIS PROCEDURE RECEIVES A FORCE POST FROM THE      #!!01278
!#       CO-NETWORK.  A BASE24 PSTM FORCE POST IS FORMATTED AND SENT #!!01279
!#       TO THE LOCAL AUTHORIZATION PROCESS.                         #!!01280
!#                                                                   #!!01281
!#    INPUT PARAMETERS:                                              #!!01282
!#       MSG          : MESSAGE WORD POINTER                         #!!01283
!#       SEM          : MESSAGE TEXT POINTER                         #!!01284
!#       PSTM         : BASE24 POS FORCE POST                        #!!01285
!#                                                                   #!!01286
!#    OUTPUT PARAMETERS:                                             #!!01287
!#                                                                   #!!01288
!#####################################################################!!01289
proc pos^0220^advice( msg, sem, pstm );                                !01290
int  .msg;                                                             !01291
int  .sem( sem^def );                                                  !01292
int  .pstm( pstm^def );                                                !01293
    begin                                                              !01294
                                                                       !01294K00
    wlform( mac^fail, "MAC Generation failure on POS \\\\ message " )  !01294K01
                                                                       !01294K02
                                                                       !01294K03
    struct .ilf( ilf^def ),                                            !01295
           .prikey( prikey^def );                                      !01296
                                                                       !01297
                                                                       !01297K00
                                                                       !01297S00
    string       log_auth_dest_resp := " ";                            !01297S01
                                                                       !01297S02
    string                                                             !01297K01
                .tkn^grp[ 0:3 ];                                       !01297K02
                                                                       !01297K03
                                                                       !01297S03
    int    .auth_dest[ 0:wordlen( $len( pstm.rte.pri ) ) - 1 ];        !01297S04
    int     fatal_flg := true;                                         !01297S05
    int     sta^x;                                                     !01297S06
                                                                       !01297S07
    int                                                                !01297K04
            error,                                                     !01297K05
            ilf^lgth,                                                  !01297K06
                                                                       !01297K07
                                                                       !01298K00
                                                                       !01298K01
            resp^cde := 0;                                             !01299
                                                                       !01300>00
    int     denied^flag := 0;                                          !01300>01
                                                                       !01300>02
                                                                       !01300S00
    call util^station^index( msg^sym^source, sta^x );                  !01300S01
                                                                       !01300S02
                                                                       !01301S00
    if  resp^cde := pos^frmt^sem^to^pstm^0220( sem, pstm, sta^x )then  !01301S01
                                                                       !01301S02
        begin                                                          !01302
        call util^send^reject( msg, resp^cde );                        !01303
        return;                                                        !01304
        end;                                                           !01305
                                                                       !01306
                                                                       !01306>00
                                                                       !C0130600
    if not pos^approved^d( sem ) and                                   !C0130601
       not pos^adjustment^d( sem ) then                                !C0130602
                                                                       !C0130603
                                                                       !C0130604
                                                                       !C0130605
        begin                                                          !01306>02
        !                                                             !!01306>03
        ! Set the denied flag so that the 0220 is not processed after !!01306>04
        ! the ack is sent.                                            !!01306>05
        !                                                             !!01306>06
        denied^flag := true;                                           !01306>07
        end;                                                           !01306>08
                                                                       !01306>09
    if  pct.options.ack^to^swi  then                                   !01307
        begin                                                          !01308
        !                                                             !!01309
        !  Format and send an acknowledgement to the Co-network       !!01310
        !                                                             !!01311
        if  psem.typ = auth^advice^d or psem.typ = auth^repeat^d then  !01312
            begin                                                      !01313
            movd ( psem.typ,             auth^acknowledge^d  );        !01314
            mov^ ( psem.pri^bit^map,     pos.p0130.pbit^map  );        !01315
            mov^ ( psem.secndry^bit^map, pos.p0130.sbit^map  );        !01316
                                                                       !01316K00
            movl ( tkn^grp, pos.p0130.tkn^grp, $occurs( tkn^grp ) );   !01316K01
                                                                       !01316K02
            end                                                        !01317
        else                                                           !01318
            begin                                                      !01319
            movd ( psem.typ,             tran^acknowledge^d  );        !01320
            mov^ ( psem.pri^bit^map,     pos.p0230.pbit^map  );        !01321
            mov^ ( psem.secndry^bit^map, pos.p0230.sbit^map  );        !01322
                                                                       !01322K00
            movl ( tkn^grp, pos.p0230.tkn^grp, $occurs( tkn^grp ) );   !01322K01
                                                                       !01322K02
            end;                                                       !01323
                                                                       !01324
        mov^ ( psem.xmit^dat^tim,    zeroes              );            !01325
        movd ( psem.responder,       switch^origin^d     );            !01326
        mov^ ( psem.resp^cde,        zeroes              );            !01327
                                                                       !01327K00
                                                                       !01327K01
        call pos^frmt^sem^to^sem^tkn( sem, tkn^grp );                  !01327K02
                                                                       !01327K03
        if ( error := pos^util^send^sem( sem, msg^sym^source ) ) and   !01327K04
             error <> true then                                        !01327K05
            begin                                                      !01327K06
            call logmessage^( 1046,, @mac^fail, net.myname,            !01327K07
                              2, @pos^prod^g, @psem.typ );             !01327K08
            return;                                                    !01327K09
            end;                                                       !01327K0A
                                                                       !01327K0B
                                                                       !01328K00
                                                                       !01328K01
        end;                                                           !01329
                                                                       !01330
    if  not util^ilf^dat( psem.cap^dat ) then                          !01331
        move ( pstm.acq^ichg^setl^dat, pct.ilf.cur.dat );              !01332
                                                                       !01333
                                                                       !01334>00
    if denied^flag or pos^inquiry^d( sem ) then                        !01334>01
                                                                       !01334>02
        !                                                             !!01335
        ! This force post is either an inquiry or denied              !!01336
        !                                                             !!01337
        return;                                                        !01338
                                                                       !01339
    call pos^frmt^sem^to^prikey( sem, prikey );                        !01340
    if  util^ilf^get( prikey, $len( prikey^def ), ilf, ilf^lgth ) then !01341
        if  ilf.pos.typ = pstm^force^post^d then                       !01342
            !                                                         !!01343
            !  This is a duplicate force post                         !!01344
            !                                                         !!01345
            return;                                                    !01346
                                                                       !01346S00
                                                                       !01346e00
    !                                                                 !!01346e01
    ! Add the switch token                                            !!01346e02
    !                                                                 !!01346e03
    if base24^rel^g >= 5 then                                          !01346e04
        begin                                                          !01346e05
        util^add^swi^tkn( sem, pstm, pos^l, acq^l );                   !01346e06
                                                                       !01346000
        call util^add^swi^cmn^data^tkn( sem,                           !01346001
                                        pstm,                          !01346002
                                        pos^l );                       !01346003
                                                                       !01346004
        end;                                                           !01346e07
                                                                       !01346e08
    if base24^rel^g >= 6 then                                          !01346S01
        begin                                                          !01346S02
        !                                                            ! !01346S03
        ! Release 6.0 and higher. Perform APCF routing               ! !01346S04
        !                                                            ! !01346S05
        if resp^cde := hiswutil_acq_txn_rte( pstm,                     !01346S06
                                             icf^name^g,               !01346S07
                                             apcfemt_seg_id_g,         !01346S08
                                             apcfemt_name_g,           !01346S09
                                             pos^pct.dest,             !01346S0A
                                             msg^sym^source,           !01346S0B
                                             apcf_emt_rec_g,           !01346S0C
                                             auth_dest,                !01346S0D
                                             fatal_flg,                !01346S0E
                                             log_auth_dest_resp ) then !01346S0F
            begin                                                      !01346S0G
            call util^ilf^add( pstm.acq^ichg^setl^dat,                 !01346S0H
                               prikey,                                 !01346S0I
                               $len( prikey^def ),                     !01346S0J
                               pos^l,                                  !01346S0K
                               sub^fail^pre^auth^l,                    !01346S0L
                               msg^sym^source,                         !01346S0M
                               pstm, sem );                            !01346S0N
            return;                                                    !01346S0O
            end;                                                       !01346S0P
                                                                       !01346S0Q
        call pos^util^send^pstm( pstm, auth_dest );                    !01346S0R
                                                                       !01346S0S
        if log_auth_dest_resp = "Y" then                               !01346S0T
            begin                                                      !01346S0U
            call pos^util^send^pstm( pstm, pos^pct.dest.name );        !01346S0V
                                                                       !01346S0W
            end;                                                       !01346S0X
                                                                       !01346S0Y
        end ! of bsee24^rel^g >= 6                                   ! !01346S0Z
    else                                                               !01346S10
        begin                                                          !01346S11
        call pos^util^send^pstm( pstm, pos^pct.dest.name );            !01346S12
                                                                       !01346S13
        end;                                                           !01346S14
                                                                       !01346S15
    call util^ilf^add( pstm.acq^ichg^setl^dat,                         !01346S16
                       prikey,                                         !01346S17
                       $len( prikey^def ),                             !01346S18
                       pos^l,                                          !01346S19
                       sub^ok^l,                                       !01346S1A
                       msg^sym^source,                                 !01346S1B
                       pstm,                                           !01346S1C
                       sem );                                          !01346S1D
                                                                       !01346S1E
                                                                       !01347S00
                                                                       !01347S01
                                                                       !01347S02
    end;                                                               !01351
?section pos^0230^ack                                                  !01352
?page "                                        - pos^0230^ack"         !01353
                                                                       !01354
!#####################################################################!!01355
!#                                                                   #!!01356
!#                       POS^0230^ACKNOWLEDGE                        #!!01357
!#                                                                   #!!01358
!#    NARRATIVE : THIS PROCEDURE RECEIVES AN ACKNOWLEDGEMENT FROM    #!!01359
!#       THE CO-NETWORK AND DELTES THE TRANSACTION FROM THE SAF.     #!!01360
!#                                                                   #!!01361
!#    INPUT PARAMETERS:                                              #!!01362
!#       MSG          : MESSAGE WORD POINTER                         #!!01363
!#       SEM          : POINTER TO BIC EXTERNAL MESSAGE              #!!01364
!#       PSTM         : POINTER TO BASE24 INTERNAL POS MESSAGE       #!!01365
!#                                                                   #!!01366
!#    OUTPUT PARAMETERS:                                             #!!01367
!#                                                                   #!!01368
!#####################################################################!!01369
proc pos^0230^ack( msg, sem, pstm );                                   !01370
int     .msg;                                                          !01371
struct  .sem( sem^def );                                               !01372
struct  .pstm( pstm^def );                                             !01373
    begin                                                              !01374
                                                                       !01374K00
    int                                                                !01374K01
            bit^map[ 0:7 ],                                            !01374K02
            trace^num,                                                 !01374K03
                                                                       !01374K04
                                                                       !01375K00
                                                                       !01375K01
           .userbuf( timer^userbuf^def );                              !01376
                                                                       !01377
    call ascii^integer^( psem.trace^num, trace^num );                  !01378
                                                                       !01379
    if  @userbuf := util^timer^find( time^saf^l, trace^num ) then      !01380
        begin                                                          !01381
        call util^timer^delete( time^saf^l, trace^num );               !01382
        !                                                             !!01383
        ! This advice is from the saf                                 !!01384
        !                                                             !!01385
                                                                       !01385M00
        pct.sta[ userbuf.nmm^prikey.sta^x ].t^o^ctr := 0;              !01385M01
        if  util^station^status( userbuf.nmm^prikey.sta^x, sta^up^l ) then
            call util^link^status( link^up^l, true );                  !01385M04
                                                                       !01385M05
                                                                       !01385K00
        call util^saf^delete( userbuf.nmm^prikey.sta^x );              !01385K01
                                                                       !01385K02
                                                                       !01386K00
                                                                       !01386K01
        end;                                                           !01387
                                                                       !01388
                                                                       !01388K00
    !!                                                                 !01388K01
    !reset the mac.out^cons^err^cnt if the request was mac'ed!         !01388K02
    !!                                                                 !01388K03
    if pct.mac.mac^typ = "1" then                                      !01388K04
        begin                                                          !01388K05
        if psem.typ = auth^advice^d then                               !01388K06
            begin                                                      !01388K07
            call hexchar^binaryx( pos.p0120.popt^map,                  !01388K08
                                  16, bit^map[ 0 ] );                  !01388K09
            call hexchar^binaryx( pos.p0120.sopt^map,                  !01388K0A
                                  16, bit^map[ 4 ] );                  !01388K0B
            end                                                        !01388K0C
        else                                                           !01388K0D
        if psem.typ = tran^advice^d then                               !01388K0E
            begin                                                      !01388K0F
            call hexchar^binaryx( pos.p0220.popt^map,                  !01388K0G
                                  16, bit^map[ 0 ] );                  !01388K0H
            call hexchar^binaryx( pos.p0220.sopt^map,                  !01388K0I
                                  16, bit^map[ 4 ] );                  !01388K0J
            end;                                                       !01388K0K
                                                                       !01388K0L
        if ( not testbit( bit^map, 0   )   and                         !01388K0M
                 testbit( bit^map, 63  ) ) or                          !01388K0N
           (     testbit( bit^map, 0   )   and                         !01388K0O
                 testbit( bit^map, 127 ) ) then                        !01388K0P
            begin                                                      !01388K0Q
            if pct.options.num^keys = "1" then                         !01388K0R
                set( pct.mac.in^cons^err^cnt,  0 )                     !01388K0S
            else                                                       !01388K0T
                set( pct.mac.out^cons^err^cnt, 0 );                    !01388K0U
            end;                                                       !01388K0V
        end;                                                           !01388K0W
                                                                       !01388K0X
                                                                       !01388K0Y
    end;                                                               !01389
?section pos^0402^request                                              !01390
?page "                                        - pos^0402^request"     !01391
!#####################################################################!!01392
!#                                                                   #!!01393
!#                          POS^0402^REQUEST                         #!!01394
!#                                                                   #!!01395
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS A CHARGEBACK      #!!01396
!#       ( ISSUER GENERATED REVERSAL ) TO THE AUTHORIZATION PROCESS  #!!01397
!#       AND SENDS AN ACKNOWLEDGMENT TO THE STATION.                 #!!01398
!#                                                                   #!!01399
!#    INPUT PARAMETERS :                                             #!!01400
!#       MSG           : WORD POINTER TO MESSAGE                     #!!01401
!#       SEM           : POINTER TO BIC EXTERNAL MESSAGE             #!!01402
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!01403
!#                                                                   #!!01404
!#    OUTPUT PARAMETERS:                                             #!!01405
!#                                                                   #!!01406
!#####################################################################!!01407
proc pos^0402^request( msg, sem, pstm );                               !01408
int  .msg;                                                             !01409
int  .sem(  sem^def  );                                                !01410
int  .pstm( pstm^def );                                                !01411
    begin                                                              !01412
                                                                       !01412K00
    wlform( mac^fail, "MAC Generation failure on POS \\\\ message " )  !01412K01
    wlform( ilf^err, "Transaction denied due to a previous error" ','  !01412K02
            " on the ILF - Correct the problem and warmboot " )        !01412K03
    wlform( saf^err, "Transaction denied due to a previous error" ','  !01412K04
            " on the SAF - Correct the problem and warmboot " )        !01412K05
                                                                       !01412K06
                                                                       !01412K07
                                                                       !01412K08
    struct  .ilf( ilf^def ),                                           !01413
            .prikey( prikey^def );                                     !01414
                                                                       !01415
                                                                       !01415K00
    int                                                                !01415K01
             error,                                                    !01415K02
             ilf^lgth,                                                 !01415K03
                                                                       !01415K04
                                                                       !01416K00
                                                                       !01416K01
             resp^cde;                                                 !01417
                                                                       !01417S00
                                                                       !01417W00
    int     .auth_dest[ 0:wordlen( $len( pstm.rte.pri ) ) - 1 ];       !01417W01
                                                                       !01417W02
                                                                       !01417W03
                                                                       !01417W04
    int      fatal_flg := true;                                        !01417S02
    int      log_auth_dest_resp := " ";                                !01417S03
    int      sta^x;                                                    !01417S04
                                                                       !01417S05
                                                                       !01418
    if  msg^poss^dup^( msg )  then                                     !01419
        !                                                             !!01420
        !                                                             !!01421
        !                                                             !!01422
        return;                                                        !01423
                                                                       !01424
    call pos^frmt^sem^to^prikey( sem, prikey );                        !01425
                                                                       !01426
    if  not util^ilf^dat( psem.cap^dat ) then                          !01427
        begin                                                          !01428
        move ( pstm.acq^ichg^setl^dat, pct.ilf.cur.dat );              !01429
        call pos^0200^deny( prikey, sem, msg^sym^source,               !01430
                                                                       !01430L00
                                                                       !01430L01
            pos^resp^cant^process^l, sub^fail^pre^auth^l, pstm );      !01430L02
                                                                       !01430L03
                                                                       !01430L04
                                                                       !01431L00
                                                                       !01431L01
        return;                                                        !01432
        end;                                                           !01433
                                                                       !01434
                                                                       !01434S00
    call util^station^index( msg^sym^source, sta^x );                  !01434S01
                                                                       !01434S02
                                                                       !01435S00
    if  resp^cde := pos^frmt^sem^to^pstm^0402( sem, pstm, sta^x )then  !01435S01
                                                                       !01435S02
        begin                                                          !01436
        call pos^0200^deny( prikey, sem, msg^sym^source,               !01437
            resp^cde, sub^frmt^err^l );                                !01438
        return;                                                        !01439
        end;                                                           !01440
                                                                       !01441
                                                                       !01441K00
    if pct.ilf.ferror and pct.ilf.ferror <> feeof then                 !01441K01
        begin                                                          !01441K02
        call pos^0200^deny( prikey, sem, msg^sym^source,               !01441K03
            resp^cde, sub^sys^err^l );                                 !01441K04
        call logmessage^( 1047,, @ilf^err, net.myname,                 !01441K05
                          2, @pos^prod^g );                            !01441K06
        return;                                                        !01441K07
        end;                                                           !01441K08
                                                                       !01441K09
    if pct.saf.ferror and pct.saf.ferror <> feeof then                 !01441K0A
                                                                       !01441K0B
                                                                       !01442K00
                                                                       !01442K01
                                                                       !01442K02
        begin                                                          !01444
        call pos^0200^deny( prikey, sem, msg^sym^source,               !01445
            resp^cde, sub^sys^err^l );                                 !01446
                                                                       !01446K00
        call logmessage^( 1048,, @saf^err, net.myname,                 !01446K01
                          2, @pos^prod^g );                            !01446K02
                                                                       !01446K03
        return;                                                        !01447
        end;                                                           !01448
                                                                       !01449
                                                                       !01450K00
                                                                       !01450K01
                                                                       !01450K02
    movd ( psem.responder,       switch^interface^origin^d );          !01452
    movd ( psem.typ,             rvsl^response^d           );          !01453
    mov^ ( psem.pri^bit^map,     pos.p0412.pbit^map        );          !01454
    mov^ ( psem.secndry^bit^map, pos.p0412.sbit^map        );          !01455
    mov^ ( psem.resp^cde,        zeroes                    );          !01456
                                                                       !01457
                                                                       !01457K00
    if ( error := pos^util^send^sem( sem, msg^sym^source ) ) and       !01457K01
         error <> true then                                            !01457K02
        begin                                                          !01457K03
        call logmessage^( 1049,, @mac^fail, net.myname,                !01457K04
                          2, @pos^prod^g, @psem.typ );                 !01457K05
        return;                                                        !01457K06
        end;                                                           !01457K07
                                                                       !01457K08
                                                                       !01457S00
                                                                       !01457e00
    !                                                                 !!01457e01
    ! Add the switch token                                            !!01457e02
    !                                                                 !!01457e03
    if base24^rel^g >= 5 then                                          !01457e04
        begin                                                          !01457e05
        util^add^swi^tkn( sem, pstm, pos^l, acq^l );                   !01457e06
                                                                       !01457000
        call util^add^swi^cmn^data^tkn( sem,                           !01457001
                                        pstm,                          !01457002
                                        pos^l );                       !01457003
                                                                       !01457004
        end;                                                           !01457e07
                                                                       !01457e08
    if base24^rel^g >= 6 then                                          !01457S01
        begin                                                          !01457S02
        !                                                            ! !01457S03
        ! Release 6.0 and higher. Perform APCF routing               ! !01457S04
        !                                                            ! !01457S05
        if resp^cde := hiswutil_acq_txn_rte( pstm,                     !01457S06
                                             icf^name^g,               !01457S07
                                             apcfemt_seg_id_g,         !01457S08
                                             apcfemt_name_g,           !01457S09
                                             pos^pct.dest,             !01457S0A
                                             msg^sym^source,           !01457S0B
                                             apcf_emt_rec_g,           !01457S0C
                                             auth_dest,                !01457S0D
                                             fatal_flg,                !01457S0E
                                             log_auth_dest_resp ) then !01457S0F
            begin                                                      !01457S0G
            call pos^0200^deny( prikey,                                !01457S0H
                                sem,                                   !01457S0I
                                msg^sym^source,                        !01457S0J
                                pos^resp^cant^process^l,               !01457S0K
                                sub^sys^err^l );                       !01457S0L
            return;                                                    !01457S0M
            end                                                        !01457S0N
        else                                                           !01457S0O
            begin                                                      !01457S0P
            call pos^util^send^pstm( pstm, auth_dest );                !01457S0Q
            end;                                                       !01457S0R
        end ! of base24^rel^g >= 6                                   ! !01457S0S
    else                                                               !01457S0T
        begin                                                          !01457S0U
        call pos^util^send^pstm( pstm, pos^pct.dest.name );            !01457S0V
        end;                                                           !01457S0W
                                                                       !01457S0X
                                                                       !01457S0Y
                                                                       !01457S0Z
                                                                       !01457S10
                                                                       !01457K0B
                                                                       !01458K00
                                                                       !01458K01
                                                                       !01458K02
    if  util^ilf^get( prikey, $len( prikey ), ilf, ilf^lgth ) then     !01460
        if  ilf.pos.typ = rvsl^request^d  or                           !01461
            ilf.pos.typ = rvsl^response^d then                         !01462
                                                                       !01463
            ! Duplicate Issuer Reversal                               !!01464
                                                                       !01465
            return;                                                    !01466
                                                                       !01467
    call util^ilf^add( pstm.acq^ichg^setl^dat, prikey,                 !01468
        $len( prikey ), pos^l, sub^ok^l,, pstm, sem );                 !01469
                                                                       !01470
    end;                                                               !01471
?section pos^0412^response                                             !01472
?page "                                        - pos^0412^response"    !01473
!#####################################################################!!01474
!#                                                                   #!!01475
!#                     POS^0412^RESPONSE                             #!!01476
!#                                                                   #!!01477
!#    NARRATIVE: THIS PROCEDURE UPDATES THE CHARGEBACK ON THE ILF    #!!01478
!#       FILE TO REFLECT THE FACT THAT THE INTERFACE RECEIVED A      #!!01479
!#       0412 CHARGEBACK RESPONSE.  IF THE ORIGINAL CHARGEBACK       #!!01480
!#       COULD NOT BE FOUND ON THE ILF ADD A RECORD AS AN EXCEPTION  #!!01481
!#       CONDITION.                                                  #!!01482
!#                                                                   #!!01483
!#    INPUT PARAMETERS:                                              #!!01484
!#       MSG           : WORD POINTER TO MESSAGE                     #!!01485
!#       PSTM          : POINTER TO INTERNAL MESSAGE.                #!!01486
!#       SEM           : POINTER TO EXTERNAL MESSAGE.                #!!01487
!#                                                                   #!!01488
!#    OUTPUT PARAMETERS:                                             #!!01489
!#                                                                   #!!01490
!#####################################################################!!01491
proc pos^0412^response( msg, sem, pstm );                              !01492
int  .msg;                                                             !01493
int  .sem(  sem^def );                                                 !01494
int  .pstm( pstm^def );                                                !01495
    begin                                                              !01496
    struct .ilf( ilf^def ),                                            !01497
           .prikey( prikey^def );                                      !01498
                                                                       !01499
                                                                       !01499K00
    int                                                                !01499K01
            bit^map[ 0:7 ],                                            !01499K02
            fnum,                                                      !01499K03
                                                                       !01499K04
                                                                       !01500K00
                                                                       !01500K01
            ilf^lgth,                                                  !01501
            trace^num,                                                 !01502
           .userbuf( timer^userbuf^def );                              !01503
                                                                       !01504
    call ascii^integer^( psem.trace^num, trace^num );                  !01505
                                                                       !01506
    if  @userbuf := util^timer^find( time^saf^l, trace^num )  then     !01507
        begin                                                          !01508
        call util^timer^delete( time^saf^l, trace^num );               !01509
        !                                                             !!01510
        ! The 0402 chargeback was on the SAF                          !!01511
        !                                                             !!01512
                                                                       !01512K00
        call util^saf^delete( userbuf.nmm^prikey.sta^x );              !01512K01
                                                                       !01512K02
                                                                       !01513K00
                                                                       !01513K01
        end;                                                           !01514
                                                                       !01515
    call pos^frmt^sem^to^prikey( sem, prikey );                        !01516
    if  ( fnum := util^ilf^get( prikey, $len( prikey^def ),            !01517
            ilf, ilf^lgth, pstm ) ) then                               !01518
        begin                                                          !01519
                                                                       !01520K00
        call util^ilf^updt( fnum, ilf, ilf^lgth, pos^l,                !01520K01
                            sub^ok^l,, pstm, sem );                    !01520K02
                                                                       !01520K03
        end                                                            !01521
    else                                                               !01522
        call util^ilf^add( pstm.iss^ichg^setl^dat, prikey,             !01523
            $len( prikey^def ), pos^l, sub^rvsl^not^found^l,,          !01524
            pstm, sem );                                               !01525
                                                                       !01525K00
                                                                       !01525K01
    !!                                                                 !01525K02
    !reset the mac.out^cons^err^cnt if the request was mac'ed!         !01525K03
    !!                                                                 !01525K04
    if pct.mac.mac^typ = "1" then                                      !01525K05
        begin                                                          !01525K06
        call hexchar^binaryx( pos.p0402.popt^map, 16, bit^map[ 0 ] );  !01525K07
        call hexchar^binaryx( pos.p0402.sopt^map, 16, bit^map[ 4 ] );  !01525K08
                                                                       !01525K09
        if ( not testbit( bit^map, 0   )   and                         !01525K0A
                 testbit( bit^map, 63  ) ) or                          !01525K0B
           (     testbit( bit^map, 0   )   and                         !01525K0C
                 testbit( bit^map, 127 ) ) then                        !01525K0D
            begin                                                      !01525K0E
            if pct.options.num^keys = "1" then                         !01525K0F
                set( pct.mac.in^cons^err^cnt,  0 )                     !01525K0G
            else                                                       !01525K0H
                set( pct.mac.out^cons^err^cnt, 0 );                    !01525K0I
            end;                                                       !01525K0J
        end;                                                           !01525K0K
                                                                       !01525K0L
                                                                       !01525K0M
    end;                                                               !01526
?section pos^0420^reversal                                             !01527
?page "                                        - pos^0420^reversal"    !01528
!#####################################################################!!01529
!#                                                                   #!!01530
!#                       POS^0420^REVERSAL                           #!!01531
!#                                                                   #!!01532
!#    NARRATIVE : THIS PROCEDURE RECEIVES A REVERSAL FROM A STATION, #!!01533
!#       FORMATS A PSTM REVERSAL AND SENDS THE MESSAGE TO THE        #!!01534
!#       AUTHORIZATION PROCESS.                                      #!!01535
!#                                                                   #!!01536
!#    INPUT PARAMETERS:                                              #!!01537
!#       MSG          :      MESSAGE WORD POINTER                    #!!01538
!#       SEM          :      STANDARD EXTERNAL MESSAGE               #!!01539
!#       PSTM         :      POS STANDARD INTERNAL MESSAGE           #!!01540
!#                                                                   #!!01541
!#    OUTPUT PARAMETERS:                                             #!!01542
!#                                                                   #!!01543
!#####################################################################!!01544
proc pos^0420^reversal( msg, sem, pstm );                              !01545
int  .msg;                                                             !01546
int  .sem( sem^def );                                                  !01547
int  .pstm( pstm^def );                                                !01548
    begin                                                              !01549
                                                                       !01549K00
    wlform( mac^fail, "MAC Generation failure on POS \\\\ message " )  !01549K01
                                                                       !01549K02
                                                                       !01549K03
    struct .ilf( ilf^def ),                                            !01550
                                                                       !01550I00
           .prikey( prikey^def ),                                      !01550I01
           .susp( susp^bici^def );                                     !01550I02
                                                                       !01550I03
                                                                       !01550K00
                                                                       !01550S00
    string       log_auth_dest_flg := " ";                             !01550S01
                                                                       !01550S02
    string                                                             !01550K01
                .tkn^grp[ 0:3 ];                                       !01550K02
                                                                       !01550K03
    int                                                                !01550K04
            error,                                                     !01550K05
            fnum,                                                      !01550K06
                                                                       !01550K07
                                                                       !01550K08
                                                                       !01550K09
                                                                       !01550K0A
            ilf^lgth,                                                  !01553I01
            .timer( timer^def );                                       !01553I02
                                                                       !01553S00
                                                                       !01553W00
    int     .auth_dest[ 0:wordlen( $len( pstm.rte.pri ) ) - 1 ];       !01553W01
                                                                       !01553W02
                                                                       !01553W03
                                                                       !01553W04
    int      fatal_flg := true;                                        !01553S02
    int      rcode;                                                    !01553S03
                                                                       !01553S04
!*===================================================================*!
!* BEGIN RPQ #27 - Handle Transaction with IVA                       *!
!---------------------------------------------------------------------!
    int     .user^data( user^data^d^def ),
             userdata^ofst;
    string  .priv^field( privfield^def );
    string  .pstm^s := @pstm '<<' 1;
    int      len^iva^fld,
             tot^userdata^len;
!---------------------------------------------------------------------!
!* END   RPQ #27 - Handle Transactions with IVA                      *!
!*===================================================================*!
                                                                       !01553I03
!*********************************************************************
! BEGIN RPQ #T0001 - RECUPERA TRACK2                2014-04-23
!--------------------------------------------------------------------*
    int      counter,
             length;
!--------------------------------------------------------------------*
! END   RPQ #T0001 - RECUPERA TRACK2               2014-04-23
!*********************************************************************
                                                                       !01554I00
!*********************************************************************!
! BEGIN RPQ #ID001 - Manejo Especial Campo P42                        !
!*********************************************************************!
   int     .rpq^p42^tkn( rpq^p42^tkn^def ),
            rpq^p42^tkn^lgth := 0,
            tkn^ofst^g := 0;

   string   tkn^id[0:1];
!*********************************************************************!
! END   RPQ #ID001 - Manejo Especial Campo P42                        !
!*********************************************************************!
                                                                       !01554I01
                                                                       !01554K00
!#####################################################################!!01554K01
!#                                                                   #!!01554K02
!# This subproc formats and send the ack to the co-network           #!!01554K03
!#                                                                   #!!01554K04
!#####################################################################!!01554K05
int subproc send^ack;                                                  !01554K06
    begin                                                              !01554K07
    movd ( psem.responder,       switch^interface^origin^d );          !01554K08
    movd ( psem.typ,             rvsl^acknowledge^d        );          !01554K09
    mov^ ( psem.pri^bit^map,     pos.p0430.pbit^map        );          !01554K0A
    mov^ ( psem.secndry^bit^map, pos.p0430.sbit^map        );          !01554K0B
    mov^ ( psem.xmit^dat^tim,    zeroes                    );          !01554K0C
    mov^ ( psem.resp^cde,        zeroes                    );          !01554K0D
    movl ( tkn^grp, pos.p0430.tkn^grp, $occurs( tkn^grp ) );           !01554K0E
                                                                       !01554K0F
    call pos^frmt^sem^to^sem^tkn( sem, tkn^grp );                      !01554K0G
                                                                       !01554K0H
    if ( error := pos^util^send^sem( sem, msg^sym^source ) ) and       !01554K0I
         error <> true then                                            !01554K0J
        begin                                                          !01554K0K
        call logmessage^( 1051,, @mac^fail, net.myname,                !01554K0L
                          2, @pos^prod^g, @psem.typ );                 !01554K0M
        return false;                                                  !01554K0N
        end;                                                           !01554K0O
                                                                       !01554L00
    return true;                                                       !01554L01
                                                                       !01554L02
    end;                                                               !01554K0P
                                                                       !01554K0Q
!#####################################################################!!01554K0R
!# start of main code                                                #!!01554K0S
!#####################################################################!!01554K0T
                                                                       !01554K0U
                                                                       !01555K00
                                                                       !01555K01
    if  msg^poss^dup^( msg ) then                                      !01556
                                                                       !01557
        ! Process Duplicates from the nucleus                         !!01558
                                                                       !01559
        begin                                                          !01560
        if  pos^util^check^dup^rvsl( sem ) then                        !01561
            return;                                                    !01562
        end;                                                           !01563
                                                                       !01564
                                                                       !01564e00
                                                                       !01564k00
                                                                       !01564k01
                                                                       !01564k02
                                                                       !01564e08
    call pos^frmt^sem^to^prikey( sem, prikey );                        !01565
                                                                       !01565K00
                                                                       !01565K01
    move( susp.prikey, prikey );                                       !01565K02
                                                                       !01565K03
    if ( pct.options.proto^typ = "03" ) and                            !01565K04
         util^suspend^tran^delete( susp, $len( susp^bici^def ),        !01565K05
                                   msg, time^inbound^rqst^l ) then     !01565K06
        begin                                                          !01565K07
        if not pos^frmt^sem^to^pstm^0420( sem, pstm ) or               !01565K08
           not pos^frmt^sem^to^pstm^tran( sem, pstm ) or               !01565K09
           not pos^frmt^sem^to^pstm^acct( sem, pstm ) then             !01565K0A
            begin                                                      !01565K0B
            call util^send^reject( msg, reject^frmt^err^l );           !01565K0C
            return;                                                    !01565K0D
            end;                                                       !01565K0E
                                                                       !01565K0F
        call util^ilf^add( pct.ilf.cur.dat, susp.prikey,               !01565K0G
            $len( prikey^def ), pos^l,,, pstm, sem );                  !01565K0H
        end                                                            !01565K0I
    else                                                               !01565K0J
                                                                       !01565K0K
                                                                       !01565K0L
                                                                       !01565K0M
                                                                       !01565K0N
                                                                       !M0156500
    if not ( fnum := util^ilf^get( prikey, $len( prikey^def ), ilf,    !M0156501
                                    ilf^lgth, pstm) ) then             !M0156502
        begin                                                          !M0156503
        !                                                             !!M0156504
        ! if first read fails, use info from orig^data and try again  !!M0156505
        !                                                             !!M0156506
        if ( ssem.b24^orig.orig^tran^dat <>                            !M0156507
             [ $len( ssem.b24^orig.orig^tran^dat ) * [" "] ] and       !M0156508
             ssem.b24^orig.orig^tran^dat <>                            !M0156509
             [ $len( ssem.b24^orig.orig^tran^dat ) * ["0"] ] and       !M015650A
             ssem.b24^orig.orig^tran^tim <>                            !M015650B
             [ $len( ssem.b24^orig.orig^tran^tim ) * [" "] ] ) then    !M015650C
            begin                                                      !M015650D
            move ( prikey.tran^dat, ssem.b24^orig.orig^tran^dat );     !M015650E
            call ascii^double( ssem.b24^orig.orig^tran^tim, 4,         !M015650F
                               prikey.tran^tim );                      !M015650G
            fnum := util^ilf^get( prikey, $len( prikey^def ), ilf,     !M015650H
                                    ilf^lgth, pstm );                  !M015650I
            end;                                                       !M015650J
        end;                                                           !M015650K
                                                                       !M015650L
    if fnum then                                                       !M015650M
        begin                                                          !M015650N
                                                                       !M015650O
 !*********************************************************************!
 ! BEGIN RPQ #ID001 - Manejo Especial Campo P42                        !
 !*********************************************************************!
          tkn^id ':=' rpq^p42^tkn^id^d;
          if hiswtkn^get^tkn( pstm,
                              tkn^id,
                               @rpq^p42^tkn,
                               rpq^p42^tkn^lgth ) then
             begin
              rpq^p42^tkn^lgth := 1;
             end;
 !*********************************************************************!
 ! END   RPQ #ID001 - Manejo Especial Campo P42                        !
 !*********************************************************************!
                                                                       !M0156600
                                                                       !M0156601
                                                                       !M0156602

!*********************************************************************!
!* BEGIN RPQ #27 - Handle Transactions with IVA                      *!
!---------------------------------------------------------------------!
    if ascii^integer^( psem.add^data^natl.len, len^iva^fld ) and
       len^iva^fld > 0 then
       begin
        pstm.data^flag := "1" ;

        tot^userdata^len := $len( priv^field );
        tot^userdata^len := tot^userdata^len + 1;

        @user^data := @pstm.srvcs[ $min( $occurs( pstm.srvcs ),
                                   pstm.num^services ) ]  '>>' 1;
        !
        ! priv^field is being mapped to the second byte, because
        ! the first byte is used as term^type in the HPDHS.
        ! The priv^fields needed start after the term^type.
        !
        @priv^field := @user^data.info.byte[1];

        priv^field.additional^amt.byte[0]    ':=' "000000000000";

        priv^field.adj^sale^orig^amt.byte[0] ':=' "000000000000";
        priv^field.product^code[0].byte[0]   ':=' "00";
        priv^field.product^code[1].byte[0]   ':=' "00";
        priv^field.product^code[2].byte[0]   ':=' "00";
        priv^field.product^code[3].byte[0]   ':=' "00";
        priv^field.reference^num.byte[0]     ':=' "000000";
        priv^field.guar^late.arrival^date.byte[0] ':=' "000000";
        priv^field.guar^late.depart^date.byte[0]  ':=' "000000";
        priv^field.guar^late.room^rate.byte[0]    ':=' "000000000000";
        priv^field.tip^flag  ':=' "0";
        priv^field.void^flag ':=' "0";

! BEGIN RPQ #27C - Ajustes por envio de campo IVA con 37 len
        priv^field.rpq^priv^data.byte[0] ':='
                         [ $len( priv^field.rpq^priv^data ) * [" "]];
! END   RPQ #27C - Ajustes por envio de campo IVA con 37 len

        priv^field.rpq^priv^data.byte[0] ':='
                   psem.add^data^natl.data for len^iva^fld;

        userdata^ofst := $offset( pstm.srvcs[0] ) +
             $min( ( $len( pstm.srvcs[0] ) * pstm.num^services ),
                   ( $len( pstm.srvcs[0] ) * $occurs( pstm.srvcs )));

        pstm^s[ userdata^ofst ] ':='
            tot^userdata^len for 1 & " " &
                             priv^field for $len( priv^field );
       end;
!---------------------------------------------------------------------!
!* END   RPQ #27 - Handle Transactions with IVA                      *!
!*********************************************************************!
                                                                       !01568L00
        if ( pstm^approved^d( pstm ) and not pstm^inquiry^d( pstm ) and
             ( ilf.pos.typ <> pstm^request^d ) and                     !01568L03
             ( ilf.pos.typ <> pstm^rvsl^advice^d ) ) or                !01568L04
           ( pstm^approved^d( pstm ) and                               !01568L05
             ( reverse^bal^inq^g and pstm^inquiry^d( pstm ) ) ) then   !01568L06
                                                                       !01568L07
                                                                       !01569L00
                                                                       !01569L01
                                                                       !01569L02
            begin                                                      !01571
            if  not pos^frmt^sem^to^pstm^0420( sem, pstm ) then        !01572
                begin                                                  !01573
                call util^send^reject( msg, reject^frmt^err^l );       !01574
                return;                                                !01575
                end;                                                   !01576
                                                                       !01577
                                                                       !01577M00
            call util^ilf^updt( fnum, ilf, ilf^lgth,                   !01577M01
                                pos^l,,, pstm, sem );                  !01577M02
                                                                       !01577M03
                                                                       !01577K00
            if pct.options.ack^to^swi then                             !01577K01
                begin                                                  !01577K02
                if not send^ack then                                   !01577K03
                    return;                                            !01577K04
                end;                                                   !01577K05
                                                                       !01577K06

!*********************************************************************
! BEGIN RPQ #T0001 - RECUPERA TRACK2              2014-04-23
!*-------------------------------------------------------------------*
            counter := -1;
            while ( counter := counter + 1 ) < length and
                    sem.isopsem.track2.data.byte[ counter ] <> " " do;
            pstm.tran.track2 ':=' start^sent^d &
                                  sem.isopsem.track2.data for counter &
                                  end^sent^d;

            PSTM.TRAN.TRACK2.BYTE[0] ':=' ";";
!*********************************************************************
! BEGIN RPQ #COF - 
!*********************************************************************
--          if psem.entry^mde = "01" then
            if psem.entry^mde = "01" or
               psem.entry^mde = "10"  then
!*********************************************************************
! END   RPQ #COF - 
!*********************************************************************
               BEGIN
                 PSTM.TRAN.TRACK2.BYTE[0] ':=' "M";
               END;
!*-------------------------------------------------------------------*
! END   RPQ #T0001 - RECUPERA TRACK2           2014-04-23
!*********************************************************************
                                                                       !01577K07
                                                                       !01577S00
            if base24^rel^g >= 6 then                                  !01577S01
                begin                                                  !01577S02
                if rcode := hiswsem_rvsl_txn_rte_pos(                  !01577S03
                                             pstm,                     !01577S04
                                             pos^pct.acq^txn^prfl,     !01577S05
                                             msg^sym^source,           !01577S06
                                             pos^pct.dest,             !01577S07
                                             apcfemt_seg_id_g,         !01577S08
                                             pos^pct.num^srv,          !01577S09
                                             icfe_name_g,              !01577S0A
                                                                       !01577W00
                                             auth_dest,                !01577W01
                                             log_auth_dest_flg,        !01577W02
                                             fatal_flg,                !01577W03
                                             apcfemt_name_g ) then     !01577W04
                                                                       !01577W05
                                                                       !01577W06
                                                                       !01577W07
                                                                       !01577W08
                    begin                                              !01577S0F
                    call util^ilf^add( pct.ilf.cur.dat,                !01577S0G
                                       prikey,                         !01577S0H
                                       $len( prikey^def ),             !01577S0I
                                       pos^l,                          !01577S0J
                                       sub^fail^pre^auth^l,            !01577S0K
                                       msg^sym^source,                 !01577S0L
                                       pstm,                           !01577S0M
                                       sem );                          !01577S0N
                    return;                                            !01577S0O
                    end                                                !01577S0P
                else                                                   !01577S0Q
                    begin                                              !01577S0R
                    call pos^util^send^pstm( pstm, auth_dest );        !01577S0S
                    if log_auth_dest_flg = "Y" then                    !01577S0T
                        begin                                          !01577S0U
                        call pos^util^send^pstm( pstm,                 !01577S0V
                                                 pos^pct.dest.name );  !01577S0W
                        end;                                           !01577S0X
                    return;                                            !01577S0Y
                    end; ! of else rcode                             ! !01577S0Z
                                                                       !01577S10
                end                                                    !01577S11
            else                                                       !01577S12
                begin                                                  !01577S13
                !                                                    ! !01577S14
                ! No APCF routing for pre-release 6.0.               ! !01577S15
                !                                                    ! !01577S16
                call pos^util^send^pstm( pstm, pos^pct.dest.name );    !01577S17
                                                                       !01577S18
                return;                                                !01577S19
                                                                       !01577S1A
                end;                                                   !01577S1B
                                                                       !01577S1C
                                                                       !01578S00
                                                                       !01578S01
                                                                       !01578S02
                                                                       !01578M03
                                                                       !01578M04
                                                                       !01579M00
                                                                       !01579M01
                                                                       !01579M02
            end;                                                       !01580
        end                                                            !01581
    else                                                               !01582
        begin                                                          !01583
        if  not pos^frmt^sem^to^pstm^0420( sem, pstm ) or              !01584
            not pos^frmt^sem^to^pstm^tran( sem, pstm ) or              !01585
            not pos^frmt^sem^to^pstm^acct( sem, pstm ) then            !01586
            begin                                                      !01587
            call util^send^reject( msg, reject^frmt^err^l );           !01588
            return;                                                    !01589
            end;                                                       !01590
                                                                       !01591
        call util^ilf^add( pct.ilf.cur.dat, prikey, $len( prikey^def ),
            pos^l, sub^rvsl^not^found^l,, pstm, sem );                 !01594
        end;                                                           !01595
                                                                       !01596
                                                                       !01596K00
    if pct.options.ack^to^swi then                                     !01596K01
        call send^ack;                                                 !01596K02
                                                                       !01596K03
                                                                       !01596K04
                                                                       !01597K00
                                                                       !01597K01
                                                                       !01597K02
    end;                                                               !01610
?section pos^0430^ack                                                  !01611
?page "                                        - pos^0430^ack"         !01612
                                                                       !01613
!#####################################################################!!01614
!#                                                                   #!!01615
!#                       POS^0430^ACKNOWLEDGE                        #!!01616
!#                                                                   #!!01617
!#    NARRATIVE : THIS PROCEDURE PROCESSES A REVERSAL ACK FROM THE   #!!01618
!#       CO-NETWORK AND DELETES THE TRANSACTION FROM THE SAF.        #!!01619
!#                                                                   #!!01620
!#    INPUT PARAMETERS:                                              #!!01621
!#       MSG          :      MESSAGE WORD POINTER                    #!!01622
!#       SEM          :      STANDARD EXTERNAL MESSAGE               #!!01623
!#       PSTM         :      POS STANDARD INTERNAL MESSAGE           #!!01624
!#                                                                   #!!01625
!#    OUTPUT PARAMETERS:                                             #!!01626
!#                                                                   #!!01627
!#####################################################################!!01628
proc pos^0430^ack( msg, sem, pstm );                                   !01629
int .msg;                                                              !01630
int .sem( sem^def );                                                   !01631
int .pstm( pstm^def );                                                 !01632
    begin                                                              !01633
                                                                       !01633K00
    int                                                                !01633K01
            bit^map[ 0:7 ],                                            !01633K02
            trace^num,                                                 !01633K03
                                                                       !01633K04
                                                                       !01634K00
                                                                       !01634K01
           .userbuf( timer^userbuf^def );                              !01635
                                                                       !01636
    call ascii^integer^( psem.trace^num, trace^num );                  !01637
                                                                       !01638
    if  @userbuf := util^timer^find( time^saf^l, trace^num ) then      !01639
        begin                                                          !01640
        call util^timer^delete( time^saf^l, trace^num );               !01641
        !                                                             !!01642
        ! This advice is from the saf                                 !!01643
        !                                                             !!01644
                                                                       !01644M00
        pct.sta[ userbuf.nmm^prikey.sta^x ].t^o^ctr := 0;              !01644M01
        if  util^station^status( userbuf.nmm^prikey.sta^x, sta^up^l ) then
            call util^link^status( link^up^l, true );                  !01644M04
                                                                       !01644M05
                                                                       !01644K00
        call util^saf^delete( userbuf.nmm^prikey.sta^x );              !01644K01
                                                                       !01644K02
                                                                       !01645K00
                                                                       !01645K01
        end;                                                           !01646
                                                                       !01646K00
                                                                       !01646K01
    !!                                                                 !01646K02
    !reset the mac.out^cons^err^cnt if the request was mac'ed!         !01646K03
    !!                                                                 !01646K04
    if pct.mac.mac^typ = "1" then                                      !01646K05
        begin                                                          !01646K06
        call hexchar^binaryx( pos.p0420.popt^map, 16, bit^map[ 0 ] );  !01646K07
        call hexchar^binaryx( pos.p0420.sopt^map, 16, bit^map[ 4 ] );  !01646K08
                                                                       !01646K09
        if ( not testbit( bit^map, 0   )   and                         !01646K0A
                 testbit( bit^map, 63  ) ) or                          !01646K0B
           (     testbit( bit^map, 0   )   and                         !01646K0C
                 testbit( bit^map, 127 ) ) then                        !01646K0D
            begin                                                      !01646K0E
            if pct.options.num^keys = "1" then                         !01646K0F
                set( pct.mac.in^cons^err^cnt,  0 )                     !01646K0G
            else                                                       !01646K0H
                set( pct.mac.out^cons^err^cnt, 0 );                    !01646K0I
            end;                                                       !01646K0J
        end;                                                           !01646K0K
                                                                       !01646K0L
                                                                       !01646K0M
    end;                                                               !01647
?section pos^cmd^performance                                           !01648
?page "                                        - pos^cmd^performance"  !01649
!#####################################################################!!01650
!#                                                                   #!!01651
!#                        POS^CMD^PERFORMANCE                        #!!01652
!#                                                                   #!!01653
!#    NARRATIVE : THIS PROCEDURE PROCESSES THE PERFORMANCE COMMAND   #!!01654
                                                                       !01655K00
!#       BY DISPLAYING PERTINENT POS STATISTICS ON THE LOG TERMINAL  #!
                                                                       !01655K03
!#       AS REFLECTED IN THE PERFORMANCE PORTION OF THE PCT TABLE.   #!!01656
!#                                                                   #!!01657
!#    INPUT PARAMETERS:                                              #!!01658
!#                                                                   #!!01659
!#    OUTPUT PARAMETERS:                                             #!!01660
!#                                                                   #!!01661
!#####################################################################!!01662
proc pos^cmd^performance;                                              !01663
                                                                       !01664
     begin                                                             !01665
     wlform( hdr, "*** POS Performance Statistics Summary ***" )       !01666
     wlform( out, "Minutes in Period: #  Outbound Request Limit: #" )  !01667
     wlform( in,  "Minutes in Period: #  Inbound  Request Limit: #" )  !01668
     wlform( hdr1,"         Requests - Timeouts - Percent - Average" ) !01669
     wlform( perf,"Period #   $$$$       $$$$       ###%     ##.##" )  !01670
                                                                       !01671
     int(32) average,                                                  !01672
                                                                       !01672K00
             ttl^rqsts,                                                !01672K01
                                                                       !01672K02
             ttl^tim;                                                  !01673
                                                                       !01674
     int     i,                                                        !01675
             percent;                                                  !01676
                                                                       !01677
     call logmessage^( 1050,, @hdr, net.myname, 0, @pos^prod^g );      !01678
     call logmessage^( 1055,, @out, net.myname, 0, @pos^prod^g,        !01679
         $int( pct.timers.perf / 6000d ),                              !01680
         $int( pos^pct.timers.outbound / 100d ) );                     !01681
     call logmessage^( 1060,, @hdr1, net.myname, 0, @pos^prod^g );     !01682
                                                                       !01683
     for i := 0 to $occurs( pos^pct.perform ) - 1 do                   !01684
         begin                                                         !01685
                                                                       !01685K00
         ttl^rqsts := pos^pct.perform[ i ].outbound.count +            !01685K01
                      pos^pct.perform[ i ].outbound.timeouts;          !01685K02
                                                                       !01685K03
         if ttl^rqsts > 0d then                                        !01685K04
                                                                       !01685K05
                                                                       !01686K00
                                                                       !01686K01
             begin                                                     !01687
             percent := $int(                                          !01688
                 pos^pct.perform[ i ].outbound.timeouts * 100d /       !01689
                                                                       !01689K00
                                      ttl^rqsts );                     !01689K01
                                                                       !01689K02
                                                                       !01690K00
                                                                       !01690K01
                                                                       !01691
             ttl^tim :=                                                !01692
                 $dbl( pos^pct.perform[ i ].outbound.ttl^tim / 10000f );
                                                                       !01692K00
             average := ttl^tim /                                      !01692K01
                    $max( 1d, pos^pct.perform[ i ].outbound.count );   !01692K02
                                                                       !01692K03
                                                                       !01695K00
                                                                       !01695K01
             end                                                       !01696
         else                                                          !01697
             begin                                                     !01698
             percent := 0;                                             !01699
             average := 0d;                                            !01700
             end;                                                      !01701
                                                                       !01702
         call logmessage^( 1065,, @perf, net.myname, 0, @pos^prod^g,   !01703
                                                                       !01703K00
             i, @ttl^rqsts,                                            !01703K01
                                                                       !01703K02
                                                                       !01704K00
                                                                       !01704K01
             @pos^pct.perform[ i ].outbound.timeouts, percent,         !01705
             average '/' 100, average '\' 100 );                       !01706
         end;                                                          !01707
                                                                       !01708
     call logmessage^( 1070,, @in, net.myname, 0, @pos^prod^g,         !01709
         $int( pct.timers.perf / 6000d ),                              !01710
         $int( pos^pct.timers.inbound / 100d ) );                      !01711
     call logmessage^( 1075,, @hdr1, net.myname, 0, @pos^prod^g );     !01712
                                                                       !01713
     for i := 0 to $occurs( pos^pct.perform ) - 1 do                   !01714
         begin                                                         !01715
                                                                       !01715K00
         ttl^rqsts := pos^pct.perform[ i ].inbound.count +             !01715K01
                      pos^pct.perform[ i ].inbound.timeouts;           !01715K02
                                                                       !01715K03
         if ttl^rqsts > 0d then                                        !01715K04
                                                                       !01715K05
                                                                       !01716K00
                                                                       !01716K01
             begin                                                     !01717
             percent := $int(                                          !01718
                 pos^pct.perform[ i ].inbound.timeouts * 100d /        !01719
                                                                       !01719K00
                                      ttl^rqsts );                     !01719K01
                                                                       !01719K02
                                                                       !01720K00
                                                                       !01720K01
             ttl^tim :=                                                !01721
                                                                       !01721K00
                 $dbl( pos^pct.perform[ i ].inbound.ttl^tim / 10000f );
             average := ttl^tim /                                      !01721K03
                    $max( 1d, pos^pct.perform[ i ].inbound.count );    !01721K04
                                                                       !01721K05
                                                                       !01722K00
                                                                       !01722K01
                                                                       !01722K02
             end                                                       !01724
         else                                                          !01725
             begin                                                     !01726
             percent := 0;                                             !01727
             average := 0d;                                            !01728
             end;                                                      !01729
                                                                       !01730
                                                                       !01730K00
         call logmessage^( 1080,, @perf, net.myname, 0, @pos^prod^g,   !01730K01
             i, @ttl^rqsts,                                            !01730K02
                                                                       !01730K03
                                                                       !01733K00
                                                                       !01733K01
             @pos^pct.perform[ i ].inbound.timeouts, percent,          !01734
             average '/' 100, average '\' 100 );                       !01735
         end;                                                          !01736
     end;                                                              !01737
                                                                       !01737K00
                                                                       !01737K01
?section pos^cmd^warmboot^ret^globals                                  !01737K02
?page "                            - pos^cmd^warmboot^ret^globals"     !01737K03
!#####################################################################!!01737K04
!#                                                                   #!!01737K05
!#                POS^CMD^WARMBOOT^RET^GLOBALS                       #!!01737K06
!#                                                                   #!!01737K07
!#   THIS PROC MOVES THE TEMPORARY POS PCT STORAGE STRUCTURE         #!!01737K08
!#   TO THE POS PCT STRUCTURE.                                       #!!01737K09
!#                                                                   #!!01737K0A
!#    INPUT PARAMETERS:                                              #!!01737K0B
!#      POS^PCPL      : TEMPORARY STORAGE STRUCTURE FOR POS PCT      #!!01737K0C
!#                                                                   #!!01737K0D
!#    OUTPUT PARAMETERS:                                             #!!01737K0E
!#                                                                   #!!01737K0F
!#####################################################################!!01737K0G
proc pos^cmd^warmboot^ret^globals( pos^pcpl );                         !01737K0H
int            .pos^pcpl( pos^pct^def );                               !01737K0I
    begin                                                              !01737K0J
    !!                                                                 !01737K0K
    !Retrieve the pct values from the temporary structure.!            !01737K0L
    !!                                                                 !01737K0M
    movl( pos^pct, pos^pcpl, wlen( pos^pcpl ) );                       !01737K0N
    end;                                                               !01737K0O
                                                                       !01737K0P
?section pos^cmd^warmboot^store^globals                                !01737K0Q
?page "                          - pos^cmd^warmboot^store^globals"     !01737K0R
!#####################################################################!!01737K0S
!#                                                                   #!!01737K0T
!#              POS^CMD^WARMBOOT^STORE^GLOBALS                       #!!01737K0U
!#                                                                   #!!01737K0V
!#   THIS PROC MOVES THE POS PCT STRUCT INTO A TEMPORARY             #!!01737K0W
!#   STORAGE STRUCTURE AND RESETS THE GLOBAL STRUCT.                 #!!01737K0X
!#                                                                   #!!01737K0Y
!#    INPUT PARAMETERS:                                              #!!01737K0Z
!#      POS^PCPL      : TEMPORARY STORAGE STRUCTURE FOR POS PCT      #!!01737K10
!#                                                                   #!!01737K11
!#    OUTPUT PARAMETERS:                                             #!!01737K12
!#                                                                   #!!01737K13
!#####################################################################!!01737K14
proc pos^cmd^warmboot^store^globals( pos^pcpl );                       !01737K15
int            .pos^pcpl( pos^pct^def );                               !01737K16
    begin                                                              !01737K17
    !!                                                                 !01737K18
    !Save pos pct values in pos pcpl and clear the pos pct structure!  !01737K19
    !!                                                                 !01737K1A
    movl ( pos^pcpl, pos^pct, wlen( pos^pcpl ) );                      !01737K1B
    end;                                                               !01737K1C
                                                                       !01737K1D
                                                                       !01737K1E
                                                                       !01737S00
?section pos_del_tkns                                                  !01737S01
?page "pos_del_tkns"                                                   !01737S02
!#################################################################### !!01737S03
!#                                                                  # !!01737S04
!#                         pos_del_tkns                             # !!01737S05
!#                                                                  # !!01737S06
!#  NARRATIVE: This procedure deletes the Acquirer Routing token,   # !!01737S07
!#             Transaction Description token and Transaction        # !!01737S08
!#             Profile token from the internal message if they were # !!01737S09
!#             in the external message and formatted to the         # !!01737S0A
!#             internal message.                                    # !!01737S0B
!#                                                                  # !!01737S0C
!#  INPUT PARAMETERS:                                               # !!01737S0D
!#      pstm          : Pointer to the BASE24 Internal POS message. # !!01737S0E
!#                                                                  # !!01737S0F
!#  OUTPUT PARAMETERS:                                              # !!01737S0G
!#                                                                  # !!01737S0H
!#################################################################### !!01737S0I
proc pos_del_tkns( pstm );                                             !01737S0J
int            .pstm( pstm^def );                                      !01737S0K
    begin                                                              !01737S0L
                                                                       !01737S0M
    wlform( del^err,                                                   !01737S0N
        "Error while attempting to delete token \\ from the PSTM " )   !01737S0O
                                                                       !01737S0P
    struct         .acq^rte^tkn( acq_rte_tkn_def );                    !01737S0Q
    struct         .txn^descr^tkn( txn_descr_tkn_def );                !01737S0R
    struct         .txn^prfl^tkn( txn_prfl_tkn_def );                  !01737S0S
                                                                       !01737S0T
    int             error;                                             !01737S0U
    int             userdata;                                          !01737S0V
                                                                       !01737S0W
    string         .tkn_id[ 0:1 ];                                     !01737S0X
                                                                       !01737S0Y
    if pstm.data^flag = "0" then                                       !01737S0Z
        begin                                                          !01737S10
        movd( userdata, false );                                       !01737S11
        end                                                            !01737S12
    else                                                               !01737S13
        begin                                                          !01737S14
        movd( userdata, true );                                        !01737S15
        end;                                                           !01737S16
                                                                       !01737S17
    !                                                            !     !01737S18
    ! Delete Acquirer Routing token from internal message        !     !01737S19
    ! if it was in the internal message.                         !     !01737S1A
    !                                                            !     !01737S1B
    movd( tkn_id, acq^rte^tkn^id^d );                                  !01737S1C
                                                                       !01737S1D
    error := tkn^del^info( pstm,                                       !01737S1E
                           pstm^lgth^d( pstm ),                        !01737S1F
                           intrn^msg^lmt^l,                            !01737S1G
                           tkn_id,                                     !01737S1H
                           !ttl^tkn^data^lgth!,                        !01737S1I
                           !tkn^dspy^frmt^flg!,                        !01737S1J
                           userdata );                                 !01737S1K
                                                                       !01737S1L
    if error <> compl^no^err^l and                                     !01737S1M
       error <> tkn^does^not^exist^l then                              !01737S1N
        begin                                                          !01737S1O
        call logmessage^( 1839, !routing code!, @del^err,              !01737S1P
                          net.myname, evt_msg_severity_crit_l,         !01737S1Q
                          @pos^prod^g, @tkn_id );                      !01737S1R
        call abend^( 1839 );                                           !01737S1S
        end;                                                           !01737S1T
    !                                                            !     !01737S1U
    ! Delete Transaction Description token from internal message !     !01737S1V
    ! if it was in the internal message.                         !     !01737S1W
    !                                                            !     !01737S1X
    movd( tkn_id, txn^descr^tkn^id^d );                                !01737S1Y
                                                                       !01737S1Z
    error := tkn^del^info( pstm,                                       !01737S20
                           pstm^lgth^d( pstm ),                        !01737S21
                           intrn^msg^lmt^l,                            !01737S22
                           tkn_id,                                     !01737S23
                           !ttl^tkn^data^lgth!,                        !01737S24
                           !tkn^dspy^frmt^flg!,                        !01737S25
                           userdata );                                 !01737S26
                                                                       !01737S27
    if error <> compl^no^err^l and                                     !01737S28
       error <> tkn^does^not^exist^l then                              !01737S29
        begin                                                          !01737S2A
        call logmessage^( 1841, !routing code!, @del^err,              !01737S2B
                          net.myname, evt_msg_severity_crit_l,         !01737S2C
                          @pos^prod^g, @tkn_id );                      !01737S2D
        call abend^( 1841 );                                           !01737S2E
        end;                                                           !01737S2F
    !                                                            !     !01737S2G
    ! Delete Transaction Profile token from internal message     !     !01737S2H
    ! if it was in the internal message.                         !     !01737S2I
    !                                                            !     !01737S2J
    movd( tkn_id, txn^prfl^tkn^id^d );                                 !01737S2K
                                                                       !01737S2L
    error := tkn^del^info( pstm,                                       !01737S2M
                           pstm^lgth^d( pstm ),                        !01737S2N
                           intrn^msg^lmt^l,                            !01737S2O
                           tkn_id,                                     !01737S2P
                           !ttl^tkn^data^lgth!,                        !01737S2Q
                           !tkn^dspy^frmt^flg!,                        !01737S2R
                           userdata );                                 !01737S2S
                                                                       !01737S2T
    if error <> compl^no^err^l and                                     !01737S2U
       error <> tkn^does^not^exist^l then                              !01737S2V
        begin                                                          !01737S2W
        call logmessage^( 1843, !routing code!, @del^err,              !01737S2X
                          net.myname, evt_msg_severity_crit_l,         !01737S2Y
                          @pos^prod^g, @tkn_id );                      !01737S2Z
        call abend^( 1843 );                                           !01737S30
        end;                                                           !01737S31
    end; ! of pos_del_tkns                                           ! !01737S32
                                                                       !01737S33
?section pos^failed^0x00^pstm^rqst                                     !01738
?page "                               - pos^failed^0x00^pstm^rqst"     !01738K00
!#####################################################################!!01741
!#                                                                   #!!01742
!#                        POS^FAILED^0X00^PSTM^RQST                  #!!01743
!#                                                                   #!!01744
                                                                       !01744K00
!#    NARRATIVE : THIS PROCEDURE A FAILED INTERNAL REQUEST MESSAGE   #!!01744K01
!#                THAT IS RETURNED FROM THE NUCLEUS                  #!!01744K02
!#                                                                   #!!01744K03
!#    INPUT PARAMETERS:                                              #!!01744K04
!#       MSG          : MESSAGE WORD POINTER                         #!!01744K05
!#       MTP          : MESSAGE TEXT POINTER                         #!!01744K06
!#       PSTM         : POINTER TO BASE24 INTERNAL POS MESSAGE       #!!01744K07
                                                                       !01744K08
                                                                       !01745K00
                                                                       !01745K01
                                                                       !01745K02
!#                                                                   #!!01748
!#    OUTPUT PARAMETERS:                                             #!!01749
!#                                                                   #!!01750
!#####################################################################!!01751
proc pos^failed^0x00^pstm^rqst( msg, mtp, pstm );                      !01752
int    .msg;                                                           !01753
string .mtp;                                                           !01754
int    .pstm( pstm^def );                                              !01755
     begin                                                             !01756
     struct .sem( sem^def ),                                           !01757
            .susp( susp^bici^def );                                    !01758
                                                                       !01758K00
                                                                       !01758K01
    init( susp,                "  ", wlen( susp^bici^def ) );          !01758K02
    call pstm^frmt^b24^to^prikey( pstm, susp.prikey.tran^tim );        !01758K03
                                                                       !01758K04
    if  util^suspend^tran^delete( susp, $len( susp^bici^def ), msg,    !01758K05
                                  time^inbound^rqst^l ) then           !01758K06
         begin                                                         !01758K07
         call pos^util^sem^expand( sem, susp.msg, susp.msg^lgth );     !01758K08
                                                                       !01758K09
                                                                       !01759K00
                                                                       !01759K01
                                                                       !01759K02
         call pos^0200^deny( susp.prikey, sem, susp.orig^net^pro,      !01768
             pos^resp^cant^process^l, sub^down^at^rqst^l );            !01769
         end;                                                          !01770
     end;                                                              !01771
                                                                       !01771E00
                                                                       !01771E01
?section pos^failed^0x10^pstm^resp                                     !01771E02
                                                                       !01771K00
?page "                               - pos^failed^0x10^pstm^resp"     !01771K01
!#####################################################################!!01771K02
!#                                                                   #!!01771K03
!#                        POS^FAILED^0X10^PSTM^RESP                  #!!01771K04
!#                                                                   #!!01771K05
!#    NARRATIVE : THIS PROCEDURE HANDLES A FAILED INTERNAL RESPONSE  #!!01771K06
!#                MESSAGE THAT IS RETURNED FROM THE NUCLEUS          #!!01771K07
!#                                                                   #!!01771K08
!#    INPUT PARAMETERS:                                              #!!01771K09
!#       MSG          : MESSAGE WORD POINTER                         #!!01771K0A
!#       MTP          : MESSAGE TEXT POINTER                         #!!01771K0B
!#       PSTM         : POINTER TO BASE24 INTERNAL POS MESSAGE       #!!01771K0C
!#                                                                   #!!01771K0D
!#    OUTPUT PARAMETERS:                                             #!!01771K0E
!#                                                                   #!!01771K0F
!#####################################################################!!01771K0G
                                                                       !01771K0H
proc pos^failed^0x10^pstm^resp( msg, mtp, pstm );                      !01771E0R
int    .msg;                                                           !01771E0S
string .mtp;                                                           !01771E0T
int    .pstm( pstm^def );                                              !01771E0U
     begin                                                             !01771E0V
     struct .sem( sem^def );                                           !01771E0W
                                                                       !01771E0X
     incr^trace( trace^num^g );                                        !01771E0Y
     call pstm^frmt^b24^to^pos^sem( pstm, sem );                       !01771E0Z
                                                                       !01771E10
     msg^failure := 0;                                                 !01771E11
     movd( pstm.typ,  "0420" );                                        !01771E12
     call pstm^0420^reversal( msg, pstm, sem );                        !01771E13
     end;                                                              !01771E14
                                                                       !01771E15
                                                                       !01771E16
?section pos^failed^0x00^sem^rqst                                      !01772
?page "                                - pos^failed^0x00^sem^rqst"     !01772K00
!#####################################################################!!01775
!#                                                                   #!!01776
!#                        POS^FAILED^0X00^SEM^RQST                   #!!01777
!#                                                                   #!!01778
!#    NARRATIVE :  THIS PROCEDURE PROCESSES A FAILED OR REJECTED     #!!01779
!#       BIC ISO EXTERNAL REQUEST.                                   #!!01780
!#                                                                   #!!01781
!#    INPUT PARAMETERS:                                              #!!01782
!#       MSG           : FAILED MESSAGE WORD POINTER                 #!!01783
!#       MTP           : FAILED MESSAGE TEXT POINTER                 #!!01784
                                                                       !01784K00
!#       SEM           : POINTER TO THE BIC ISO EXTERNAL MESSAGE     #!!01784K01
!#       REJECT        : FLAG THAT INDICATES WHAT REJECT OCCURRED    #!!01784K02
                                                                       !01784K03
!#                                                                   #!!01785
!#    OUTPUT PARAMETERS:                                             #!!01786
!#                                                                   #!!01787
!#####################################################################!!01788
                                                                       !01788K00
proc pos^failed^0x00^sem^rqst( msg, mtp, sem, reject );                !01788K01
                                                                       !01788K02
                                                                       !01789K00
                                                                       !01789K01
int    .msg;                                                           !01790
string .mtp;                                                           !01791
int    .sem( sem^def );                                                !01792
                                                                       !01792K00
int     reject;                                                        !01792K01
                                                                       !01792K02
    begin                                                              !01793
    struct .susp( susp^bici^def );                                     !01794
                                                                       !01794K00
                                                                       !01794K01
    int                                                                !01794K02
           .pstm( pstm^def ) := @susp.msg;                             !01794K03
                                                                       !01794M00
    int    sta^x;                                                      !01794M01
                                                                       !01794M02
                                                                       !01794K04
    string                                                             !01794K05
            err^flg;                                                   !01794K06
                                                                       !01794K07
    init( susp,                "  ", wlen( susp^bici^def ) );          !01794K08
    call pos^frmt^sem^to^prikey( sem, susp.prikey.tran^tim );          !01794K09
                                                                       !01794K0A
    if  util^suspend^tran^delete( susp, $len( susp^bici^def ), msg,    !01794K0B
                                                                       !01794M03
                                  time^outbound^rqst^l,, sta^x ) then  !01794M04
                                                                       !01794M05
                                                                       !01794M06
                                                                       !01794M07
        begin                                                          !01794K0D
        if reject = key^sync^err^l then                                !01794K0E
            movd( err^flg, "K" )                                       !01794K0F
        else                                                           !01794K0G
        if reject = invalid^mac^err^l then                             !01794K0H
            movd( err^flg, "I" )                                       !01794K0I
        else                                                           !01794K0J
        if reject = sec^operation^failed^l or                          !01794K0K
           reject = sec^device^failed^l    then                        !01794K0L
            movd( err^flg, "M" );                                      !01794K0M
                                                                       !01794K0N
        if err^flg = "K" or                                            !01794K0O
           err^flg = "I" or                                            !01794K0P
           err^flg = "M" then                                          !01794K0Q
            begin                                                      !01794K0R
                                                                       !01794U00
            if base24^rel^g >= 5 then                                  !01794U01
                                                                       !01794U02
                call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,      !01794K0T
                                           pstm^lgth^d( pstm ),        !01794K0U
                                           false,, pstm.data^flag,     !01794K0V
                                           err^flg );                  !01794K0W
                                                                       !01794K0X
!@**********************************************************!
!@ BEGIN RPQ #240 Special Response Code for Invalid MAC
!@----------------------------------------------------------!
            if reject <> invalid^mac^err^l then
               Begin

            call pstm^0200^deny( susp.prikey, susp.msg,               !01794K0Y
                                 susp.orig^net^pro,                   !01794K0Z
                                 pstm^resp^unable^to^auth^l,          !01794K10
                                 sub^sys^err^l );                     !01794K11

               End
            else
             Begin
              call pstm^0200^deny( susp.prikey, susp.msg,
                                   susp.orig^net^pro,
                                   pstm^invalid^mac^error^l,
                                   sub^sys^err^l );
             End;
!@----------------------------------------------------------!
!@ END   RPQ #240 Special Response Code for Invalid MAC
!@**********************************************************!

            end                                                        !01794K12
        else                                                           !01794K13
            call pstm^0200^route( susp.prikey, susp.msg,               !01794K14
                      susp.orig^net^pro, pstm^resp^referral^l,         !01794K15
                      sub^down^at^rqst^l, pstm^stat^line^down^l );     !01794K16
                                                                       !01794M08
        if  msg^failure = 104 or msg^failure = 204 then                !01794M09
                                                                       !01794M0A
            ! The message timed out in the queue!                      !01794M0B
                                                                       !01794M0C
            begin                                                      !01794M0D
                                                                       !01794M0E
            increment( pct.sta[ sta^x ].t^o^ctr );                     !01794M0F
                                                                       !01794M0G
            if  pct.sta[ sta^x ].t^o^ctr >= pct.options.t^o^max then   !01794M0H
                begin                                                  !01794M0I
                if  util^station^status( sta^x, sta^down^l ) then      !01794M0J
                    call util^link^status( link^down^l,,               !01794M0K
                                           pct.sta[sta^x].t^o^ctr );   !01794M0L
                call util^timer^delete( time^wft^l,, sta^x );          !01794M0M
                call util^timer^insert( pct.timers.xnmm, time^xnmm^l,, !01794M0N
                                        sta^x, nmm^echotest^l );       !01794M0O
                end;                                                   !01794M0P
            end;                                                       !01794M0Q
                                                                       !01794M0R
        end;                                                           !01794K17
                                                                       !01794K18
                                                                       !01795K00
                                                                       !01795K01
                                                                       !01795K02
    end;                                                               !01805
?section pos^failed^0x10^sem^resp                                      !01806
?page "                                - pos^failed^0x10^sem^resp"     !01806K00
!#####################################################################!!01809
!#                                                                   #!!01810
!#                        POS^FAILED^0X10^SEM^RESP                   #!!01811
!#                                                                   #!!01812
!#    NARRATIVE : THIS PROCEDURE PROCESSES A FAILED OR REJECTED      #!!01813
!#       BIC ISO EXTERNAL RESPONSE.                                  #!!01814
!#                                                                   #!!01815
!#    INPUT PARAMETERS:                                              #!!01816
!#       MSG           : FAILED MESSAGE WORD POINTER                 #!!01817
!#       MTP           : FAILED MESSAGE TEXT POINTER                 #!!01818
!#       SEM           : BIC ISO EXTERNAL RESPONSE                   #!!01819
                                                                       !01819K00
!#       REJECT        : FLAG THAT INDICATES WHAT REJECT OCCURED     #!!01819K01
                                                                       !01819K02
!#                                                                   #!!01820
!#    OUTPUT PARAMETERS:                                             #!!01821
!#                                                                   #!!01822
!#####################################################################!!01823
                                                                       !01823K00
proc pos^failed^0x10^sem^resp( msg, mtp, sem, reject );                !01823K01
                                                                       !01823K02
                                                                       !01824K00
                                                                       !01824K01
int    .msg;                                                           !01825
string .mtp;                                                           !01826
struct .sem( sem^def );                                                !01827
                                                                       !01827K00
int     reject;                                                        !01827K01
                                                                       !01827K02
                                                                       !01828
    begin                                                              !01829
    struct .ilf( ilf^def ),                                            !01830
                                                                       !01830K00
           .prikey( prikey^def );                                      !01830K01
                                                                       !01830K02
                                                                       !01831K00
                                                                       !01831K01
                                                                       !01831K02
                                                                       !01833
    int     fnum,                                                      !01834
                                                                       !01834K00
            ilf^lgth,                                                  !01834K01
           .sim[ 0:( intrn^msg^lmt^l / 2 ) - 1 ],                      !01834K02
           .pstm( pstm^def ) := @sim;                                  !01834K03
                                                                       !01834S00
                                                                       !01834W00
    int    .auth_dest[ 0:wordlen( $len( pstm.rte.pri ) ) - 1 ];        !01834W01
                                                                       !01834W02
                                                                       !01834W03
                                                                       !01834W04
    int     fatal_flg := true;                                         !01834S02
    int     rcode;                                                     !01834S03
                                                                       !01834S04
    string  log_auth_dest_flg := " ";                                  !01834S05
                                                                       !01834S06
                                                                       !01834S07
                                                                       !01834S08
                                                                       !01835K00
                                                                       !01835K01
                                                                       !01835e00
                                                                       !01835k00
                                                                       !01835k01
                                                                       !01835k02
                                                                       !01835e08
                                                                       !01836
                                                                       !01836L00
    if ( pos^approved^d( sem ) and not pos^inquiry^d( sem ) ) or       !01836L01
       ( pos^approved^d( sem ) and                                     !01836L02
            ( reverse^bal^inq^g and pos^inquiry^d( sem ) ) ) then      !01836L03
                                                                       !01836L04
                                                                       !01837L00
                                                                       !01837L01
        !                                                             !!01838
        ! Send a reversal back to Auth for approved response          !!01839
        !                                                             !!01840
        begin                                                          !01841
        call pos^frmt^sem^to^prikey( sem, prikey );                    !01842
        if  ( fnum := util^ilf^get( prikey, $len( prikey^def ),        !01843
                ilf, ilf^lgth, pstm ) ) then                           !01844
            !                                                         !!01845
            ! The original transaction was located on the ILF         !!01846
            !                                                         !!01847
            begin                                                      !01848
            movd ( pstm.typ,        pstm^rvsl^advice^d        );       !01849
            movd ( pstm.originator, switch^interface^origin^d );       !01850
                                                                       !01850(00
            move ( pstm.retl^regn,                                     !01850(01
                   psem.add^data^prvt.pos.retl^regn );                 !01850(02
            move ( pstm.retl^grp,                                      !01850(03
                   psem.add^data^prvt.pos.retl^grp );                  !01850(04
                                                                       !01850(05
                                                                       !01850K00
                                                                       !01850K01
            if reject = key^sync^err^l then                            !01850K02
                movd( pstm.rvsl^cde, "22" )                            !01850K03
            else                                                       !01850K04
            if reject = invalid^mac^err^l then                         !01850K05
                movd( pstm.rvsl^cde, "24" )                            !01850K06
            else                                                       !01850K07
            if reject = sec^operation^failed^l or                      !01850K08
               reject = sec^device^failed^l    then                    !01850K09
                movd( pstm.rvsl^cde, "21" )                            !01850K0A
            else                                                       !01850K0B
                call integer^ascii^( pstm.rvsl^cde,                    !01850K0C
                                     pstm^rvsl^auth^not^avail^l );     !01850K0D
                                                                       !01850K0E
                                                                       !01851K00
                                                                       !01851K01
                                                                       !01851K02
                                                                       !01853
                                                                       !01853S00
            if base24^rel^g >= 6 then                                  !01853S01
                begin                                                  !01853S02
                if rcode := hiswsem_rvsl_txn_rte_pos(                  !01853S03
                                             pstm,                     !01853S04
                                             pos^pct.acq^txn^prfl,     !01853S05
                                             msg^sym^source,           !01853S06
                                             pos^pct.dest,             !01853S07
                                             apcfemt_seg_id_g,         !01853S08
                                             pos^pct.num^srv,          !01853S09
                                             icfe_name_g,              !01853S0A
                                                                       !01853W00
                                             auth_dest,                !01853W01
                                             log_auth_dest_flg,        !01853W02
                                             fatal_flg,                !01853W03
                                             apcfemt_name_g ) then     !01853W04
                                                                       !01853W05
                                                                       !01853W06
                                                                       !01853W07
                                                                       !01853W08
                    begin                                              !01853S0F
                    call util^ilf^updt( fnum,                          !01853S0G
                                        ilf,                           !01853S0H
                                        ilf^lgth,                      !01853S0I
                                        pos^l,                         !01853S0J
                                        sub^fail^pre^auth^l,           !01853S0K
                                        !pro^name!,                    !01853S0L
                                        pstm );                        !01853S0M
                    return;                                            !01853S0N
                    end                                                !01853S0O
                else                                                   !01853S0P
                    begin                                              !01853S0Q
                    call pos^util^send^pstm( pstm, auth_dest );        !01853S0R
                    if log_auth_dest_flg = "Y" then                    !01853S0S
                        begin                                          !01853S0T
                        call pos^util^send^pstm( pstm,                 !01853S0U
                                                 pos^pct.dest.name );  !01853S0V
                        end;                                           !01853S0W
                    end; ! of else rcode                             ! !01853S0X
                                                                       !01853S0Y
                end ! of base24^rel^g >= 6                           ! !01853S0Z
            else                                                       !01853S10
                begin                                                  !01853S11
                !                                                    ! !01853S12
                ! No APCF routing for pre-release 6.0.               ! !01853S13
                !                                                    ! !01853S14
                call pos^util^send^pstm( pstm, ilf.orig^net^pro );     !01853S15
                end;                                                   !01853S16
                                                                       !01853S17
                                                                       !01854S00
                                                                       !01854S01
                                                                       !01854S02
                                                                       !01855K04
                                                                       !01855S03
            call util^ilf^updt( fnum, ilf, ilf^lgth, pos^l,            !01855S04
                                sub^down^at^resp^l,, pstm );           !01855S05
                                                                       !01855S06
                                                                       !01855S07
            end;                                                       !01857
        end;                                                           !01858
    end;                                                               !01859
?section pos^failed^0xxx^sem^advice                                    !01860
?page "                              - pos^failed^0xxx^sem^advice"     !01860K00
!#####################################################################!!01863
!#                                                                   #!!01864
!#                        POS^FAILED^0XXX^SEM^ADVICE                 #!!01865
!#                                                                   #!!01866
!#    NARRATIVE :  THIS PROCEDURE PROCESSES A FAILED OR REJECTED     #!!01867
!#       BIC ISO EXTERNAL ADVICE.                                    #!!01868
!#                                                                   #!!01869
!#    INPUT PARAMETERS:                                              #!!01870
!#       MSG           : FAILED MESSAGE WORD POINTER                 #!!01871
!#       MTP           : FAILED MESSAGE TEXT POINTER                 #!!01872
!#       SEM           : BIC ISO EXTERNAL ADVICE                     #!!01873
                                                                       !01873K00
!#       REJECT        : FLAG THAT INDICATES WHAT REJECT OCCURED     #!!01873K01
                                                                       !01873K02
!#                                                                   #!!01874
!#    OUTPUT PARAMETERS:                                             #!!01875
!#                                                                   #!!01876
!#####################################################################!!01877
                                                                       !01877K00
proc pos^failed^0xxx^sem^advice( msg, mtp, sem, reject );              !01877K01
                                                                       !01877K02
                                                                       !01878K00
                                                                       !01878K01
int    .msg;                                                           !01879
string .mtp;                                                           !01880
int    .sem( sem^def );                                                !01881
                                                                       !01881K00
int     reject;                                                        !01881K01
                                                                       !01881K02
    begin                                                              !01882
    wlform( error1,                                                    !01883
    "BASE24 SAF Retry Limit EXCEEDED - SAF Record Follows" )           !01884
                                                                       !01884K00
    wlform( bad^ver,                                                   !01884K01
    "MAC Verification failure on SAF Record - SAF Record Follows" )    !01884K02
                                                                       !01884K03
                                                                       !01885
    struct .saf( saf^def );                                            !01886
                                                                       !01887
    int     saf^lgth,                                                  !01888
            sta^x,                                                     !01889
            trace^num;                                                 !01890
                                                                       !01891
    string .hdr( hdr^def );                                            !01892
                                                                       !01893
                                                                       !01893K00
    call ascii^integer^( psem.trace^num, trace^num );                  !01893K01
    if  util^timer^find( time^saf^l, trace^num,,, true ) then          !01893K02
        begin                                                          !01893K03
        call util^station^index( msg^sym^source, sta^x );              !01893K04
                                                                       !01893K05
        set  ( pct.saf.pending,    false );                            !01893K06
        set  ( saf.prikey.dpc^num, 0     );                            !01893K07
                                                                       !01893P00
        decrement( pct.sta[ sta^x ].pending );                         !01893P01
                                                                       !01893P02
                                                                       !01893M00
        if  msg^failure = 104 or msg^failure = 204 then                !01893M01
                                                                       !01893M02
            ! The message timed out in the queue!                      !01893M03
                                                                       !01893M04
            begin                                                      !01893M05
                                                                       !01893M06
            increment( pct.sta[ sta^x ].t^o^ctr );                     !01893M07
                                                                       !01893M08
            if  pct.sta[ sta^x ].t^o^ctr >= pct.options.t^o^max then   !01893M09
                begin                                                  !01893M0A
                if  util^station^status( sta^x, sta^down^l ) then      !01893M0B
                    call util^link^status( link^down^l,,               !01893M0C
                                           pct.sta[sta^x].t^o^ctr );   !01893M0D
                call util^timer^delete( time^wft^l,, sta^x );          !01893M0E
                call util^timer^insert( pct.timers.xnmm, time^xnmm^l,, !01893M0F
                                        sta^x, nmm^echotest^l );       !01893M0G
                end;                                                   !01893M0H
            end;                                                       !01893M0I
                                                                       !01893M0J
        if  hiswfile^keyposition( pct.saf.fcb.filenum, saf.prikey,,    !01893K08
                $len( saf.prikey.dpc^num ), generic^l ) <> feok then   !01893K09
            return;                                                    !01893K0A
                                                                       !01893K0B
        if  hiswfile^read( pct.saf.fcb.filenum, saf,                   !01893K0C
                $len( saf ), saf^lgth ) <> feok then                   !01893K0D
            return;                                                    !01893K0E
                                                                       !01893K0F
        if reject then                                                 !01893K0G
            begin                                                      !01893K0H
            if reject <> key^sync^err^l      and                       !01893K0I
               reject <> sec^device^failed^l then                      !01893K0J
                begin                                                  !01893K0K
                call util^saf^delete( sta^x );                         !01893K0L
                if reject = invalid^mac^err^l      or                  !01893K0M
                   reject = sec^operation^failed^l then                !01893K0N
                    begin                                              !01893K0O
                    call logmessage^( 1082,, @bad^ver, net.myname,     !01893K0P
                                      2, @pos^prod^g );                !01893K0Q
                    call log^message( 1083,, saf.msg,                  !01893K0R
                                      $min( max^logger^l, saf^lgth ),  !01893K0S
                                      net.myname, 2, @pos^prod^g );    !01893K0T
                    end;                                               !01893K0U
                return;                                                !01893K0V
                end;                                                   !01893K0W
            end                                                        !01893K0X
        else                                                           !01893K0Y
            begin                                                      !01893K0Z
            increment( pct.saf.retry^ctr );                            !01893K10
            if  pct.saf.retry^ctr = pct.saf.retry^max then             !01893K11
                begin                                                  !01893K12
                call logmessage^( 1085,, @error1, net.myname,          !01893K13
                                  2, @pos^prod^g );                    !01893K14
                call log^message( 1086,, saf.msg,                      !01893K15
                                  $min( max^logger^l, saf^lgth ),      !01893K16
                                  net.myname, 2, @pos^prod^g );        !01893K17
                call util^saf^delete( sta^x );                         !01893K18
                return;                                                !01893K19
                end;                                                   !01893K1A
            end;                                                       !01893K1B
                                                                       !01893K1C
        if  @hdr := util^hdr^expand( saf.msg, saf.msg^lgth) then       !01893K1D
            begin                                                      !01893K1E
            if not sem^repeat^d( hdr ) then                            !01893K1F
                begin                                                  !01893K1G
                if  hdr.typ = auth^advice^d then                       !01893K1H
                    movd ( hdr.typ, auth^repeat^d         );           !01893K1I
                                                                       !01893K1J
                if  hdr.typ = tran^advice^d then                       !01893K1K
                    movd ( hdr.typ, tran^repeat^d         );           !01893K1L
                                                                       !01893K1M
                if  hdr.typ = rvsl^request^d then                      !01893K1N
                    movd ( hdr.typ, rvsl^request^repeat^d );           !01893K1O
                                                                       !01893K1P
                if  hdr.typ = rvsl^advice^d then                       !01893K1Q
                    movd ( hdr.typ, rvsl^repeat^d         );           !01893K1R
                                                                       !01893K1S
                call hiswfile^update( pct.saf.fcb.filenum,             !01893K1T
                                      saf, saf^lgth );                 !01893K1U
                end;                                                   !01893K1V
            end;                                                       !01893K1W
        end;                                                           !01893K1X
                                                                       !01893K1Y
                                                                       !01893K1Z
                                                                       !01894K00
                                                                       !01894K01
                                                                       !01894K02
    end;                                                               !01934
?section pos^frmt^sem^to^prikey                                        !01935
?page "                                  - pos^frmt^sem^to^prikey"     !01935K00
!#####################################################################!!01938
!#                                                                   #!!01939
!#                    POS^FRMT^SEM^T0^PRIKEY                         #!!01940
!#                                                                   #!!01941
!#    NARRATIVE : THIS PROCEDURE FORMATS A TRANSACTION PRIMARY KEY   #!!01942
!#       FROM THE EXTERNAL MESSAGE.                                  #!!01943
!#                                                                   #!!01944
!#    INPUT PARAMETERS:                                              #!!01945
!#       SEM           : POINTER TO THE BIC ISO EXTERNAL MESSAGE     #!!01946
!#                                                                   #!!01947
!#    OUTPUT PARAMETERS:                                             #!!01948
!#       PRIKEY        : POINTER TO THE TRANSACTION PRIMARY KEY      #!!01949
!#                                                                   #!!01950
!#####################################################################!!01951
proc pos^frmt^sem^to^prikey( sem, prikey );                            !01952
int .sem( sem^def );                                                   !01953
int .prikey( prikey^def );                                             !01954
     begin                                                             !01955
     int   pan^lgth := -1;                                             !01956
                                                                       !01957
     init ( prikey, "  ", wlen( prikey^def ) );                        !01958
                                                                       !01959
                                                                       !H0195900
    if psem.track2.len <> [ $len( psem.track2.len ) * [ " " ] ] and    !H0195901
       psem.track2.len <> [ $len( psem.track2.len ) * [ "0" ] ] and    !H0195902
       psem.track2.data <> [ $len( psem.track2.data ) * [ " " ] ] and  !H0195903
       psem.track2.data <> [ $len( psem.track2.data ) * [ "0" ] ] then !H0195904
        begin                                                          !H0195905
        while ( ( pan^lgth := pan^lgth + 1 ) <= $len( prikey.pan ) )   !H0195906
           and $numeric( psem.track2.data.byte[ pan^lgth ] ) do;       !H0195907
                                                                       !H0195908
        if pan^lgth then                                               !H0195909
            begin                                                      !H019590A
            movl( prikey.pan, psem.track2.data, pan^lgth );            !H019590B
            end                                                        !H019590C
        else                                                           !H019590D
            begin                                                      !H019590E
            init^( prikey.pan, "0" );                                  !H019590F
            end;                                                       !H019590G
        end  ! of track2 present                                      !!H019590H
    else                                                               !H019590I
    if psem.pan.len <> [ $len( psem.pan.len ) * [ " " ] ]  and         !H019590J
       psem.pan.len <> [ $len( psem.pan.len ) * [ "0" ] ]  and         !H019590K
       psem.pan.data <> [ $len( psem.pan.data ) * [ " " ] ] and        !H019590L
       psem.pan.data <> [ $len( psem.pan.data ) * [ "0" ] ] then       !H019590M
        begin                                                          !H019590N
        call ascii^integer^( psem.pan.len, pan^lgth );                 !H019590O
        movl( prikey.pan, psem.pan.data, pan^lgth );                   !H019590P
        end  ! of de-2 present                                        !!H019590Q
    else                                                               !H019590R
        begin                                                          !H019590S
        init^( prikey.pan, "0" );                                      !H019590T
        end; ! no track2 or pan available                             !!H019590U
                                                                       !H019590V
                                                                       !H0196000
                                                                       !H0196001
                                                                       !H0196002
                                                                       !01962K05
                                                                       !01962K06
                                                                       !01963K00
                                                                       !01963K01
     move ( prikey.ref^num,  psem.retrvl^ref^num.data    );            !01964
     move ( prikey.term^id,  psem.term^id                );            !01965
     move ( prikey.tran^dat, psem.tran^dat               );            !01966
                                                                       !01967
     call ascii^double( psem.tran^tim, 4, prikey.tran^tim );           !01968
     end;                                                              !01969
?section pos^frmt^sem^to^pstm                                          !01970
?page "                                        - pos^frmt^sem^to^pstm" !01971
!#####################################################################!!01972
!#                                                                   #!!01973
!#                    POS^FRMT^SEM^T0^PSTM                           #!!01974
!#                                                                   #!!01975
!#    NARRATIVE : THIS PROCEDURE FORMATS AN EXTERNAL REQUEST TO A    #!!01976
!#       PSTM REQUEST.                                               #!!01977
!#                                                                   #!!01978
!#    INPUT PARAMETERS :                                             #!!01979
!#       SEM           : POINTER TO EXTERNAL MESSAGE.                #!!01980
!#                                                                   #!!01981
!#    OUTPUT PARAMETERS:                                             #!!01982
!#       PSTM          : POINTER TO INTERNAL MESSAGE.                #!!01983
!#                                                                   #!!01984
!#####################################################################!!01985
proc pos^frmt^sem^to^pstm( sem, pstm );                                !01986
int .sem( sem^def );                                                   !01987
int .pstm( pstm^def );                                                 !01988
    begin                                                              !01989
    int  apprv^cde^lgth := 6;                                          !01990
                                                                       !01991
                                                                       !01991K00
    struct .address( p63^addr^def );                                   !01991K01
                                                                       !01991K02
    int                                                                !01991K03
                                                                       !01991K04
                                                                       !01991K05
                                                                       !01991M00
            userdata^ofst,                                             !01991M01
                                                                       !01991M02
                                                                       !01991M03
                                                                       !01991M04
                                                                       !01991K07
                                                                       !01991K08
            prvt4^lgth,                                                !01991K09
                                                                       !01991K0A
            prvt4^item^lgth;                                           !01991D04
                                                                       !01991D05
                                                                       !01991K0B
                                                                       !01991M05
    string .pstm^s := @pstm '<<' 1,                                    !01991M06
                                                                       !01991M07
                                                                       !01991M08
                                                                       !01991M09
           .prvt4^ptr;                                                 !01991K0D

!*===================================================================*!
!* BEGIN RPQ #nn- Control REDE/MULT                                   !
!---------------------------------------------------------------------!
    struct pro^rede^temp;
          begin string byte[0:15]; end;
!---------------------------------------------------------------------!
!* END   RPQ #nn- Control REDE/MULT                                   !
!*===================================================================*!
!* BEGIN RPQ #27 - Handle Transaction with IVA                       *!
!---------------------------------------------------------------------!
    int     .user^data( user^data^d^def );
    string  .priv^field( privfield^def );
    int      len^iva^fld,
             tot^userdata^len;
!---------------------------------------------------------------------!
!* END   RPQ #27 - Handle Transactions with IVA                      *!
!*===================================================================*!
                                                                       !01991K0E
    !!                                                                 !01991K0F
    !clear the pstm and the token header eye catcher!                  !01991K0G
    !if one was left over from a pervious tran!                        !01991K0H
    !!                                                                 !01991K0I
                                                                       !01991n00
                                                                       !01991n01
    init( pstm, "00", ( wlen( pstm^def ) +                             !01991n02
                        wlen( user^data^def ) + 1 ) );                 !01991n03
                                                                       !01991n04
                                                                       !01991K0L
                                                                       !01991K0M
                                                                       !01991K0N
                                                                       !01994
    ! Initialize the binary fields to 0                               !!01995
                                                                       !01996
    pstm.tran.amt^1 := pstm.tran.amt^2 := 0f;                          !01997
    pstm.exit^tim := pstm.re^entry^tim := pstm.entry^tim := 0f;        !01998
    pstm.term^tim^ofst := 0;                                           !01999
                                                                       !01999\00
    pstm.tran.pre^auth^hld := 0;                                       !01999\01
                                                                       !01999\02
    pstm.rte.onl^lmt   := 0d;                                          !02000
    pstm.rte.offl^lmt  := 0d;                                          !02001
                                                                       !02002
    call all^ascii^integer^(                                           !02003
        psem.pri^rsrvd1^prvt.pos.term^time^ofst, pstm.term^tim^ofst ); !02004
                                                                       !02005
    mov^ ( pstm.post^dat, pos^post^dat^g );                            !02006
                                                                       !02006K00
                                                                       !02006K01
    call hiswutil^mmdd^to^yymmdd( psem.cap^dat,                        !02006K02
                                  pstm.acq^ichg^setl^dat );            !02006K03
    call hiswutil^mmdd^to^yymmdd( psem.tran^dat,                       !02006K04
                                  pstm.tran^dat          );            !02006K05
                                                                       !02006K06
    move ( pstm.prod^id,         psem.prod^id            );            !02006K07
    set  ( pstm.dpc^num,         0                       );            !02006K08
    mov^ ( pstm.orig^pro^name,   net.myname              );            !02006K09

!*********************************************************************!
!* BEGIN RPQ #nn- Control REDE/MULT                                   !
!---------------------------------------------------------------------!
    mov^( pro^rede^temp,    net.myname );
    pstm.tran.user^fld2 ':=' " ";

    if pro^rede^temp.byte[0] = pro^rede^adq^g.byte[0] for 12 then
      begin
       !    Transaccion coming from REDEBAN ADQ
       !
       pstm.tran.user^fld2 ':=' "R";
      end;

!---------------------------------------------------------------------!
!* END   RPQ #nn- Control REDE/MULT                                   !
!*********************************************************************!

    movd ( pstm.originator,      switch^origin^d         );            !02006K0A
    move ( pstm.term^ln,         pct.ln                  );            !02006K0B
    move ( pstm.term^fiid,       pct.fiid                );            !02006K0C
    mov^ ( pstm.term^id,         blanks                  );            !02006K0D
    move ( pstm.term^id,         psem.term^id            );            !02006K0E
    move ( pstm.term^name^loc,                                         !02006K0F
        ssem.secndry^rsrvd1^prvt.pos.term^name^loc );                  !02006K0G
    move ( pstm.term^owner^name, psem.crd^accpt^name^loc.term^owner ); !02006K0H
    move ( pstm.term^city,       psem.crd^accpt^name^loc.term^city  ); !02006K0I
    move ( pstm.term^st,         psem.crd^accpt^name^loc.term^st    ); !02006K0J
    move ( pstm.term^cntry^cde,  psem.crd^accpt^name^loc.term^cntry ); !02006K0K
                                                                       !02006M00
                                                                       !02006i00
    if pct.options.mult^crncy = "N" then                               !02006i01
        begin                                                          !02006i02
        mov^( pstm.orig^crncy^cde, local^crncy^cde^g );                !02006i03
        end                                                            !02006i04
    else                                                               !02006i05
        begin                                                          !02006i06
        mov^( pstm.orig^crncy^cde, psem.crncy^cde );                   !02006i07
        end;                                                           !02006i08
                                                                       !02006i09
                                                                       !02006i0A
                                                                       !02006i0B
                                                                       !02006M02
                                                                       !02006M03
                                                                       !02006M04
    move ( pstm.brch^id,  ssem.secndry^rsrvd1^prvt.pos.brch^id      ); !02006K0M
    move ( pstm.clerk^id, ssem.secndry^rsrvd2^prvt.pos.clerk^id     ); !02006K0N
                                                                       !02006K0O
                                                                       !02011K00
                                                                       !02011K01
                                                                       !02011K02
    move ( pstm.crt^auth.grp,                                          !02044
        ssem.secndry^rsrvd2^prvt.pos.crt^auth^grp );                   !02045
    move ( pstm.crt^auth.user^id,                                      !02046
        ssem.secndry^rsrvd2^prvt.pos.crt^auth^user^id );               !02047
                                                                       !02048
                                                                       !02048;00
    if pstm.crt^auth.grp <>                                            !02048;01
           zeroes for $len( pstm.crt^auth.grp ) and                    !02048;02
       pstm.crt^auth.grp <>                                            !02048;03
           blanks for $len( pstm.crt^auth.grp ) and                    !02048;04
       pstm.crt^auth.user^id <>                                        !02048;05
           zeroes for $len( pstm.crt^auth.user^id ) and                !02048;06
       pstm.crt^auth.user^id <>                                        !02048;07
           blanks for $len( pstm.crt^auth.user^id ) then               !02048;08
        begin                                                          !02048;09
        pstm.term^typ ':=' "99";                                       !02048;0A
        end;                                                           !02048;0B
                                                                       !02048;0C
                                                                       !02048K00
                                                                       !02048K01
    mov^ ( pstm.seq^num,         blanks                          );    !02048K02
    move ( pstm.seq^num,         psem.retrvl^ref^num.pos.seq^num );    !02048K03
                                                                       !02048K04
                                                                       !02053
    move ( pstm.pre^auth^seq^num,                                      !02054
        ssem.secndry^rsrvd7^prvt.pos.pre^auth^seq^num );               !02055
    move ( pstm.invoice^num     ,                                      !02056
        ssem.secndry^rsrvd4^prvt.pos.invoice^num );                    !02057
    move ( pstm.orig^invoice^num,                                      !02058
        ssem.secndry^rsrvd4^prvt.pos.orig^invoice^num );               !02059
    move ( pstm.batch^seq^num,                                         !02060
        ssem.secndry^rsrvd5^prvt.pos.batch^seq^num );                  !02061
                                                                       !02061K00
                                                                       !02061K01
    move ( pstm.batch^num, ssem.secndry^rsrvd5^prvt.pos.batch^num );   !02061K02
    move ( pstm.shift^num, ssem.secndry^rsrvd5^prvt.pos.shift^num );   !02061K03
                                                                       !02061K04
    move ( pstm.retl^id,       psem.add^data^prvt.pos.retl^id   );     !02061K05
    move ( pstm.retl^regn,     psem.add^data^prvt.pos.retl^regn );     !02061K06
    move ( pstm.retl^grp,      psem.add^data^prvt.pos.retl^grp  );     !02061K07
    move ( pstm.retl^sic^cde,  psem.mrcht^typ^cde               );     !02061K08
                                                                       !02061K09
    movd ( pstm.tran.orig,     "BICI"                           );     !02061K0A
    movd ( pstm.tran.dest,     "B24 "                           );     !02061K0B
                                                                       !02061K0C
    move ( pstm.tran.acct,      ssem.acct1                      );     !02061K0D
    move ( pstm.tran.mbr^num,   psem.mbr^num                    );     !02061K0E
    move ( pstm.tran.exp^dat,   psem.exp^dat                    );     !02061K0F
    mov^ ( pstm.tran.apprv^cde, blanks                          );     !02061K0G
    move ( pstm.tran.apprv^cde, psem.auth^id^resp               );     !02061K0H
                                                                       !02061200
    init^( pstm.tran.ichg^resp, " "                             );     !02061201
                                                                       !02061202
                                                                       !02066K00
                                                                       !02066K01
                                                                       !02066K02
                                                                       !02091
    if  psem.auth^id^resp^len = blanks for $len( psem.auth^id^resp^len ) then
        call integer^ascii^( pstm.tran.apprv^cde^lgth,                 !02094
            pos^pct.apprv^cde^lgth )                                   !02095
    else                                                               !02096
                                                                       !02097
        ! The BIC ISO External message only supports a 6 digit maximum!!02098
        ! approval code                                               !!02099
                                                                       !02100
        begin                                                          !02101
        call ascii^integer^( psem.auth^id^resp^len, apprv^cde^lgth );  !02102
        call integer^ascii^( pstm.tran.apprv^cde^lgth,                 !02103
            $min( 6, apprv^cde^lgth ) );                               !02104
        end;                                                           !02105
                                                                       !02106
    call ascii^integer^( ssem.secndry^rsrvd7^prvt.pos.pre^auth^hld,    !02107
        pstm.tran.pre^auth^hld );                                      !02108
    if  pstm.tran.pre^auth^hld <= 0 then                               !02109
        set  ( pstm.tran.pre^auth^hld, pos^pct.pre^auth^hld );         !02110
                                                                       !02111
    move ( pstm.tran.rfrl^phone,                                       !02112
        ssem.secndry^rsrvd7^prvt.pos.rfrl^phone );                     !02113
    if  pstm.tran.rfrl^phone = blanks for $len(pstm.tran.rfrl^phone) then
        move ( pstm.tran.rfrl^phone, pos^pct.phone^num );              !02116
                                                                       !02117
    move ( pstm.tran.pseudo^term^id,                                   !02118
         psem.pri^rsrvd1^prvt.pos.pseudo^term^id );                    !02119
    move ( pstm.tran.dft^capture^flg,                                  !02120
         ssem.secndry^rsrvd6^prvt.pos.dft^capture^flg );               !02121
    move ( pstm.tran.save^acct^typ,                                    !02122
         psem.pri^rsrvd2^prvt.pos.save^acct^typ  );                    !02123
                                                                       !02124
                                                                       !02124K00
                                                                       !02124K01
    move ( pstm.tran.setl^flg, ssem.secndry^rsrvd6^prvt.pos.setl^flg); !02124K02
    move ( pstm.rte.srv,       ssem.secndry^rsrvd6^prvt.pos.srv     ); !02124K03
                                                                       !02124K04
    move ( pstm.rea^for^chrgbck,                                       !02129
         ssem.secndry^rsrvd7^prvt.pos.rea^for^chrgbck );               !02130
    move ( pstm.num^of^chrgbck,                                        !02131
         ssem.secndry^rsrvd7^prvt.pos.num^of^chrgbck  );               !02132
                                                                       !02133
                                                                       !02133K00
    move ( pstm.tran^tim,           psem.tran^tim                   ); !02133K01
                                                                       !02133K02
                                                                       !02136
    if  psem.pt^tran^spcl^cde <> blanks for                            !02137
            $len( psem.pt^tran^spcl^cde ) then                         !02138
                                                                       !02138K00
        move ( pstm.pt^srv^cond^cde,    psem.pt^tran^spcl^cde       ); !02138K01
                                                                       !02138K02
    if  psem.entry^mde <> blanks for $len( psem.entry^mde ) then       !02138K03
        move ( pstm.pt^srv^entry^mde,   psem.entry^mde              ); !02138K04
                                                                       !02138K05
    move ( pstm.crd^accpt^id^num,   psem.crd^accpt^id^cde           ); !02138K06
    move ( pstm.postal^cde, psem.pri^rsrvd3^prvt.b24^def.postal^cde ); !02138K07
                                                                       !02138K08
                                                                       !02138M00
                                                                       !02138+00
                                                                       !02138+01
    mov^( pstm.orig^data,              zeroes              );          !02138+02
    movl( pstm.orig^data.msg^typ,      psem.typ, 2         );          !02138+03
    move( pstm.orig^data.tran^seq^num, psem.retrvl^ref^num );          !02138+04
    move( pstm.orig^data.trn^dat,      psem.tran^dat       );          !02138+05
    move( pstm.orig^data.trn^tim,      psem.tran^tim       );          !02138+06
    move( pstm.orig^data.b24^post^dat, psem.cap^dat        );          !02138+07
                                                                       !02138+08
                                                                       !02138M07
                                                                       !02138M08
                                                                       !02138M09
                                                                       !02138M0A
                                                                       !02138K0F
                                                                       !02141K00
                                                                       !02141K01
                                                                       !02141K02
                                                                       !02161
    call util^frmt^inst^id( pstm.crd^iss^id^num,                       !02162
        ssem.secndry^rsrvd3^prvt.len.byte[1],                          !02163
        ssem.secndry^rsrvd3^prvt.b24.crd^iss^id^num, 1 );              !02164
                                                                       !02165
    call util^frmt^inst^id( pstm.acq^inst^id^num,                      !02166
        psem.acq^inst^id.len, psem.acq^inst^id.num, 1 );               !02167
                                                                       !02168
    call util^frmt^inst^id( pstm.rcv^inst^id^num,                      !02169
        ssem.rcv^inst.len, ssem.rcv^inst.id^num, 1 );                  !02170
                                                                       !02171
    call util^frmt^inst^id( pstm.frwd^inst^id^num,                     !02172
        psem.frwd^inst^id.len, psem.frwd^inst^id.num, 1 );             !02173
                                                                       !02173j00
    if ovrrd^acq^inst^id^d and                                         !02173j01
       pstm.acq^inst^id^num =                                          !02173j02
           [ $len( pstm.acq^inst^id^num ) * [ "0" ] ] then             !02173j03
        begin                                                          !02173j04
        !                                                             !!02173j05
        ! Move pct.acq^id^num (right justified, zero filled) into     !!02173j06
        ! pstm.acq^inst^id^num (right justified, zero filled)         !!02173j07
        !                                                             !!02173j08
        mov^( pstm.acq^inst^id^num, pct.acq^id^num );                  !02173j09
        end;                                                           !02173j0A
                                                                       !02173j0B
                                                                       !02173m00
                                                                       !02173m01
                                                                       !02173m02
                                                                       !02173j0M
                                                                       !02174
    use i; i := -1;                                                    !02175
    pstm.num^services := pos^pct.num^srv;                              !02176
    while ( ( i := i + 1 ) < pstm.num^services ) do                    !02177
        begin                                                          !02178
        pstm.srvcs[ i ].typ ':=' pos^pct.allowed^srv[ i ] for 2;       !02179
                                                                       !02179L00
        pstm.srvcs[ i ].tran^profile ':='                              !02179L01
                                pstm.tran.dft^capture^flg for 1;       !02179L02
                                                                       !02179L03
        pstm.srvcs[ i ].flr^lmt  := 0d;                                !02180
        pstm.srvcs[ i ].tran^lmt := 0d;                                !02181
        end;                                                           !02182
    drop i;                                                            !02183
                                                                       !02184
    if  ascii^integer^( ssem.secndry^rsrvd8^prvt.len,                  !02185
            pos^userdata^lgth^g ) and pos^userdata^lgth^g > 0 then     !02186
        begin                                                          !02187
        pstm.data^flag := "1";                                         !02188
        pos^userdata^g ':=' ssem.secndry^rsrvd8^prvt.pos^user^data for !02189
                                                                       !02189M00
            $min( pos^userdata^lgth^g, 200 );                          !02189M01
        userdata^ofst := $offset( pstm.srvcs[0] ) +                    !02189M02
             $min( ( $len( pstm.srvcs[0] ) * pstm.num^services ),      !02189M03
             ( $len( pstm.srvcs[0] ) * $occurs( pstm.srvcs )));        !02189M04
        pstm^s[ userdata^ofst ] ':='                                   !02189M05
            pos^userdata^lgth^g for 1 &                                !02189M06
            pos^userdata^g for pos^userdata^lgth^g;                    !02189M07
                                                                       !02189M08
                                                                       !02190M00
                                                                       !02190M01
        end;                                                           !02191
                                                                       !02192
!*********************************************************************!
!* BEGIN RPQ #27 - Handle Transactions with IVA                      *!
!---------------------------------------------------------------------!
    if ascii^integer^( psem.add^data^natl.len, len^iva^fld ) and
       len^iva^fld > 0 then
       begin
        pstm.data^flag := "1" ;

        tot^userdata^len := $len( priv^field );
        tot^userdata^len := tot^userdata^len + 1;

        @user^data := @pstm.srvcs[ $min( $occurs( pstm.srvcs ),
                                   pstm.num^services ) ]  '>>' 1;
        !
        ! priv^field is being mapped to the second byte, because
        ! the first byte is used as term^type in the HPDHS.
        ! The priv^fields needed start after the term^type.
        !
        @priv^field := @user^data.info.byte[1];

! BEGIN RPQ #27C - Ajustes por envio de campo IVA con 37 len
        priv^field.rpq^priv^data.byte[0] ':='
                         [ $len( priv^field.rpq^priv^data ) * [" "]];
! END   RPQ #27C - Ajustes por envio de campo IVA con 37 len

        priv^field.rpq^priv^data.byte[0] ':='
                   psem.add^data^natl.data for len^iva^fld;


        userdata^ofst := $offset( pstm.srvcs[0] ) +
             $min( ( $len( pstm.srvcs[0] ) * pstm.num^services ),
                   ( $len( pstm.srvcs[0] ) * $occurs( pstm.srvcs )));

        pstm^s[ userdata^ofst ] ':='
            tot^userdata^len for 1 & " " &
                             priv^field for $len( priv^field );

       end;
!---------------------------------------------------------------------!
!* END   RPQ #27 - Handle Transactions with IVA                      *!
!*********************************************************************!
                                                                       !02192K00
                                                                       !02192L00
                                                                       !02192U00
    if pct.options.version^num = "00" then                             !02192U01
                                                                       !02192U02
                                                                       !02192L02
                                                                       !02192L03
                                                                       !02192L04
        begin                                                          !02192K02
        !!                                                             !02192K03
        ! Transfer address and verification status from SEM to PSTM!   !02192K04
        !!                                                             !02192K05
        if not ascii^integer^( psem.pri^rsrvd4^prvt.len, prvt4^lgth )  !02192K06
            then prvt4^lgth := 0;                                      !02192K07
        @prvt4^ptr := @psem.pri^rsrvd4^prvt.pos.add^data;              !02192K08
        !!                                                             !02192K09
        ! While we have not searched all of the valid data items!      !02192K0A
        !!                                                             !02192K0B
        while ( @prvt4^ptr '-' @psem.pri^rsrvd4^prvt.pos.add^data )    !02192K0C
            < prvt4^lgth do                                            !02192K0D
            begin                                                      !02192K0E
            if ( prvt4^ptr[2] = av^data^item^cde^d ) then              !02192K0F
                begin  ! Disassemble address verification data !       !02192K0G
                mov^( address, prvt4^ptr );                            !02192K0H
                mov^( pstm.addr^flds.addr,  address.addr );            !02192K0I
                mov^( pstm.zip^cde,         address.zip^cde );         !02192K0J
                movd( pstm.addr^typ, av^addr^typ^d );                  !02192K0K
                end;                                                   !02192K0L
            !!                                                         !02192K0M
            ! Move prvt4^ptr to beginning of next data item!           !02192K0N
            !!                                                         !02192K0O
            call ascii^integer( prvt4^ptr, 2, prvt4^item^lgth );       !02192K0P
            @prvt4^ptr := @prvt4^ptr '+' ( prvt4^item^lgth + 2 );      !02192K0Q
            end; ! while !                                             !02192K0R
        end;                                                           !02192K0S
                                                                       !02192K0T
                                                                       !02192K0U
                                                                       !02192K0V
                                                                       !02192K0W
                                                                       !02192K0X
    if ( psem.resp^data.pos.addr^vrfy^stat <> zeroes ) and             !02192D0Q
        ( psem.resp^data.pos.addr^vrfy^stat <> blanks ) then           !02192D0R
        begin                                                          !02192D0S
        move( pstm.addr^flds.addr^vrfy^stat,                           !02192D0T
              psem.resp^data.pos.addr^vrfy^stat );                     !02192D0U
        movd( pstm.addr^typ, av^addr^typ^d );                          !02192D0V
        end;                                                           !02192D0W
                                                                       !02192D0X
                                                                       !02192D0Y
    end;                                                               !02193
?section pos^frmt^sem^to^pstm^0200                                     !02194
?page "                               - pos^frmt^sem^to^pstm^0200"     !02194K00
!#####################################################################!!02197
!#                                                                   #!!02198
!#                     POS^FRMT^SEM^TO^PSTM^0200                     #!!02199
!#                                                                   #!!02200
!#    NARRATIVE : THIS PROCEDURE FORMATS A BASE24 INTERNAL POS       #!!02201
!#       REQUEST MESSAGE FROM A BIC ISO EXTERNAL REQUEST MESSAGE.    #!!02202
!#                                                                   #!!02203
!#    INPUT PARAMETERS:                                              #!!02204
!#       SEM           : POINTER TO THE BIC ISO EXTERNAL MESSAGE     #!!02205
                                                                       !02205S00
!#       STA^X         : INDEX OF STATION MESSAGE RECEIVED ON        #!
                                                                       !02205S03
!#                                                                   #!!02206
!#    OUTPUT PARAMETERS:                                             #!!02207
!#       PSTM          : POINTER TO THE BASE24 INTERNAL POS MESSAGE  #!!02208
!#                                                                   #!!02209
!#####################################################################!!02210
                                                                       !02211S00
int proc pos^frmt^sem^to^pstm^0200( sem, pstm, sta^x );                !02211S01
                                                                       !02211S02
int .sem(  sem^def  );                                                 !02212
int .pstm( pstm^def );                                                 !02213
                                                                       !02213S00
int .sta^x;                                                            !02213S01
                                                                       !02213S02
    begin                                                              !02214
                                                                       !02214K00
    wlform( del^err,                                                   !02214K01
        "Error while attempting to delete token \\ from the PSTM " )   !02214K02
    wlform( get^err, "Error while attempting to get token \\ " )       !02214K03
                                                                       !02214K04
!*==================================================================*!
!  BEGIN RPQ #25 - Bill Payment                      MCD / 2269      !
!--------------------------------------------------------------------!
    wlform(conv^err,"Error while attempting to convert ascii to fixed")
    wlform(add^err, "Error while attempting to add token \\")
!--------------------------------------------------------------------!
!  END   RPQ #25 - Bill Payment                      MCD / 2269      !
!*==================================================================*!
                                                                       !02214K05
                                                                       !02214K06
    define   sem^adj^code^d( x )  =  adjustment^tbl[ (x) * 4 + 0]#,    !02215
             pstm^adj^code^d( x ) =  adjustment^tbl[ (x) * 4 + 2]#;    !02216
                                                                       !02217
    string   adjustment^tbl = 'P' :=  [                                !02218
        !                                                             !!02219
        !  SEM  ADJ.        PSTM ADJ.                                 !!02220
        !  CODES            CODES                                     !!02221
        !    |                |                                       !!02222
        !    v                v                                       !!02223
           "64",            "12", ! original amount incorrect         !!02224
           "S1",            "14", ! private - suspcious rvsl overide  !!02225
           "S2",            "15", ! private - misdispense overide     !!02226
           "94",            "16", ! duplicate transmission            !!02227
           "95",            "17", ! reconcile error                   !!02228
           "S3",            "18", ! private - PLUS add cash wdl or adv!!02229
           "96",            "19", ! system malfunction                !!02230
                                                                       !02230100
           "T9",            "16", ! duplicate transmission            !!02230101
                                                                       !02230102
            0 ];                                                       !02231
                                                                       !02232
                                                                       !02233K00
    literal                                                            !02233K01
                                                                       !02233K02
            max^pin^lgth^l = 16;                                       !02234
                                                                       !02235
                                                                       !02235K00
    struct                                                             !02235K01

!*==================================================================*!
!  BEGIN RPQ #25 - Bill Payment                       MCD / 2269     !
!--------------------------------------------------------------------!
           .rpq^bill^pymt^buf( rpq^bill^pymt^tkn^def ),
!--------------------------------------------------------------------!
!  END   RPQ #25 - Bill Payment                       MCD / 2269     !
!*===================================================================!
!*******************************************************************!
! BEGIN RPQ #ID001 - Manejo Especial Campo P42                      !
!*******************************************************************!
           .rpq^p42^tkn( rpq^p42^tkn^def ),
!*******************************************************************!
! END   RPQ #ID001 - Manejo Especial Campo P42                      !
!*******************************************************************!
           .addr^ver^tkn( addr^ver^tkn^def );                          !02235K02
                                                                       !02235K03
    int                                                                !02235K04
            add^tkn := 0,                                              !02235K05
            addr^tkn^del := 0,                                         !02235K06
            epin^lgth := -1,                                           !02235K07
            error,                                                     !02235K08
           .ext^data^fld^i := wordaddr( @psem.pri^rsrvd4^prvt.data ),  !02235K09
            ext^lgth^i := 0,                                           !02235K0A
            ipin^lgth := -1,                                           !02235K0B
            pan^lgth  := -1,                                           !02235K0C
                                                                       !O0223500
           .pos^data1^tkn( pos^data1^tknx^def ),                       !O0223501
                                                                       !O0223502
            resp^cde  := 0,                                            !02235K0D
            sec^dev^resp := 0,                                         !02235K0E
            tkn^lgth,                                                  !02235K0F
!*==================================================================*!
!    RPQ #25 - Bill Payment                           MCD / 2269     !
!--------------------------------------------------------------------!
            tkn^ofst^g := 0,
            tkn^util^val,
            txt^lgth,
            pos^user^data^flag,
            stat,
!--------------------------------------------------------------------!
!    RPQ #25 - Bill Payment                           MCD / 2269     !
!*==================================================================*!
            userdata;                                                  !02235K0G
                                                                       !02235S00
    int     fatal_flg := true;                                         !02235S01
    int     rcode;                                                     !02235S02
                                                                       !02235S03
                                                                       !02235K0H
    string                                                             !02235K0I
            err^flg,                                                   !02235K0J
           .pan[ 0:max^pan^lgth^l - 1 ],                               !02235K0K
                                                                       !D0223500
           .prevrfyd^pin[ 0:15 ] := [ 16 * [ "0" ] ],                  !D0223501
                                                                       !D0223502
                                                                       !D0223503
            tkn^id[0:1];                                               !D0223504
                                                                       !D0223505
                                                                       !02235K0M
                                                                       !02236K00
                                                                       !02236K01
                                                                       !02236K02
                                                                       !02241
    movd ( pstm.typ, tran^request^d );                                 !02242
                                                                       !02243
    call integer^ascii^( pstm.host^trace^num, trace^num^g );           !02244
                                                                       !02245
    if  not pos^frmt^sem^to^pstm^tran( sem, pstm ) then                !02246
                                                                       !02246K00
        set( resp^cde, pos^resp^inv^tran^l );                          !02246K01
                                                                       !02246K02
                                                                       !02247K00
                                                                       !02247K01
                                                                       !02248
    if  not pos^frmt^sem^to^pstm^acct( sem, pstm ) then                !02249
                                                                       !02249K00
        if not resp^cde then                                           !02249K01
            set( resp^cde, pos^resp^frmt^err^l );                      !02249K02
                                                                       !02249K03
    while ( ( pan^lgth := pan^lgth + 1 ) < max^pan^lgth^l ) and        !02249K04
              $numeric( psem.track2.data.byte[ pan^lgth ] ) do;        !02249K05
    init ( pan, " ", $occurs( pan ) );                                 !02249K06
    movl ( pan, psem.track2.data, pan^lgth );                          !02249K07
                                                                       !02249S00
                                                                       !02249W00
    if not pos^frmt^sem^to^pstm^tkn( sem, pstm ) then                  !02249W01
        begin                                                          !02249W02
        movd( err^flg, tkn^err^flg^d );                                !02249W03
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02249W04
        call hiswtkn^set^ps50^tkn( ext^data^fld^i,                     !02249W05
                                   $len( psem.pri^rsrvd4^prvt.pos.     !02249W06
                                         add^data ),                   !02249W07
                                   0, true, ext^lgth^i, !city^ext!,    !02249W08
                                   err^flg );                          !02249W09
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02249W0A
        if not resp^cde then                                           !02249W0B
            begin                                                      !02249W0C
            set( resp^cde, pos^resp^frmt^err^l );                      !02249W0D
            end;                                                       !02249W0E
        end                                                            !02249W0F
    else                                                               !02249W0G
        begin                                                          !02249W0H
        if base24^rel^g >= 6 and                                       !02249W0I
           psem.pri^rsrvd4^prvt.len <> "   " and                       !02249W0J
           psem.pri^rsrvd4^prvt.len <> "000" then                      !02249W0K
            begin                                                      !02249W0L
            call pos_del_tkns( pstm );                                 !02249W0M
            end;                                                       !02249W0N
        end;                                                           !02249W0O
                                                                       !02249W0P
    if base24^rel^g >= 6 then                                          !02249S01
        begin                                                          !02249S02
        rcode := hiswpstm_txn_alwd_acq ( pstm,                         !02249S03
                                         pos^pct.acq^txn^prfl,         !02249S04
                                         pct.sta[ sta^x ].nam,         !02249S05
                                         apcfemt_seg_id_g,             !02249S06
                                         pos^pct.num^srv,              !02249S07
                                         apcf_emt_rec_g,               !02249S08
                                         fatal_flg,                    !02249S09
                                         apcfemt_name_g );             !02249S0A
        if rcode = sys_frmt_err_l then                                 !02249S0B
            begin                                                      !02249S0C
            !                                                        ! !02249S0D
            ! System error                                           ! !02249S0E
            !                                                        ! !02249S0F
            return pos^resp^frmt^err^l;                                !02249S0G
            end                                                        !02249S0H
        else                                                           !02249S0I
            begin                                                      !02249S0J
            if rcode = txn_cde_not_sppt_l then                         !02249S0K
                begin                                                  !02249S0L
                !                                                    ! !02249S0M
                ! Trans not allowed to switch according to APCFEMT   ! !02249S0N
                !                                                    ! !02249S0O
                return pos^resp^inv^tran^l;                            !02249S0P
                end;                                                   !02249S0Q
            end;                                                       !02249S0R
        end; ! of base24^rel^g >= 6                                  ! !02249S0S
                                                                       !02249S0T
                                                                       !02249K08
                                                                       !02250K00
                                                                       !D0225000
                                                                       !D0225001
    prevrfyd^pin[0] ':=' prevrfy^pin^pad^char^g for 1 &                !D0225002
                         prevrfyd^pin[0] for                           !D0225003
                         $occurs( prevrfyd^pin ) - 1;                  !D0225004
    if psem.pin = prevrfyd^pin for $len( psem.pin ) then               !D0225005
                                                                       !D0225006
        begin                                                          !02251-02
                                                                       !F0225100
        pstm.pin^tries ':=' "Z";                                       !F0225101
                                                                       !F0225102
        end                                                            !02251-04
    else                                                               !02251-05
                                                                       !02251-06
                                                                       !D0225107
       if psem.pin <> [ $len( psem.pin ) * [ " " ] ] then              !D0225108
                                                                       !D0225109
                                                                       !D0225200
                                                                       !D0225201
                                                                       !D0225202
        begin                                                          !02254
                                                                       !02255K00
                                                                       !02255K01
                                                                       !02255K02
                                                                       !02255L00
        while ( ( epin^lgth := epin^lgth + 1 ) < max^pin^lgth^l ) and  !02255L01
                                                                       !02255L02
                                                                       !02258L00
                                                                       !02258L01
            ( psem.pin.byte[ epin^lgth ] <> " " ) do;                  !02259
                                                                       !02260
        if  not util^frmt^ext^pin^to^int^pin( psem.pin, epin^lgth,     !02261
               pan, pan^lgth, pstm.pin, ipin^lgth, pstm.pin^key,       !02262
                                                                       !02262K00
               pstm.pin^frmt, pstm.ansi^ofst, pstm.pinpad^char,        !02262K01
               pstm.user^key, sec^dev^resp )               or          !02262K02
            not integer^ascii^( pstm.pin^size, ipin^lgth ) then        !02262K03
            begin                                                      !02262K04
            if sec^dev^resp = sanity^chk^err^l and                     !02262K05
                                                                       !02262U00
               ( pct.options.version^num = "60" or                     !02262U01
                 pct.options.version^num = "01" ) then                 !02262U02
                                                                       !02262U03
                                                                       !02262U04
                                                                       !02262U05
                begin                                                  !02262K07
                movd( err^flg, "S" );                                  !02262K08
                call integer^ascii^( pstm.tran.resp^cde,               !02262K09
                                     pstm^resp^unable^to^auth^l );     !02262K0A
                                                                       !02262K0B
                if psem.pri^rsrvd4^prvt.len <> "000" and               !02262K0C
                   psem.pri^rsrvd4^prvt.len <> "   " then              !02262K0D
                    shift^ext^fld^d( psem.pri^rsrvd4^prvt,             !02262K0E
                                     ext^lgth^i );                     !02262K0F
                call hiswtkn^set^ps50^tkn( ext^data^fld^i,             !02262K0G
                                                                       !02262M00
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02262M01
                                                                       !02262M02
                                                                       !02262M03
                                                                       !02262M04
                                 0, true, ext^lgth^i,, err^flg );      !02262K0I
                reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );   !02262K0J
                end;                                                   !02262K0K
            if not resp^cde then                                       !02262K0L
                set( resp^cde, pos^resp^system^err^l );                !02262K0M
            end;                                                       !02262K0N
                                                                       !02262K0O
                                                                       !02263K00
                                                                       !02263K01
                                                                       !02263K02
                                                                       !02263L00
        end;                                                           !02263L01
                                                                       !02263L02
                                                                       !02266L00
                                                                       !02266L01
                                                                       !02267
                                                                       !02268L00
                                                                       !02268L01
                                                                       !02269
                                                                       !02269L00
    ! Verify the requested amount                                     !
                                                                       !02269L03
                                                                       !02270L00
                                                                       !02270L01
                                                                       !02270e00
    !                                                                 !!02270e01
    ! Verify that the acquirer currency code matches the shared       !!02270e02
    ! currency.                                                       !!02270e03
    !                                                                 !!02270e04
                                                                       !02270q00
    if pct.options.mult^crncy = "N" and                                !02270q01
       base24^rel^g >= 6            then                               !02270q02
                                                                       !02270q03
        begin                                                          !02270e06
        if psem.setl^crncy <>                                          !02270e07
               [ $len( psem.setl^crncy ) * [ " " ] ] then              !02270e08
            begin                                                      !02270e09
            if psem.setl^crncy <>                                      !02270e0A
                   pct.crncy^cde for $len( pct.crncy^cde ) then        !02270e0B
                begin                                                  !02270e0C
                if not resp^cde then                                   !02270e0D
                    begin                                              !02270e0E
                    set( resp^cde, pos^resp^system^err^l );            !02270e0F
                    end;                                               !02270e0G
                end;                                                   !02270e0H
                                                                       !02270i00
            end                                                        !02270i01
        else                                                           !02270i02
                                                                       !02270i03
                                                                       !02270i04
                                                                       !02270i05
                                                                       !02270i06
        if psem.crncy^cde <>                                           !02270e0K
               pct.crncy^cde for $len( pct.crncy^cde ) then            !02270e0L
            begin                                                      !02270e0M
            if not resp^cde then                                       !02270e0N
                begin                                                  !02270e0O
                set( resp^cde, pos^resp^system^err^l );                !02270e0P
                end;                                                   !02270e0Q
            end;                                                       !02270e0R
        end;                                                           !02270e0S
                                                                       !02270e0T
                                                                       !02271
                                                                       !02271L00
    if  not pos^frmt^sem^to^pstm^amt( sem, pstm ) then                 !02271L01
        if  not resp^cde then                                          !02271L02
            set( resp^cde, pos^resp^inv^amt^l );                       !02271L03
                                                                       !02271L04
                                                                       !02272L00
                                                                       !02272L01
                                                                       !02272L02
                                                                       !02283
    if  pos^adjustment^d( sem ) then                                   !02284
        begin                                                          !02285
                                                                       !02286L00
                                                                       !02286L01
                                                                       !02286L02
                                                                       !02289
        if  pstm.tran.amt^2 > pstm.tran.amt^1 then                     !02290
            move ( pstm.adj^flg, pos^pct.adj^flg );                    !02291
                                                                       !02292
        use i; i := -1;                                                !02293
        while sem^adj^code^d( i := i + 1 ) and psem.resp^cde  <>       !02294
              sem^adj^code^d( i ) for $len( psem.resp^cde ) do;        !02295
                                                                       !02296
        if  not sem^adj^code^d ( i )  then                             !02297
            movd ( pstm.rvsl^cde, "00" )                               !02298
        else                                                           !02299
            movl ( pstm.rvsl^cde, pstm^adj^code^d( i ),                !02300
               $len( pstm.rvsl^cde ) );                                !02301
        drop i;                                                        !02302
        end;                                                           !02303
                                                                       !02303K00
                                                                       !02303K01
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02303K02
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02303K03
                                                                       !02303U00
       ( pct.options.version^num = "60" or                             !02303U01
         pct.options.version^num = "01" ) then                         !02303U02
                                                                       !02303U03
                                                                       !02303U04
                                                                       !02303U05
        begin                                                          !02303K05
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02303K06
                                                                       !02303K07
        movd( tkn^id,   addr^ver^tkn^id^d );                           !02303K08
        !!                                                             !02303K09
        !get the address verification from the external message!       !02303K0A
        !!                                                             !02303K0B
        error := tkn^get^info( ext^data^fld^i, 0,                      !02303K0C
                                                                       !02303M00
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02303M01
                                                                       !02303M02
                                                                       !02303M03
                                                                       !02303M04
                               tkn^id, @addr^ver^tkn, tkn^lgth,        !02303K0E
                               true );                                 !02303K0F
        if error = compl^no^err^l then                                 !02303K0G
            begin                                                      !02303K0H
            !!                                                         !02303K0I
            !if address verification token was found!                  !02303K0J
            !move the information into the pstm fields!                !02303K0K
            !!                                                         !02303K0L
            mov^( pstm.addr^flds.addr, addr^ver^tkn.addr    );         !02303K0M
            mov^( pstm.zip^cde,        addr^ver^tkn.zip^cde );         !02303K0N
            movd( pstm.addr^typ,       av^addr^typ^d        );         !02303K0O
            end                                                        !02303K0P
        else                                                           !02303K0Q
        if error <> tkn^does^not^exist^l then                          !02303K0R
            begin                                                      !02303K0S
            call logmessage^( 1088,, @get^err, net.myname, 3,          !02303K0T
                              @pos^prod^g, @tkn^id );                  !02303K0U
                                                                       !02303}00
            if not resp^cde then                                       !02303}01
                begin                                                  !02303}02
                set( resp^cde, pos^resp^frmt^err^l );                  !02303}03
                end;                                                   !02303}04
                                                                       !02303}05
            end;                                                       !02303K0W
                                                                       !O0230300
        if psem.setl^crncy =                                           !O0230301
                    [ $len( psem.setl^crncy ) * [ " " ] ] then         !O0230302
            begin                                                      !O0230303
            movd( tkn^id, pos^data1^tkn^id^d );                        !O0230304
            error := tkn^get^info ( ext^data^fld^i,                    !O0230305
                                    0,                                 !O0230306
                                    $len( pos^data1^tkn ),             !O0230307
                                    tkn^id,                            !O0230308
                                    @pos^data1^tkn,                    !O0230309
                                    tkn^lgth,                          !O023030A
                                    true );                            !O023030B
                                                                       !O023030C
            if error = compl^no^err^l then                             !O023030D
                begin                                                  !O023030E
                mov^( pstm.pre^auth^opt,                               !O023030F
                    pos^data1^tkn.partial^auth^opt );                  !O023030G
                end;                                                   !O023030H
            end;                                                       !O023030I
                                                                       !O023030J
                                                                       !O023030K
                                                                       !O023030L
                                                                       !O023030M
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02303K0Y
        end;                                                           !02303K0Z
                                                                       !02303K10
                                                                       !02303W00
                                                                       !02303W01
                                                                       !02303W02
                                                                       !02303W03
                                                                       !02303W04
                                                                       !02303W05
                                                                       !02303W06
                                                                       !02303W07
                                                                       !02303W08
                                                                       !02303W09
                                                                       !02303W0A
                                                                       !02303W0B
                                                                       !02303W0C
                                                                       !02303W0D
                                                                       !02303S0C
                                                                       !02303K1C
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02303K1D
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02303K1E
                                                                       !02303U0B
       ( pct.options.version^num = "60" or                             !02303U0C
         pct.options.version^num = "01" ) then                         !02303U0D
                                                                       !02303U0E
                                                                       !02303U0F
                                                                       !02303U0G
        begin                                                          !02303K1G
        !!                                                             !02303K1H
        !delete address verification token from interal message!       !02303K1I
        !if it was in the external msg and formatted to the internal!  !02303K1J
        !!                                                             !02303K1K
        if pstm.data^flag = "0" then                                   !02303K1L
            movd( userdata, false )                                    !02303K1M
        else                                                           !02303K1N
            movd( userdata, true );                                    !02303K1O
                                                                       !02303K1P
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !02303K1Q
                               intrn^msg^lmt^l,                        !02303K1R
                               tkn^id,,, userdata );                   !02303K1S
                                                                       !02303K1T
        if error <> compl^no^err^l       and                           !02303K1U
           error <> tkn^does^not^exist^l then                          !02303K1V
            begin                                                      !02303K1W
            call logmessage^( 1092,, @del^err, net.myname,             !02303K1X
                              3, @pos^prod^g, @tkn^id );               !02303K1Y
            call abend^( 1725 );                                       !02303K1Z
            end;                                                       !02303K20
        end;                                                           !02303K21
                                                                       !02303K22
!*******************************************************************!
! BEGIN RPQ #ID001 - Manejo Especial Campo P42                      !
!*******************************************************************!
    pstm.zip^cde.byte[0] ':='
                 psem.crd^accpt^id^cde.byte[11] for 4;
    tkn^id ':=' rpq^p42^tkn^id^d;                ! "ID"
    rpq^p42^tkn.campo^p42.byte[0] ':='
                 psem.crd^accpt^id^cde.byte[0] for 15;
    rpq^p42^tkn.user^p42.byte[0]  ':='
                 psem.crd^accpt^id^cde.byte[0] for 2;
    rpq^p42^tkn.user^p42.byte[2]  ':=' "00";
    rpq^p42^tkn.user^p42.byte[4]  ':='
                 psem.crd^accpt^id^cde.byte[2] for 10;
    tkn^ofst^g := $offset(pstm.srvcs[0]) +
               $min(($len(pstm.srvcs[0]) * pstm.num^services),
                    ($len(pstm.srvcs[0]) * $occurs(pstm.srvcs)));

    if pstm.data^flag = "0" then
       pos^user^data^flag := false
    else
     begin
      pos^user^data^flag := true;
     end;
    tkn^util^val := tkn^add^info(pstm, tkn^ofst^g,
                                 intrn^msg^lmt^l, tkn^id,
                                 rpq^p42^tkn,
                                 $len( rpq^p42^tkn ),,,,,
                                 pos^user^data^flag);
    if tkn^util^val <> compl^no^err^l and
       tkn^util^val <> tkn^exist^l then
       begin
        call logmessage^(5003,, @add^err,,3,@pos^prod^g, @tkn^id);
       end;
!*******************************************************************!
! END    RPQ #ID001 - Manejo Especial Campo P42                     !
!*******************************************************************!
!*******************************************************************!
!   BEGIN RPQ #25 - Bill Payment                   MCD / 2269       !
!-------------------------------------------------------------------!
    if psem.pt^tran^spcl^cde = "15" and
       ( pstm^inquiry^d( pstm ) or
         pstm^^purchase^d ) then
       begin
       tkn^id ':=' rpq^bill^pymt^tkn^id^d ;
       rpq^bill^pymt^buf ':=' (($len(rpq^bill^pymt^buf))/2)
                                          * ["  "];
       rpq^bill^pymt^buf.city^cde ':='
                 psem.pri^rsrvd1^natl.bill^pay^info.city^cde for
            $len( rpq^bill^pymt^buf.city^cde);
       rpq^bill^pymt^buf.vendor^type ':='
                 psem.pri^rsrvd1^natl.bill^pay^info.vendor^type for
            $len( rpq^bill^pymt^buf.vendor^type);

       txt^lgth :=
          $len(psem.pri^rsrvd1^natl.bill^pay^info.amount);
       stat := ascii^fixed
               (psem.pri^rsrvd1^natl.bill^pay^info.amount,
                txt^lgth, rpq^bill^pymt^buf.amount);
       if not stat then
          begin
          call logmessage^(5000,,@conv^err,,3, @pos^prod^g);
          if not resp^cde then
             set (resp^cde, pos^resp^inv^amt^l);
          end;

       rpq^bill^pymt^buf.invoice^num ':='
            psem.pri^rsrvd1^natl.bill^pay^info.invoice^num for
            $len( rpq^bill^pymt^buf.invoice^num);
       rpq^bill^pymt^buf.vendor^id ':='
            psem.pri^rsrvd1^natl.bill^pay^info.vendor^id for
            $len( rpq^bill^pymt^buf.vendor^id);
       rpq^bill^pymt^buf.merchant^id ':='
            psem.pri^rsrvd1^natl.bill^pay^info.merchant^id for
            $len( rpq^bill^pymt^buf.merchant^id);
       rpq^bill^pymt^buf.due^date ':='
            psem.pri^rsrvd1^natl.bill^pay^info.due^date for
            $len( rpq^bill^pymt^buf.due^date);
       rpq^bill^pymt^buf.fax^num ':='
            psem.pri^rsrvd1^natl.bill^pay^info.fax^num for
            $len( rpq^bill^pymt^buf.fax^num);
       rpq^bill^pymt^buf.paid^flg ':='
            psem.pri^rsrvd1^natl.bill^pay^info.paid^flg for
            $len(rpq^bill^pymt^buf.paid^flg);

!*********************************************************************!
!* BEGIN RPQ #25A-Bill Payment                                       *!
!---------------------------------------------------------------------!
       rpq^bill^pymt^buf.telecode^number ':='
            psem.pri^rsrvd1^natl.bill^pay^info.telecode^number for
            $len( rpq^bill^pymt^buf.telecode^number );
       rpq^bill^pymt^buf.cvv2            ':='
            psem.pri^rsrvd1^natl.bill^pay^info.cvv2 for
            $len( rpq^bill^pymt^buf.cvv2 );

       rpq^bill^pymt^buf.cardholder^id   ':='
            psem.pri^rsrvd2^natl.bill^pay^info.cardholder^id for
            $len( rpq^bill^pymt^buf.cardholder^id );
!---------------------------------------------------------------------!
!* END   RPQ #25A-Bill Payment                                       *!
!*********************************************************************!

       tkn^ofst^g := $offset(pstm.srvcs[0]) +
               $min(($len(pstm.srvcs[0]) * pstm.num^services),
                    ($len(pstm.srvcs[0]) * $occurs(pstm.srvcs)));

       if pstm.data^flag = "0" then
          pos^user^data^flag := false
       else
          begin
          pos^user^data^flag := true;
          end;
       tkn^util^val := tkn^add^info(pstm, tkn^ofst^g,
                                    intrn^msg^lmt^l, tkn^id,
                                    rpq^bill^pymt^buf,
                                    $len( rpq^bill^pymt^buf ),,,,,
                                    pos^user^data^flag);

       if tkn^util^val <> compl^no^err^l and
          tkn^util^val <> tkn^exist^l then
          begin
          call logmessage^(5003,, @add^err,,3,@pos^prod^g, @tkn^id);
          if not resp^cde then
             set(resp^cde, pos^resp^system^err^l);
          end;
       end;
!---------------------------------------------------------------------!
!    RPQ #25 - Bill Payment                        MCD / 2269         !
!*********************************************************************!

    return resp^cde;                                                   !02303K23
                                                                       !02303K24
                                                                       !02304K00
                                                                       !02304K01
                                                                       !02304K02
    end;                                                               !02306
?section pos^frmt^sem^to^pstm^0210                                     !02307
?page "                               - pos^frmt^sem^to^pstm^0210"     !02307K00
!#####################################################################!!02310
!#                                                                   #!!02311
!#                      POS^FRMT^SEM^TO^PSTM^0210                    #!!02312
!#                                                                   #!!02313
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0210 SEM TO AN INTERNAL   #!!02314
!#       0210 RESPONSE MESSAGE.                                      #!!02315
!#                                                                   #!!02316
!#    INPUT PARAMETERS :                                             #!!02317
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!!02318
!#                                                                   #!!02319
!#    OUTPUT PARAMETERS:                                             #!!02320
!#       PSTM          : POINTER TO IMTERNAL MESSAGE                 #!!02321
                                                                       !02321K00
                                                                       !O0232100
                                                                       !O0232101
                                                                       !O0232102
                                                                       !02321K03
!#                                                                   #!!02322
!#####################################################################!!02323
                                                                       !02323H00
                                                                       !O0232300
int proc pos^frmt^sem^to^pstm^0210( sem, pstm );                       !O0232301
                                                                       !O0232302
                                                                       !02323H02
                                                                       !02324H00
                                                                       !02324H01
int .sem(  sem^def  );                                                 !02325
int .pstm( pstm^def );                                                 !02326
                                                                       !02326H00
                                                                       !O0232600
                                                                       !O0232601
                                                                       !02326H02
                                                                       !02326H03
    begin                                                              !02327
                                                                       !02327K00
    wlform( del^err,                                                   !02327K01
        "Error while attempting to delete token \\ from the PSTM " )   !02327K02
    wlform( get^err, "Error while attempting to get token \\ " )       !02327K03
                                                                       !02327K04
                                                                       !02328
    define  sem^code^d( i )  =  resp^tbl[ ( i ) * 5 + 0 ] #,           !02329
            pstm^code^d( i ) =  resp^tbl[ ( i ) * 5 + 2 ] #;           !02330
                                                                       !02331
    string  resp^tbl  = 'P' :=  [                                      !02332
        !                                                             !!02333
        ! BICI      PSTM                                              !!02334
        ! Codes     Codes                                             !!02335
        !  .         .                                                !!02336
        !  .         .                                                !!02337
        !  v         v                                                !!02338
                                                                       !02339
                                                                       !02339M00
         "00",     "001",  ! approved - balances are not present!      !02339M01
         "00",     "000",  ! approved - balance avail!                 !02339M02
                                                                       !02339M03
                                                                       !02340M00
                                                                       !02340M01
                                                                       !02340M02
                                                                       !02342X00
         "01",     "101",  ! issue call                               !!02342X01
                                                                       !02342X02
         "02",     "101",  ! issue call                               !!02343
         "03",     "150",  ! merchant not on file                     !!02344
         "04",     "909",  ! capture                                  !!02345
         "05",     "050",  ! decline                                  !!02346
         "06",     "100",  ! unable to process transaction            !!02347
                                                                       !02347K00
         "07",     "909",  ! pick-up card special condition!           !02347K01
                                                                       !02347K02
                                                                       !02348K00
                                                                       !02348K01
         "08",     "003",  ! approved - maybe more id                 !!02349
                                                                       !02349F00
         "09",     "078",  ! request in progress                      !
                                                                       !02349F03
                                                                       !J0235000
         "10",     "000",  ! partial approval                         !!J0235001
                                                                       !J0235002
                                                                       !02350F01
         "11",     "006",  ! approved - vip                           !!02351
         "12",     "055",  ! invalid transaction                      !!02352
                                                                       !J0235300
         "13",     "205",  ! invalid advance amount                   !!J0235301
                                                                       !J0235302
         "14",     "058",  ! invalid card number/no such number       !!02354
         "15",     "070",  ! no idf                                   !!02355
         "30",     "069",  ! bad message edit                         !!02356
         "31",     "053",  ! no sharing                               !!02357
         "33",     "901",  ! expired card                             !!02358
                                                                       !02358F00
         "34",     "909",  ! suspected fraud pick up                  !
         "35",     "909",  ! card acceptor contact acquirer, pick-up  !
                                                                       !02358F05
                                                                       !02359F00
                                                                       !02359F01
                                                                       !02359F02
         "36",     "902",  ! restricted card pick up                  !!02361
                                                                       !02361F00
         "37",     "909",  ! card acceptor call acquirer security, pic!
                                                                       !02361F03
                                                                       !02362F00
                                                                       !02362F01
         "38",     "900",  ! pin tries exceeded                       !!02363
         "39",     "050",  ! decline                                  !!02364
         "41",     "057",  ! lost  card  pick up                      !!02365
         "43",     "903",  ! stolen card pick up                      !!02366
         "51",     "076",  ! not sufficient funds                     !!02367
         "54",     "051",  ! expired card                             !!02368
         "55",     "201",  ! incorrect pin                            !!02369
         "56",     "206",  ! no card record                           !!02370
         "57",     "056",  ! no support                               !!02371
         "58",     "055",  ! invalid transaction                      !!02372
         "61",     "095",  ! exceeds withdrawal amount limit          !!02373
         "62",     "059",  ! restricted                               !!02374
         "65",     "082",  ! exceeds withdrawal frequency limit       !!02375
         "68",     "113",  ! no pbf                                   !!02376
         "75",     "052",  ! pin tries exceeded                       !!02377
         "76",     "002",  ! approved - country club                  !!02378
         "77",     "004",  ! approved - pending identification        !!02379
         "78",     "005",  ! approved - blind                         !!02380
         "79",     "007",  ! approved - admin tran                    !!02381
         "80",     "008",  ! approved - national neg hit okay         !!02382
         "81",     "009",  ! approved - commercial                    !!02383
         "82",     "054",  ! no atalla box                            !!02384
         "83",     "060",  ! no accounts                              !!02385
         "84",     "061",  ! no pbf                                   !!02386
         "85",     "062",  ! pbf update error                         !!02387
         "86",     "063",  ! invalid auth type                        !!02388
         "87",     "064",  ! bad track 2 data                         !!02389
         "88",     "068",  ! ptlf errorull                            !!02390
         "89",     "073",  ! invalid route service                    !!02391
                                                                       !02391F00
         "90",     "074",  ! destination not available                !
         "91",     "074",  ! destination not available                !
                                                                       !02391F05
                                                                       !02392F00
                                                                       !02392F01
                                                                       !02392F02
         "92",     "050",  ! decline                                  !!02394

!@ ==========================================================!
!@ BEGIN RPQ #240 Special Response Code for Invalid MAC
         "93",     "964",  ! invalid mac error
!@ END   RPQ #240 Special Response Code for Invalid MAC
!@ ==========================================================!

         "94",     "078",  ! duplicate transaction                    !!02395
                                                                       !02395F00
         "96",     "100",  ! system malfunction                       !
                                                                       !02395F03
                                                                       !02396F00
                                                                       !02396F01
         "S4",     "115",  ! ptlf is full                             !!02397
         "S5",     "960",  ! approved, customer files updated         !!02398
         "S6",     "961",  ! approved, customer files not updated     !!02399
         "S7",     "962",  ! accepted, incorrect destination          !!02400
         "S8",     "121",  ! Admin File problem                       !!02401
         "S9",     "122",  ! Unable to validate PIN, sec box is down  !!02402
         "T1",     "066",  ! Invalid Credit card advance increment    !!02403
         "T2",     "067",  ! Invalid tran date                        !!02404
         "T3",     "105",  ! Card not supported                       !!02405
         "T4",     "106",  ! Amount over max                          !!02406
         "T5",     "089",  ! CAF Status 0-9                           !!02407
         "T6",     "120",  ! Bad UAF                                  !!02408
                                                                       !J0240900
         "T7",     "251",  ! Purchase with cash back                  !!J0240901
                                                                       !J0240902
         "T8",     "200",  ! Error - account problem                  !!02410
         "N0",     "074",  ! unable to authorize                      !!02411
         "N1",     "075",  ! invalid pan length                       !!02412
         "N2",     "077",  ! pre auth full                            !!02413
         "N3",     "079",  ! max online refund reached                !!02414
         "N4",     "080",  ! max offline refund reached               !!02415
         "N5",     "081",  ! max credit per refund                    !!02416
         "N6",     "083",  ! max refund credit reached                !!02417
         "N7",     "084",  ! customer selected neg reason             !!02418
         "N8",     "086",  ! over floor limitth                       !!02419
         "N9",     "087",  ! max num refund credit                    !!02420
         "O0",     "090",  ! refferal file full                       !!02421
         "O1",     "091",  ! neg file problem                         !!02422
         "O2",     "092",  ! advance less than minimum                !!02423
         "O3",     "093",  ! refferal file full                       !!02424
         "O4",     "094",  ! over limit table                         !!02425
         "O5",     "096",  ! pin required                             !!02426
         "O6",     "097",  ! mod 10 check                             !!02427
         "O7",     "098",  ! force post                               !!02428
         "O8",     "099",  ! bad pbf                                  !!02429
         "O9",     "103",  ! neg file problem                         !!02430
         "P0",     "104",  ! caf file problem                         !!02431
         "P1",     "107",  ! over daily limit                         !!02432
         "P2",     "108",  ! capf not found                           !!02433
         "P3",     "109",  ! advance less than min                    !!02434
         "P4",     "110",  ! num times used                           !!02435
         "P5",     "111",  ! delinquent                               !!02436
         "P6",     "112",  ! over limit table                         !!02437
         "P7",     "202",  ! advance less than min                    !!02438
         "P8",     "203",  ! admun card needed                        !!02439
         "P9",     "204",  ! enter lesser amount                      !!02440
                                                                       !02441
         "Q0",     "207",  ! invalid tran date                        !!02442
         "Q1",     "208",  ! invalid expiration date                  !!02443
         "Q2",     "209",  ! invalid tran code                        !!02444
         "Q3",     "904",  ! advance less than min                    !!02445
         "Q4",     "905",  ! num times usedmount                      !!02446
         "Q5",     "906",  ! delinquent                               !!02447
         "Q6",     "907",  ! over limit table                         !!02448
         "Q7",     "908",  ! amount over maxount                      !!02449
         "Q8",     "950",  ! admin card not found                     !!02450
         "Q9",     "951",  ! admin card not allowed                   !!02451
         "R0",     "952",  ! approved admin request / in window       !!02452
         "R1",     "953",  ! approved admin request / out of window   !!02453
         "R2",     "954",  ! approved admin request / anytime         !!02454
         "R3",     "955",  ! chargeback / customer file updated       !!02455
         "R4",     "956",  ! chargeback / cust.file updated / acq.not !!02456
         "R5",     "957",  ! chargeback / incorrect prefix number     !!02457
         "R6",     "958",  ! chargeback / incorrect response code or c!!02458
         "R7",     "959",  ! admin tranx. not supported               !!02459
         "R8",     "072",  ! card on national neq file                !!02460
            0 ];                                                       !02461
                                                                       !02462
                                                                       !02462K00
    struct                                                             !02462K01
           .ps50^tkn( ps50^tkn^def );                                  !02462K02
                                                                       !02462K03
    string                                                             !02462K04
            err^flg,                                                   !02462K05
           .post^dat[ 0:5 ],                                           !02462K06
           .tkn^id[ 0:1 ];                                             !02462K07
                                                                       !02462K08
    int                                                                !02462K09
            error,                                                     !02462K0A
           .ext^data^fld^i := wordaddr( @psem.pri^rsrvd4^prvt.data ),  !02462K0B
            ext^lgth^i,                                                !02462K0C
            tkn^frmt^err := 0,                                         !02462K0D
            tkn^lgth,                                                  !02462K0E
            userdata;                                                  !02462K0F
                                                                       !02462K0G
                                                                       !02463K00
                                                                       !02463K01
                                                                       !02463H00
                                                                       !O0246300
    fixed   psem^fixed^tran^amt := 0f;                                 !O0246301
                                                                       !O0246302
                                                                       !02463H02
                                                                       !02464
    movd ( pstm.typ,       tran^response^d );                          !02465
    movd ( pstm.responder, switch^origin^d );                          !02466
                                                                       !02467
    call util^frmt^inst^id( pstm.crd^iss^id^num,                       !02468
       ssem.secndry^rsrvd3^prvt.len.byte[1],                           !02469
       ssem.secndry^rsrvd3^prvt.b24.crd^iss^id^num, 1 );               !02470
                                                                       !02471
    call util^frmt^inst^id( pstm.rcv^inst^id^num,                      !02472
        ssem.rcv^inst.len, ssem.rcv^inst.id^num, 1 );                  !02473
                                                                       !02473j00
    if ovrrd^rcv^inst^id^d and                                         !02473j01
       pstm.rcv^inst^id^num =                                          !02473j02
           [ $len( pstm.rcv^inst^id^num ) * [ "0" ] ] then             !02473j03
        begin                                                          !02473j04
        !                                                             !!02473j05
        ! Move pct.acq^id^num (right justified, zero filled) into     !!02473j06
        ! pstm.rcv^inst^id^num (right justified, zero filled)         !!02473j07
        !                                                             !!02473j08
        mov^( pstm.rcv^inst^id^num, pct.acq^id^num );                  !02473j09
        end;                                                           !02473j0A
                                                                       !02473j0B
                                                                       !02473)00
    if psem.mbr^num <> zeroes for $len( psem.mbr^num ) and             !02473)01
       psem.mbr^num <> blanks for $len( psem.mbr^num ) then            !02473)02
        begin                                                          !02473)03
        pstm.tran.mbr^num ':=' psem.mbr^num for $len( psem.mbr^num );  !02473)04
        end;                                                           !02473)05
                                                                       !02473)06
                                                                       !02474
    call hiswutil^mmdd^to^yymmdd( psem.setl^dat, post^dat );           !02475
    if  pstm.iss^ichg^setl^dat '<>' post^dat                           !02476
            for $len( pstm.iss^ichg^setl^dat ) and                     !02477
        util^ilf^dat( psem.setl^dat ) then                             !02478
        mov^ ( pstm.iss^ichg^setl^dat, post^dat );                     !02479
                                                                       !02480
                                                                       !02480M00
    if  pstm.tran.tran^cde.tc = "10"  and                              !02480M01
        pstm.tran.tran^cde.aa = "00"  then                             !02480M02
        call pos^frmt^sem^to^pstm^tran( sem, pstm );                   !02480M03
                                                                       !02480M04
                                                                       !02480M05
    if  psem.pri^rsrvd2^prvt.pos.ichg^resp <> blanks for 8 then        !02481
                                                                       !02481=00
         begin                                                         !02481=01
         move ( pstm.tran.ichg^resp,                                   !02481=02
                psem.pri^rsrvd2^prvt.pos.ichg^resp );                  !02481=03
         end                                                           !02481=04
    else                                                               !02481=05
         begin                                                         !02481=06
         move ( pstm.tran.ichg^resp, psem.resp^cde );                  !02481=07
         end;                                                          !02481=08
                                                                       !02481{00
                                                                       !02481{01
                                                                       !02481{02
                                                                       !02484L01
                                                                       !O0248400
    if  not pos^frmt^sem^to^pstm^amt( sem, pstm ) then                 !O0248401
                                                                       !O0248402
        return false;                                                  !02484L03
                                                                       !02484L04
                                                                       !02484L05
                                                                       !02484L06
                                                                       !02484L07
                                                                       !02484b00
    mov^ ( pstm.tran.apprv^cde, blanks );                              !02484b01
                                                                       !02484b02
    move ( pstm.tran.apprv^cde,  psem.auth^id^resp );                  !02488
                                                                       !02489
    if  not pos^frmt^sem^to^pstm^acct( sem, pstm ) then                !02490
        return false;                                                  !02491
                                                                       !02491M00
    !                                                                 !
    ! Format orig data for possible reversal use later                !
    !                                                                 !
                                                                       !02491+00
                                                                       !02491+01
    mov^( pstm.orig^data,              zeroes              );          !02491+02
    movl( pstm.orig^data.msg^typ,      psem.typ, 2         );          !02491+03
    move( pstm.orig^data.tran^seq^num, psem.retrvl^ref^num );          !02491+04
    move( pstm.orig^data.trn^dat,      psem.tran^dat       );          !02491+05
    move( pstm.orig^data.trn^tim,      psem.tran^tim       );          !02491+06
    move( pstm.orig^data.b24^post^dat, psem.cap^dat        );          !02491+07
                                                                       !02491+08
                                                                       !02491M0D
                                                                       !02492
    !                                                                 !!02493
    ! Convert the response codes                                      !!02494
    !                                                                 !!02495
    use i; i := -1;                                                    !02496
    while sem^code^d( i:=i+1 ) and psem.resp^cde  <>                   !02497
          sem^code^d( i ) for 2 do;                                    !02498
                                                                       !02499
    if  not sem^code^d( i ) then                                       !02500
                                                                       !02500j00
        begin                                                          !02500j01
        pstm.tran.resp^cde ':=' "050";                                 !02500j02
        call pos^util^frmt^enhanced^rc( sem, pstm, ext^to^int^l );     !02500j03
        end                                                            !02500j04
                                                                       !02500j05
                                                                       !02501j00
                                                                       !02501j01
    else                                                               !02502
        pstm.tran.resp^cde ':=' pstm^code^d( i ) for                   !02503
            $len( pstm.tran.resp^cde );                                !02504
    drop i;                                                            !02505
                                                                       !02505M00
    if  pstm.tran.resp^cde = "001" and                                 !02505M01
        pos^inquiry^d ( sem ) then                                     !02505M02
        movd ( pstm.tran.resp^cde, "000" );                            !02505M03
                                                                       !O0250500
    call all^ascii^fixed^( psem.tran^amt, psem^fixed^tran^amt );       !O0250501
                                                                       !O0250502
    if pstm.pre^auth^opt <> "P"              and                       !O0250503
       pstm.pre^auth^opt <> "p"              and                       !O0250504
       pstm.pre^auth^opt <> "G"              and                       !O0250505
       pstm.pre^auth^opt <> "g"              and                       !O0250506
       psem^fixed^tran^amt < pstm.tran.amt^1 and                       !O0250507
       pstm^approved^d( pstm )               and                       !O0250508
       not pstm^inquiry^d( pstm )            then                      !O0250509
        begin                                                          !O025050A
        !                                                             !!O025050B
        ! Transaction was incorrectly approved for a lesser amount.   !!O025050C
        !                                                             !!O025050D
        movd( pstm.tran.resp^cde, "076" );                             !O025050E
        return false;                                                  !O025050F
        end                                                            !O025050G
    else                                                               !O025050H
    if pstm.pre^auth^opt <> "P"              and                       !O025050I
       pstm.pre^auth^opt <> "p"              and                       !O025050J
       pstm.pre^auth^opt <> "G"              and                       !O025050K
       pstm.pre^auth^opt <> "g"              and                       !O025050L
       psem^fixed^tran^amt > pstm.tran.amt^1 and                       !O025050M
       pstm^approved^d( pstm )               and                       !O025050N
       not pstm^inquiry^d( pstm )            then                      !O025050O
        begin                                                          !O025050P
        !                                                             !!O025050Q
        ! Transaction was incorrectly approved for a greater amount.  !!O025050R
        !                                                             !!O025050S
        movd( pstm.tran.resp^cde, "076" );                             !O025050T
        return false;                                                  !O025050U
        end                                                            !O025050V
    else                                                               !O025050W
    if ( pstm.pre^auth^opt = "P"              or                       !O025050X
         pstm.pre^auth^opt = "p"              or                       !O025050Y
         pstm.pre^auth^opt = "G"              or                       !O025050Z
         pstm.pre^auth^opt = "g" )            and                      !O025050a
       ( psem^fixed^tran^amt <> pstm.tran.amt^1 or                     !O025050b
         psem.resp^cde = "10" )               and                      !O025050c
       pstm^approved^d( pstm )                and                      !O025050d
       not pstm^inquiry^d( pstm )             and                      !O025050e
       psem.setl^crncy <> [ $len( psem.setl^crncy ) * [" "] ] then     !O025050f
        begin                                                          !O025050g
        !                                                             !!O025050h
        ! Transaction was incorrectly approved for a different amount !!O025050i
        ! than requested and settlement amount is present.            !!O025050j
        !                                                             !!O025050k
        movd( pstm.tran.resp^cde, "076" );                             !O025050l
        return false;                                                  !O025050m
        end;                                                           !O025050n
                                                                       !O025050o
    if ( pstm.pre^auth^opt = "P"             or                        !O025050p
         pstm.pre^auth^opt = "p"             or                        !O025050q
         pstm.pre^auth^opt = "G"             or                        !O025050r
         pstm.pre^auth^opt = "g" )           and                       !O025050s
       not pstm^inquiry^d( pstm )            and                       !O025050t
       psem^fixed^tran^amt < pstm.tran.amt^1 and                       !O025050u
       pstm^approved^d( pstm )               then                      !O025050v
        begin                                                          !O025050w
        !                                                             !!O025050x
        ! Transaction was approved for a lesser amount than requested.!!O025050y
        !                                                             !!O025050z
        if pstm^pur^d( pstm )      or                                  !O0250510
           pstm^pre^auth^d( pstm )      or                             !O0250511
           pstm^mail^phone^d ( pstm )   or                             !O0250512
           pstm^cash^adv^d ( pstm ) or                                 !O0250513
           pstm^cash^back^d( pstm )     then                           !O0250514
            begin                                                      !O0250515
            !                                                         !!O0250516
            ! Valid transaction for approval for lesser amount.       !!O0250517
            !                                                         !!O0250518
            pstm.tran.amt^1 := psem^fixed^tran^amt;                    !O0250519
                                                                       !O025051A
            if ( pstm^cash^back^d ( pstm )             or              !O025051B
                 pre^auth^cash^back^d( pstm ) )          and           !O025051C
               psem.add^amts.b24^def.amt <> blanks for                 !O025051D
                     $len( psem.add^amts.b24^def.amt ) then            !O025051E
                begin                                                  !O025051F
                !                                                     !!O025051G
                ! Cash Back transaction, populate Amount 2.           !!O025051H
                !                                                     !!O025051I
                call all^ascii^fixed^( psem.add^amts.b24^def.amt,      !O025051J
                                       pstm.tran.amt^2 );              !O025051K
                end;                                                   !O025051L
            end                                                        !O025051M
        else                                                           !O025051N
            begin                                                      !O025051O
            !                                                         !!O025051P
            ! Invalid transation for approval for lesser amount.      !!O025051Q
            !                                                         !!O025051R
            movd( pstm.tran.resp^cde, "076" );                         !O025051S
            return false;                                              !O025051T
            end;                                                       !O025051U
                                                                       !O025051V
         end                                                           !O025051W
     else                                                              !O025051X
     if ( pstm.pre^auth^opt = "P"              or                      !O025051Y
          pstm.pre^auth^opt = "p"              or                      !O025051Z
          pstm.pre^auth^opt = "G"              or                      !O025051a
          pstm.pre^auth^opt = "g" )            and                     !O025051b
        psem^fixed^tran^amt <> pstm.tran.amt^1 and                     !O025051c
        not pstm^inquiry^d( pstm )             and                     !O025051d
        pstm^approved^d( pstm )                then                    !O025051e
         begin                                                         !O025051f
         !                                                            !!O025051g
         ! Transaction was approved for greater amount than requested.!!O025051h
         !                                                            !!O025051i
         if  pstm^pur^d( pstm )            or                          !O025051j
             pstm^mail^phone^d ( pstm )         or                     !O025051k
           ( pstm^pre^auth^d( pstm )  and                              !O025051l
             not ( pre^auth^cash^back^d( pstm ) ) )  then              !O025051m
             begin                                                     !O025051n
             !                                                        !!O025051o
             ! Valid transaction for approval for greater amount.     !!O025051p
             !                                                        !!O025051q
             pstm.tran.amt^1 := psem^fixed^tran^amt;                   !O025051r
             end                                                       !O025051s
         else                                                          !O025051t
             begin                                                     !O025051u
             !                                                        !!O025051v
             ! Invalid transaction for approval for greater amount.   !!O025051w
             !                                                        !!O025051x
             movd( pstm.tran.resp^cde, "076" );                        !O025051y
             return false;                                             !O025051z
             end;                                                      !O0250520
        end;                                                           !O0250521
                                                                       !O0250522
                                                                       !02505M04
                                                                       !02505D00
                                                                       !02505D01
    !!                                                                 !02505D02
    ! Transfer address verification status!                            !02505D03
    !!                                                                 !02505D04
    if ( psem.resp^data.pos.addr^vrfy^stat <> zeroes ) and             !02505D05
        ( psem.resp^data.pos.addr^vrfy^stat <> blanks ) then           !02505D06
        begin                                                          !02505D07
        move( pstm.addr^flds.addr^vrfy^stat,                           !02505D08
              psem.resp^data.pos.addr^vrfy^stat );                     !02505D09
        movd( pstm.addr^typ, av^addr^typ^d );                          !02505D0A
        end;                                                           !02505D0B
                                                                       !02505D0C
                                                                       !02505K00
    !!                                                                 !02505K01
    !if response was approved and request contained!                   !02505K02
    !a pin then reset the pin.out^cons^err^cnt.!                       !02505K03
    !!                                                                 !02505K04
    if pstm.pin <> blanks for $len( pstm.pin ) and                     !02505K05
       pstm.pin <> zeroes for $len( pstm.pin ) and                     !02505K06
       pstm^approved^d( pstm )                then                     !02505K07
        begin                                                          !02505K08
        if pct.options.num^keys = 1 then                               !02505K09
            set( pct.pin.in^cons^err^cnt, 0 )                          !02505K0A
        else                                                           !02505K0B
            set( pct.pin.out^cons^err^cnt, 0 );                        !02505K0C
        end;                                                           !02505K0D
                                                                       !02505K0E
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02505K0F
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02505K0G
                                                                       !02505U00
       ( pct.options.version^num = "60" or                             !02505U01
         pct.options.version^num = "01" ) then                         !02505U02
                                                                       !02505U03
                                                                       !02505U04
                                                                       !02505U05
        begin                                                          !02505K0I
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02505K0J
                                                                       !02505K0K
        movd( tkn^id, ps50^tkn^id^d );                                 !02505K0L
        error := tkn^get^info( ext^data^fld^i, 0,                      !02505K0M
                                                                       !02505M05
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02505M06
                                                                       !02505M07
                                                                       !02505M08
                                                                       !02505M09
                               tkn^id, @ps50^tkn, tkn^lgth, true );    !02505K0O
        if error = compl^no^err^l and                                  !02505K0P
           ps50^tkn.err^flg = "S" then                                 !02505K0Q
            begin                                                      !02505K0R
            movd( ps50^tkn.err^flg, "R" );                             !02505K0S
            if pct.pin.pin^err^lmt > 0 then                            !02505K0T
                begin                                                  !02505K0U
                if pct.options.num^keys = "1" then                     !02505K0V
                    begin                                              !02505K0W
                    increment( pct.pin.in^err^cnt );                   !02505K0X
                    if pct.pin.in^err^cnt >                            !02505K0Y
                       pct.pin.pin^err^lmt then                        !02505K0Z
                        begin                                          !02505K10
                        call setbit( exchange^keys^g,                  !02505K11
                                     pin^both^keys^l );                !02505K12
                        set( pct.pin.in^err^cnt,      0  );            !02505K13
                        set( pct.pin.in^cons^err^cnt, 0  );            !02505K14
                        set( pct.pin.in^key^tran^cnt, 0d );            !02505K15
                        call util^timer^find( time^key^exchange^l,     !02505K16
                                              sub^in^pin^l,,, true );  !02505K17
                        end;                                           !02505K18
                    end                                                !02505K19
                else                                                   !02505K1A
                    begin                                              !02505K1B
                    increment( pct.pin.out^err^cnt );                  !02505K1C
                    if pct.pin.out^err^cnt >                           !02505K1D
                       pct.pin.pin^err^lmt then                        !02505K1E
                        begin                                          !02505K1F
                        call setbit( exchange^keys^g, pin^out^key^l ); !02505K1G
                        set( pct.pin.out^err^cnt,      0  );           !02505K1H
                        set( pct.pin.out^cons^err^cnt, 0  );           !02505K1I
                        set( pct.pin.out^key^tran^cnt, 0d );           !02505K1J
                        call util^timer^find( time^key^exchange^l,     !02505K1K
                                              sub^out^pin^l,,, true ); !02505K1L
                        end;                                           !02505K1M
                    end;                                               !02505K1N
                end;                                                   !02505K1O
                                                                       !02505K1P
            if pct.pin.cons^pin^err^lmt > 0 then                       !02505K1Q
                begin                                                  !02505K1R
                if pct.options.num^keys = "1" then                     !02505K1S
                    begin                                              !02505K1T
                    increment( pct.pin.in^cons^err^cnt );              !02505K1U
                    if pct.pin.in^cons^err^cnt >                       !02505K1V
                       pct.pin.cons^pin^err^lmt then                   !02505K1W
                        begin                                          !02505K1X
                        call setbit( exchange^keys^g,                  !02505K1Y
                                     pin^both^keys^l );                !02505K1Z
                        set( pct.pin.in^err^cnt,      0  );            !02505K20
                        set( pct.pin.in^cons^err^cnt, 0  );            !02505K21
                        set( pct.pin.in^key^tran^cnt, 0d );            !02505K22
                        call util^timer^find( time^key^exchange^l,     !02505K23
                                              sub^in^pin^l,,, true );  !02505K24
                        end;                                           !02505K25
                    end                                                !02505K26
                else                                                   !02505K27
                    begin                                              !02505K28
                    increment( pct.pin.out^cons^err^cnt );             !02505K29
                    if pct.pin.out^cons^err^cnt >                      !02505K2A
                       pct.pin.cons^pin^err^lmt then                   !02505K2B
                        begin                                          !02505K2C
                        call setbit( exchange^keys^g, pin^out^key^l ); !02505K2D
                        set( pct.pin.out^err^cnt,      0  );           !02505K2E
                        set( pct.pin.out^cons^err^cnt, 0  );           !02505K2F
                        set( pct.pin.out^key^tran^cnt, 0d );           !02505K2G
                        call util^timer^find( time^key^exchange^l,     !02505K2H
                                              sub^out^pin^l,,, true ); !02505K2I
                        end;                                           !02505K2J
                    end;                                               !02505K2K
                end;                                                   !02505K2L
            end                                                        !02505K2M
        else                                                           !02505K2N
        if error = tkn^addr^o^b^l  or                                  !02505K2O
           error = invalid^param^l then                                !02505K2P
            begin                                                      !02505K2Q
            call logmessage^( 1094,, @get^err, net.myname, 3,          !02505K2R
                              @pos^prod^g, @tkn^id );                  !02505K2S
                                                                       !02505}00
            return false;                                              !02505}01
                                                                       !02505}02
            end;                                                       !02505K2U
                                                                       !02505K2V
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02505K2W
        end;                                                           !02505K2X
                                                                       !02505K2Y
                                                                       !02505300
    if base24^rel^g >= 6 and                                           !02505301
       psem.pri^rsrvd4^prvt.len <> "   " and                           !02505302
       psem.pri^rsrvd4^prvt.len <> "000" then                          !02505303
        begin                                                          !02505304
        call pos^sem^del^tkns( sem );                                  !02505305
        end;                                                           !02505306
                                                                       !02505307
    if not pos^frmt^sem^to^pstm^tkn( sem, pstm ) then                  !02505K2Z
        begin                                                          !02505K30
        movd( err^flg, tkn^err^flg^d );                                !02505K31
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02505K32
        call hiswtkn^set^ps50^tkn( ext^data^fld^i,                     !02505K33
                                                                       !02505M0A
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02505M0B
                                                                       !02505M0C
                                                                       !02505M0D
                                                                       !02505M0E
                                   0, true, ext^lgth^i,, err^flg );    !02505K35
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02505K36
                                                                       !02505K37
        call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,              !02505K38
                                   pstm^lgth^d( pstm ), false,,        !02505K39
                                   pstm.data^flag, err^flg );          !02505K3A
                                                                       !02505K3B
        set( tkn^frmt^err, pos^resp^frmt^err^l );                      !02505K3C
                                                                       !02505S00
                                                                       !02505308
        end;                                                           !02505309
                                                                       !0250530A
                                                                       !0250530B
                                                                       !0250530C
                                                                       !0250530D
                                                                       !02505S0C
                                                                       !02505K3E
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02505K3F
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02505K3G
                                                                       !02505U0B
       ( pct.options.version^num = "60" or                             !02505U0C
         pct.options.version^num = "01" ) then                         !02505U0D
                                                                       !02505U0E
                                                                       !02505U0F
                                                                       !02505U0G
        begin                                                          !02505K3I
        !!                                                             !02505K3J
        !delete address verification token from interal message!       !02505K3K
        !if it was in the external msg and formatted to the internal!  !02505K3L
        !!                                                             !02505K3M
        if pstm.data^flag = "0" then                                   !02505K3N
            movd( userdata, false )                                    !02505K3O
        else                                                           !02505K3P
            movd( userdata, true );                                    !02505K3Q
                                                                       !02505K3R
        movd( tkn^id, addr^ver^tkn^id^d );                             !02505K3S
                                                                       !02505K3T
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !02505K3U
                               intrn^msg^lmt^l,                        !02505K3V
                               tkn^id,,, userdata );                   !02505K3W
                                                                       !02505K3X
        if error <> compl^no^err^l       and                           !02505K3Y
           error <> tkn^does^not^exist^l then                          !02505K3Z
            begin                                                      !02505K40
            call logmessage^( 1096,, @del^err, net.myname,             !02505K41
                              3, @pos^prod^g, @tkn^id );               !02505K42
            call abend^( 1775 );                                       !02505K43
            end;                                                       !02505K44
        end;                                                           !02505K45
                                                                       !02505K46
    if tkn^frmt^err then                                               !02505K47
        return tkn^frmt^err                                            !02505K48
    else                                                               !02505K49
        return true;                                                   !02505K4A
                                                                       !02505K4B
                                                                       !02506K00
                                                                       !02506K01
                                                                       !02506K02
    end;                                                               !02508
?section pos^frmt^sem^to^pstm^0220                                     !02509
?page "                               - pos^frmt^sem^to^pstm^0220"     !02509K00
!#####################################################################!!02512
!#                                                                   #!!02513
!#                    POS^FRMT^SEM^TO^PSTM^0220                      #!!02514
!#                                                                   #!!02515
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0220 OR 0120 SEM TO AN    #!!02516
!#       0220 PSTM ADVICE MESSAGE.                                   #!!02517
!#                                                                   #!!02518
!#    INPUT PARAMETERS :                                             #!!02519
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!!02520
                                                                       !02520S00
!#       STA^X         : INDEX OF STATION MESSAGE RECEIVED ON        #!
                                                                       !02520S03
!#                                                                   #!!02521
!#    OUTPUT PARAMETERS:                                             #!!02522
!#       PSTM          : POINTER TO INTERNAL MESSAGE                 #!!02523
!#                                                                   #!!02524
!#####################################################################!!02525
                                                                       !02526S00
int proc pos^frmt^sem^to^pstm^0220( sem, pstm, sta^x );                !02526S01
                                                                       !02526S02
int .sem(  sem^def  );                                                 !02527
int .pstm( pstm^def );                                                 !02528
                                                                       !02528S00
int .sta^x;                                                            !02528S01
                                                                       !02528S02
    begin                                                              !02529
                                                                       !02529L00
                                                                       !02529L01
    wlform( del^err,                                                   !02529L02
        "Error while attempting to delete token \\ from the PSTM " )   !02529L03
    wlform( get^err, "Error while attempting to get token \\ " )       !02529L04
                                                                       !02529L05
                                                                       !02529L06
                                                                       !02529L07
    define   sem^adj^code^d( x )  =  adjustment^tbl[ (x) * 4 + 0]#,    !02530
             pstm^adj^code^d( x ) =  adjustment^tbl[ (x) * 4 + 2]#;    !02531
                                                                       !02532
    string   adjustment^tbl = 'P' :=  [                                !02533
        !                                                             !!02534
        !  SEM ADJ.         PSTM ADJ.                                 !!02535
        !  CODES            CODES                                     !!02536
        !    |                |                                       !!02537
        !    v                v                                       !!02538
           "64",            "12", ! original amount incorrect         !!02539
           "S1",            "14", ! private - suspcious rvsl overide  !!02540
           "S2",            "15", ! private - misdispense overide     !!02541
           "94",            "16", ! duplicate transmission            !!02542
           "95",            "17", ! reconcile error                   !!02543
           "S3",            "18", ! private - PLUS add cash wdl or adv!!02544
           "96",            "19", ! system malfunction                !!02545
                                                                       !02545100
           "T9",            "16", ! duplicate transmission            !!02545101
                                                                       !02545102
            0 ];                                                       !02546
                                                                       !02547
                                                                       !02547L00
    struct                                                             !02547L01
           .addr^ver^tkn( addr^ver^tkn^def );                          !02547L02
                                                                       !02547L03
    int                                                                !02547L04
            error,                                                     !02547L05
           .ext^data^fld^i := wordaddr( @psem.pri^rsrvd4^prvt.data ),  !02547L06
            ext^lgth^i := 0,                                           !02547L07
                                                                       !02547:00
            i := -1,                                                   !02547:01
                                                                       !02547:02
            tkn^lgth,                                                  !02547L08
            userdata;                                                  !02547L09
                                                                       !02547S00
    int     fatal_flg := true;                                         !02547S01
    int     rcode;                                                     !02547S02
                                                                       !02547S03
                                                                       !02547L0A
    string                                                             !02547L0B
           .tkn^id[0:1];                                               !02547L0C
                                                                       !02547L0D
                                                                       !02547L0E
                                                                       !02547L0F
    movd ( pstm.typ, pstm^tran^advice^d );                             !02548
    call integer^ascii^( pstm.host^trace^num, trace^num^g );           !02549
                                                                       !02550
    if  not pos^frmt^sem^to^pstm^tran( sem, pstm ) then                !02551
        return reject^frmt^err^l;                                      !02552
                                                                       !02553
    if  not pos^frmt^sem^to^pstm^acct( sem, pstm ) then                !02554
        return reject^frmt^err^l;                                      !02555
                                                                       !02556
                                                                       !02556L00
    if  not pos^frmt^sem^to^pstm^amt( sem, pstm ) then                 !02556L01
        return reject^amt^l;                                           !02556L02
                                                                       !02556L03
                                                                       !02557L00
                                                                       !02557L01
                                                                       !02557L02
                                                                       !02559
                                                                       !02560L00
                                                                       !02560L01
                                                                       !02560L02
                                                                       !02563
                                                                       !02563S00
                                                                       !02563W00
    if not pos^frmt^sem^to^pstm^tkn( sem, pstm ) then                  !02563W01
        begin                                                          !02563W02
        return reject^frmt^err^l;                                      !02563W03
        end                                                            !02563W04
    else                                                               !02563W05
        begin                                                          !02563W06
        if base24^rel^g >= 6 and                                       !02563W07
           psem.pri^rsrvd4^prvt.len <> "   " and                       !02563W08
           psem.pri^rsrvd4^prvt.len <> "000" then                      !02563W09
            begin                                                      !02563W0A
            call pos_del_tkns( pstm );                                 !02563W0B
            end;                                                       !02563W0C
        end;                                                           !02563W0D
                                                                       !02563W0E
    if base24^rel^g >= 6 then                                          !02563S01
        begin                                                          !02563S02
        rcode := hiswpstm_txn_alwd_acq ( pstm,                         !02563S03
                                         pos^pct.acq^txn^prfl,         !02563S04
                                         pct.sta[ sta^x ].nam,         !02563S05
                                         apcfemt_seg_id_g,             !02563S06
                                         pos^pct.num^srv,              !02563S07
                                         apcf_emt_rec_g,               !02563S08
                                         fatal_flg,                    !02563S09
                                         apcfemt_name_g );             !02563S0A
        if rcode = sys_frmt_err_l then                                 !02563S0B
            begin                                                      !02563S0C
            !                                                        ! !02563S0D
            ! System error                                           ! !02563S0E
            !                                                        ! !02563S0F
            return pos^resp^frmt^err^l;                                !02563S0G
            end                                                        !02563S0H
        else                                                           !02563S0I
            begin                                                      !02563S0J
            if rcode = txn_cde_not_sppt_l then                         !02563S0K
                begin                                                  !02563S0L
                !                                                    ! !02563S0M
                ! Trans not allowed to switch according to APCFEMT   ! !02563S0N
                !                                                    ! !02563S0O
                return pos^resp^inv^tran^l;                            !02563S0P
                end;                                                   !02563S0Q
            end;                                                       !02563S0R
        end; ! of base24^rel^g >= 6                                  ! !02563S0S
                                                                       !02563S0T
    if  pos^adjustment^d( sem )  then                                  !02564
        begin                                                          !02565
                                                                       !02566L00
                                                                       !02566L01
                                                                       !02566L02
                                                                       !02569
        if  pstm.tran.amt^2 > pstm.tran.amt^1 then                     !02570
            move ( pstm.adj^flg, pos^pct.adj^flg );                    !02571
                                                                       !02572
                                                                       !02573:00
        i := -1;                                                       !02573:01
                                                                       !02573:02
        while sem^adj^code^d( i := i + 1 ) and psem.resp^cde <>        !02574
              sem^adj^code^d( i ) for $len( psem.resp^cde ) do;        !02575
                                                                       !02576
        if  not sem^adj^code^d ( i )  then                             !02577
            movd ( pstm.rvsl^cde, "00" )                               !02578
        else                                                           !02579
            movl ( pstm.rvsl^cde, pstm^adj^code^d( i ),                !02580
                $len( pstm.rvsl^cde ) );                               !02581
        end;                                                           !02582
                                                                       !02582L00
                                                                       !02582L01
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02582L02
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02582L03
                                                                       !02582U00
       ( pct.options.version^num = "60" or                             !02582U01
         pct.options.version^num = "01" ) then                         !02582U02
                                                                       !02582U03
                                                                       !02582U04
                                                                       !02582U05
        begin                                                          !02582L05
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02582L06
                                                                       !02582L07
        movd( tkn^id,   addr^ver^tkn^id^d );                           !02582L08
        !!                                                             !02582L09
        !get the address verification from the external message!       !02582L0A
        !!                                                             !02582L0B
        error := tkn^get^info( ext^data^fld^i, 0,                      !02582L0C
                                                                       !02582M00
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02582M01
                                                                       !02582M02
                                                                       !02582M03
                                                                       !02582M04
                               tkn^id, @addr^ver^tkn, tkn^lgth,        !02582L0E
                               true );                                 !02582L0F
        if error = compl^no^err^l then                                 !02582L0G
            begin                                                      !02582L0H
            !!                                                         !02582L0I
            !if address verification token was found!                  !02582L0J
            !move the information into the pstm fields!                !02582L0K
            !!                                                         !02582L0L
            mov^( pstm.addr^flds.addr, addr^ver^tkn.addr    );         !02582L0M
            mov^( pstm.zip^cde,        addr^ver^tkn.zip^cde );         !02582L0N
            movd( pstm.addr^typ,       av^addr^typ^d        );         !02582L0O
            end                                                        !02582L0P
        else                                                           !02582L0Q
        if error <> tkn^does^not^exist^l then                          !02582L0R
            begin                                                      !02582L0S
            call logmessage^( 1098,, @get^err, net.myname, 3,          !02582L0T
                              @pos^prod^g, @tkn^id );                  !02582L0U
                                                                       !02582}00
            reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );       !02582}01
            return reject^frmt^err^l;                                  !02582}02
                                                                       !02582}03
            end;                                                       !02582L0W
                                                                       !02582L0X
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02582L0Y
        end;                                                           !02582L0Z
                                                                       !02582L10
                                                                       !02582L11
                                                                       !02582L12
                                                                       !02582K01
                                                                       !02582W00
                                                                       !02582W01
                                                                       !02582W02
                                                                       !02582W03
                                                                       !02582W04
                                                                       !02582W05
                                                                       !02582W06
                                                                       !02582W07
                                                                       !02582W08
                                                                       !02582W09
                                                                       !02582W0A
                                                                       !02582W0B
                                                                       !02582W0C
                                                                       !02582W0D
                                                                       !02582S0E
                                                                       !02582S0F
                                                                       !02582S0G
                                                                       !02582K04
                                                                       !02582L13
                                                                       !02582L14
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02582L15
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02582L16
                                                                       !02582U0B
       ( pct.options.version^num = "60" or                             !02582U0C
         pct.options.version^num = "01" ) then                         !02582U0D
                                                                       !02582U0E
                                                                       !02582U0F
                                                                       !02582U0G
        begin                                                          !02582L18
        !!                                                             !02582L19
        !delete address verification token from interal message!       !02582L1A
        !if it was in the external msg and formatted to the internal!  !02582L1B
        !!                                                             !02582L1C
        if pstm.data^flag = "0" then                                   !02582L1D
            movd( userdata, false )                                    !02582L1E
        else                                                           !02582L1F
            movd( userdata, true );                                    !02582L1G
                                                                       !02582L1H
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !02582L1I
                               intrn^msg^lmt^l,                        !02582L1J
                               tkn^id,,, userdata );                   !02582L1K
                                                                       !02582L1L
        if error <> compl^no^err^l       and                           !02582L1M
           error <> tkn^does^not^exist^l then                          !02582L1N
            begin                                                      !02582L1O
            call logmessage^( 1102,, @del^err, net.myname,             !02582L1P
                              3, @pos^prod^g, @tkn^id );               !02582L1Q
            call abend^( 1779 );                                       !02582L1R
            end;                                                       !02582L1S
        end;                                                           !02582L1T
                                                                       !02582L1U
                                                                       !02582L1V
                                                                       !02583
    return pos^resp^no^err^l                                           !02584
    end;                                                               !02585
?section pos^frmt^sem^to^pstm^0402                                     !02586
?page "                               - pos^frmt^sem^to^pstm^0402"     !02586K00
!#####################################################################!!02589
!#                                                                   #!!02590
!#                    POS^FRMT^SEM^TO^PSTM^0402                      #!!02591
!#                                                                   #!!02592
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0402 SEM TO AN INTERNAL   #!!02593
!#       0402 REVERSAL MESSAGE.                                      #!!02594
!#                                                                   #!!02595
!#    INPUT PARAMETERS:                                              #!!02596
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!!02597
                                                                       !02597S00
!#       STA^X         : INDEX OF STATION MESSAGE RECEIVED ON        #!
                                                                       !02597S03
!#                                                                   #!!02598
!#    OUTPUT PARAMETERS:                                             #!!02599
!#       PSTM          : POINTER TO INTERNAL MESSAGE                 #!!02600
!#                                                                   #!!02601
!#####################################################################!!02602
                                                                       !02603S00
int proc pos^frmt^sem^to^pstm^0402( sem, pstm, sta^x );                !02603S01
                                                                       !02603S02
int .sem(  sem^def  );                                                 !02604
int .pstm( pstm^def );                                                 !02605
                                                                       !02605S00
int .sta^x;                                                            !02605S01
                                                                       !02605S02
    begin                                                              !02606
                                                                       !02606L00
                                                                       !02606L01
    wlform( del^err,                                                   !02606L02
        "Error while attempting to delete token \\ from the PSTM " )   !02606L03
    wlform( get^err, "Error while attempting to get token \\ " )       !02606L04
                                                                       !02606L05
                                                                       !02606L06
                                                                       !02606L07
    define  sem^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 0 ] #,           !02607
            pstm^code^d( i ) =  rvsl^tbl[ ( i ) * 4 + 2 ] #;           !02608
                                                                       !02609
    string  rvsl^tbl  = 'P' :=  [                                      !02610
        !                                                             !!02611
        !  SEM        PSTM                                            !!02612
        !  Codes      Codes                                           !!02613
        !  .          .                                               !!02614
        !  .          .                                               !!02615
        !  v          v                                               !!02616
        !                                                             !!02617
         "68",      "01",   ! timeout                                 !!02618
         "40",      "02",   ! requested function not supported        !!02619
         "R9",      "03",   ! dest not available                      !!02620
         "17",      "08",   ! customer cancelled                      !!02621
         "22",      "10",   ! suspected malfunction                   !!02622
         "96",      "19",   ! system malfunction                      !!02623
         "S0",      "20",   ! suspect reversal                        !!02624
               0 ];                                                    !02625
                                                                       !02626
                                                                       !02626L00
                                                                       !02626L01
    struct                                                             !02626L02
           .addr^ver^tkn( addr^ver^tkn^def );                          !02626L03
                                                                       !02626L04
    int                                                                !02626L05
            error,                                                     !02626L06
           .ext^data^fld^i := wordaddr( @psem.pri^rsrvd4^prvt.data ),  !02626L07
            ext^lgth^i,                                                !02626L08
            tkn^lgth,                                                  !02626L09
            userdata;                                                  !02626L0A
                                                                       !02626S00
    int     fatal_flg := true;                                         !02626S01
    int     rcode;                                                     !02626S02
                                                                       !02626S03
                                                                       !02626L0B
    string                                                             !02626L0C
            err^flg,                                                   !02626L0D
           .tkn^grp[ 0:3 ],                                            !02626L0E
           .tkn^id[0:1];                                               !02626L0F
                                                                       !02626L0G
                                                                       !02626L0H
                                                                       !02626L0I
                                                                       !02626L0J
                                                                       !02626K09
    movd ( pstm.typ, rvsl^request^d );                                 !02627
                                                                       !02628
    call integer^ascii^( pstm.host^trace^num, trace^num^g );           !02629
                                                                       !02630
    if  not pos^frmt^sem^to^pstm^tran( sem, pstm ) then                !02631
        return pos^resp^inv^tran^l;                                    !02632
                                                                       !02633
    if  not pos^frmt^sem^to^pstm^acct( sem, pstm ) then                !02634
        return pos^resp^frmt^err^l;                                    !02635
                                                                       !02636
                                                                       !02636L00
                                                                       !02636L01
    if  not pos^frmt^sem^to^pstm^amt( sem, pstm ) then                 !02636L02
        return pos^resp^inv^amt^l;                                     !02636L03
                                                                       !02636S00
                                                                       !02636W00
    if not pos^frmt^sem^to^pstm^tkn( sem, pstm ) then                  !02636W01
        begin                                                          !02636W02
        movd( err^flg, tkn^err^flg^d );                                !02636W03
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02636W04
        call hiswtkn^set^ps50^tkn( ext^data^fld^i,                     !02636W05
                                   $len( psem.pri^rsrvd4^prvt.pos.     !02636W06
                                         add^data ),                   !02636W07
                                   0, true, ext^lgth^i, !city^ext!,    !02636W08
                                   err^flg );                          !02636W09
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02636W0A
        return pos^resp^frmt^err^l;                                    !02636W0B
        end                                                            !02636W0C
    else                                                               !02636W0D
        begin                                                          !02636W0E
        if base24^rel^g >= 6 and                                       !02636W0F
           psem.pri^rsrvd4^prvt.len <> "   " and                       !02636W0G
           psem.pri^rsrvd4^prvt.len <> "000" then                      !02636W0H
            begin                                                      !02636W0I
            call pos_del_tkns( pstm );                                 !02636W0J
            end;                                                       !02636W0K
        end;                                                           !02636W0L
                                                                       !02636W0M
    if base24^rel^g >= 6 then                                          !02636S01
        begin                                                          !02636S02
        rcode := hiswpstm_txn_alwd_acq ( pstm,                         !02636S03
                                         pos^pct.acq^txn^prfl,         !02636S04
                                         pct.sta[ sta^x ].nam,         !02636S05
                                         apcfemt_seg_id_g,             !02636S06
                                         pos^pct.num^srv,              !02636S07
                                         apcf_emt_rec_g,               !02636S08
                                         fatal_flg,                    !02636S09
                                         apcfemt_name_g );             !02636S0A
        if rcode = sys_frmt_err_l then                                 !02636S0B
            begin                                                      !02636S0C
            !                                                        ! !02636S0D
            ! System error                                           ! !02636S0E
            !                                                        ! !02636S0F
            return pos^resp^frmt^err^l;                                !02636S0G
            end                                                        !02636S0H
        else                                                           !02636S0I
            begin                                                      !02636S0J
            if rcode = txn_cde_not_sppt_l then                         !02636S0K
                begin                                                  !02636S0L
                !                                                    ! !02636S0M
                ! Trans not allowed to switch according to APCFEMT   ! !02636S0N
                !                                                    ! !02636S0O
                return pos^resp^inv^tran^l;                            !02636S0P
                end;                                                   !02636S0Q
            end;                                                       !02636S0R
        end; ! of base24^rel^g >= 6                                  ! !02636S0S
                                                                       !02636S0T
                                                                       !02636L04
                                                                       !02637L00
                                                                       !02637L01
                                                                       !02637L02
                                                                       !02658
    movd ( pstm.tran.resp^cde, "955" );                                !02659
                                                                       !02660
    use i; i := -1;                                                    !02661
    while sem^code^d( i:=i+1 )  and psem.resp^cde <>                   !02662
          sem^code^d( i ) for $len( psem.resp^cde ) do;                !02663
                                                                       !02664
    if  not sem^code^d( i ) then                                       !02665
        movd ( pstm.rvsl^cde, "00" )                                   !02666
    else                                                               !02667
        movl ( pstm.rvsl^cde, sem^code^d( i ), $len( pstm.rvsl^cde ) );
    drop i;                                                            !02670
                                                                       !02671
                                                                       !02671L00
                                                                       !02671L01
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02671L02
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02671L03
                                                                       !02671U00
       ( pct.options.version^num = "60" or                             !02671U01
         pct.options.version^num = "01" ) then                         !02671U02
                                                                       !02671U03
                                                                       !02671U04
                                                                       !02671U05
        begin                                                          !02671L05
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02671L06
                                                                       !02671L07
        movd( tkn^id,   addr^ver^tkn^id^d );                           !02671L08
        !!                                                             !02671L09
        !get the address verification from the external message!       !02671L0A
        !!                                                             !02671L0B
        error := tkn^get^info( ext^data^fld^i, 0,                      !02671L0C
                                                                       !02671M00
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02671M01
                                                                       !02671M02
                                                                       !02671M03
                                                                       !02671M04
                               tkn^id, @addr^ver^tkn, tkn^lgth,        !02671L0E
                               true );                                 !02671L0F
        if error = compl^no^err^l then                                 !02671L0G
            begin                                                      !02671L0H
            !!                                                         !02671L0I
            !if address verification token was found!                  !02671L0J
            !move the information into the pstm fields!                !02671L0K
            !!                                                         !02671L0L
            mov^( pstm.addr^flds.addr, addr^ver^tkn.addr    );         !02671L0M
            mov^( pstm.zip^cde,        addr^ver^tkn.zip^cde );         !02671L0N
            movd( pstm.addr^typ,       av^addr^typ^d        );         !02671L0O
            end                                                        !02671L0P
        else                                                           !02671L0Q
        if error <> tkn^does^not^exist^l then                          !02671L0R
            begin                                                      !02671L0S
            call logmessage^( 1104,, @get^err, net.myname, 3,          !02671L0T
                              @pos^prod^g, @tkn^id );                  !02671L0U
                                                                       !02671}00
            reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );       !02671}01
            return pos^resp^frmt^err^l;                                !02671}02
                                                                       !02671}03
            end;                                                       !02671L0W
                                                                       !02671L0X
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02671L0Y
        end;                                                           !02671L0Z
                                                                       !02671L10
                                                                       !02671L11
                                                                       !02671L12
                                                                       !02671L13
                                                                       !02671L14
                                                                       !02671L15
                                                                       !02671L16
                                                                       !02671W00
                                                                       !02671W01
                                                                       !02671W02
                                                                       !02671W03
                                                                       !02671W04
                                                                       !02671W05
                                                                       !02671W06
                                                                       !02671W07
                                                                       !02671W08
                                                                       !02671W09
                                                                       !02671W0A
                                                                       !02671W0B
                                                                       !02671W0C
                                                                       !02671W0D
                                                                       !02671S0C
                                                                       !02671K0B
                                                                       !02671L17
                                                                       !02671L18
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02671L19
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02671L1A
                                                                       !02671U0B
       ( pct.options.version^num = "60" or                             !02671U0C
         pct.options.version^num = "01" ) then                         !02671U0D
                                                                       !02671U0E
                                                                       !02671U0F
                                                                       !02671U0G
        begin                                                          !02671L1C
        !!                                                             !02671L1D
        !delete address verification token from interal message!       !02671L1E
        !if it was in the external msg and formatted to the internal!  !02671L1F
        !!                                                             !02671L1G
        if pstm.data^flag = "0" then                                   !02671L1H
            movd( userdata, false )                                    !02671L1I
        else                                                           !02671L1J
            movd( userdata, true );                                    !02671L1K
                                                                       !02671L1L
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !02671L1M
                               intrn^msg^lmt^l,                        !02671L1N
                               tkn^id,,, userdata );                   !02671L1O
                                                                       !02671L1P
        if error <> compl^no^err^l       and                           !02671L1Q
           error <> tkn^does^not^exist^l then                          !02671L1R
            begin                                                      !02671L1S
            call logmessage^( 1106,, @del^err, net.myname,             !02671L1T
                              3, @pos^prod^g, @tkn^id );               !02671L1U
            call abend^( 1783 );                                       !02671L1V
            end;                                                       !02671L1W
        end;                                                           !02671L1X
                                                                       !02671L1Y
                                                                       !02671L1Z
                                                                       !02671L20
                                                                       !02671L21
                                                                       !02671L22
                                                                       !02671L23
                                                                       !02671L24
    return pos^resp^no^err^l                                           !02672
    end;                                                               !02673
?section pos^frmt^sem^to^pstm^0420                                     !02674
?page "                               - pos^frmt^sem^to^pstm^0420"     !02674K00
!#####################################################################!!02677
!#                                                                   #!!02678
!#                    POS^FRMT^SEM^TO^PSTM^0420                      #!!02679
!#                                                                   #!!02680
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0420 SEM TO AN INTERNAL   #!!02681
!#       0420 REVERSAL MESSAGE.                                      #!!02682
!#                                                                   #!!02683
!#    INPUT PARAMETERS :                                             #!!02684
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!!02685
!#                                                                   #!!02686
!#    OUTPUT PARAMETERS:                                             #!!02687
!#       PSTM          : POINTER TO INTERNAL MESSAGE                 #!!02688
!#                                                                   #!!02689
!#####################################################################!!02690
int proc pos^frmt^sem^to^pstm^0420( sem, pstm );                       !02691
int .sem(  sem^def  );                                                 !02692
int .pstm( pstm^def );                                                 !02693
                                                                       !02694
    begin                                                              !02695
                                                                       !02695L00
                                                                       !02695L01
    wlform( del^err,                                                   !02695L02
        "Error while attempting to delete token \\ from the PSTM " )   !02695L03
    wlform( get^err, "Error while attempting to get token \\ " )       !02695L04
                                                                       !02695L05
!*==================================================================*!
!  BEGIN RPQ #25 - Bill Payment                      MCD / 2269      !
!--------------------------------------------------------------------!
    wlform(conv^err,"Error while attempting to convert ascii to fixed")
    wlform(add^err, "Error while attempting to add token \\")
!--------------------------------------------------------------------!
!  END   RPQ #25 - Bill Payment                      MCD / 2269      !
!*==================================================================*!
                                                                       !02695L06
    define  sem^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 0 ] #,           !02696
            pstm^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 2 ] #;          !02697
                                                                       !02698
    string  rvsl^tbl  = 'P' :=  [                                      !02699
        !                                                             !!02700
        !  SEM        PSTM                                            !!02701
        !  Codes      Codes                                           !!02702
        !  .          .                                               !!02703
        !  .          .                                               !!02704
        !  v          v                                               !!02705
        !                                                             !!02706
         "68",      "01",   ! timeout                                 !!02707
         "40",      "02",   ! requested function not supported        !!02708
         "R9",      "03",   ! dest not available                      !!02709
         "17",      "08",   ! customer cancelled                      !!02710
         "22",      "10",   ! suspected malfunction                   !!02711
         "96",      "19",   ! system malfunction                      !!02712
         "S0",      "20",   ! suspect reversal                        !!02713
                                                                       !02713K00
         "U1",      "21",   ! MAC failure!                             !02713K01
         "U2",      "22",   ! KMAC sync error!                         !02713K02
         "U3",      "23",   ! message replay error!                    !02713K03
         "U4",      "24",   ! invalid MAC!                             !02713K04
                                                                       !02713z00
         "U6",      "40",   ! Split Routing Enabled; Secondary        !!02713z01
                            ! Service Not Approved                    !!02713z02
                                                                       !02713z03
                                                                       !02713K05
               0 ];                                                    !02714
                                                                       !02715
                                                                       !02715L00
    struct                                                             !02715L01

!*==================================================================*!
!  BEGIN RPQ #25 - Bill Payment                       MCD / 2269     !
!--------------------------------------------------------------------!
           .rpq^bill^pymt^buf( rpq^bill^pymt^tkn^def ),
!--------------------------------------------------------------------!
!  END   RPQ #25 - Bill Payment                       MCD / 2269     !
!*==================================================================*!
!*******************************************************************!
! BEGIN RPQ #ID001 - Manejo Especial Campo P42                      !
!*******************************************************************!
           .rpq^p42^tkn( rpq^p42^tkn^def ),
!*******************************************************************!
! END   RPQ #ID001 - Manejo Especial Campo P42                      !
!*******************************************************************!
           .addr^ver^tkn( addr^ver^tkn^def );                          !02715L02
                                                                       !02715L03
    int                                                                !02715L04
!*==================================================================*!
!    RPQ #25 - Bill Payment                           MCD / 2269     !
!--------------------------------------------------------------------!
            tkn^ofst^g := 0,
            tkn^util^val,
            txt^lgth,
            pos^user^data^flag,
            stat,
!--------------------------------------------------------------------!
!    RPQ #25 - Bill Payment                           MCD / 2269     !
!*==================================================================*!

            error,                                                     !02715L05
           .ext^data^fld^i := wordaddr( @psem.pri^rsrvd4^prvt.data ),  !02715L06
            ext^lgth^i := 0,                                           !02715L07
                                                                       !02715:00
            i := -1,                                                   !02715:01
                                                                       !02715:02
            tkn^lgth,                                                  !02715L08
            userdata;                                                  !02715L09
                                                                       !02715L0A
    string                                                             !02715L0B
           .tkn^id[0:1];                                               !02715L0C
                                                                       !02715L0D
                                                                       !02715L0E
                                                                       !02715L0F
    movd ( pstm.typ,  pstm^rvsl^advice^d         );                    !02716
                                                                       !02717
    call integer^ascii^( pstm.host^trace^num, trace^num^g );           !02718
                                                                       !P0271900
    move( pstm.retl^sic^cde, psem.mrcht^typ^cde );                     !P0271901
                                                                       !P0271902
    move( pstm.crd^accpt^id^num, psem.crd^accpt^id^cde );              !G0271901
                                                                       !G0271902
                                                                       !02719L00
    if  not pos^frmt^sem^to^pstm^amt( sem, pstm ) then                 !02719L01
        return false;                                                  !02719L02
                                                                       !02719L03
    if  pos^adjustment^d( sem )  then                                  !02719L04
        begin                                                          !02719L05
                                                                       !02719L06
        if  pstm.tran.amt^2 > pstm.tran.amt^1 then                     !02719L07
            move ( pstm.adj^flg, pos^pct.adj^flg );                    !02719L08
                                                                       !02719O00
                                                                       !02719O01
                                                                       !02719O02
        end;                                                           !02719L0J
                                                                       !02719O03
                                                                       !02719:00
    i := -1;                                                           !02719:01
                                                                       !02719:02
    while sem^code^d( i := i + 1 ) and psem.resp^cde <>                !02719O05
          sem^code^d( i ) for $len( psem.resp^cde ) do;                !02719O06
                                                                       !02719O07
    if  not sem^code^d ( i )  then                                     !02719O08
        movd ( pstm.rvsl^cde, "00" )                                   !02719O09
    else                                                               !02719O0A
        movl ( pstm.rvsl^cde, pstm^code^d( i ),                        !02719O0B
            $len( pstm.rvsl^cde ) );                                   !02719O0C
                                                                       !02719O0D
                                                                       !02719O0E
                                                                       !02719O0F
                                                                       !02719O0G
    move ( pstm.pre^auth^seq^num,                                      !02752L01
           ssem.secndry^rsrvd7^prvt.pos.pre^auth^seq^num );            !02752L02
                                                                       !02752L03
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02752L04
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02752L05
                                                                       !02752U00
       ( pct.options.version^num = "60" or                             !02752U01
         pct.options.version^num = "01" ) then                         !02752U02
                                                                       !02752U03
                                                                       !02752U04
                                                                       !02752U05
        begin                                                          !02752L07
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02752L08
                                                                       !02752L09
        movd( tkn^id,   addr^ver^tkn^id^d );                           !02752L0A
        !!                                                             !02752L0B
        !get the address verification from the external message!       !02752L0C
        !!                                                             !02752L0D
        error := tkn^get^info( ext^data^fld^i, 0,                      !02752L0E
                                                                       !02752M00
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02752M01
                                                                       !02752M02
                                                                       !02752M03
                                                                       !02752M04
                               tkn^id, @addr^ver^tkn, tkn^lgth,        !02752L0G
                               true );                                 !02752L0H
        if error = compl^no^err^l then                                 !02752L0I
            begin                                                      !02752L0J
            !!                                                         !02752L0K
            !if address verification token was found!                  !02752L0L
            !move the information into the pstm fields!                !02752L0M
            !!                                                         !02752L0N
            mov^( pstm.addr^flds.addr, addr^ver^tkn.addr    );         !02752L0O
            mov^( pstm.zip^cde,        addr^ver^tkn.zip^cde );         !02752L0P
            movd( pstm.addr^typ,       av^addr^typ^d        );         !02752L0Q
            end                                                        !02752L0R
        else                                                           !02752L0S
        if error <> tkn^does^not^exist^l then                          !02752L0T
            begin                                                      !02752L0U
            call logmessage^( 1108,, @get^err, net.myname, 3,          !02752L0V
                              @pos^prod^g, @tkn^id );                  !02752L0W
                                                                       !02752}00
            reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );       !02752}01
            return false;                                              !02752}02
                                                                       !02752}03
            end;                                                       !02752L0Y
                                                                       !02752L0Z
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !02752L10
        end;                                                           !02752L11
                                                                       !02752L12
                                                                       !02752L13
                                                                       !02752L14
                                                                       !02752L15
    if  not pos^frmt^sem^to^pstm^tkn( sem, pstm ) then                 !02752K01
                                                                       !02752S00
        begin                                                          !02752S01
        return false;                                                  !02752S02
        end                                                            !02752S03
    else                                                               !02752S04
        begin                                                          !02752S05
        if base24^rel^g >= 6 and                                       !02752S06
           psem.pri^rsrvd4^prvt.len <> "   " and                       !02752S07
                                                                       !02752U06
           psem.pri^rsrvd4^prvt.len <> "000" then                      !02752U07
                                                                       !02752U08
                                                                       !02752U09
                                                                       !02752U0A
            begin                                                      !02752S0A
            call pos_del_tkns( pstm );                                 !02752S0B
            end;                                                       !02752S0C
        end;                                                           !02752S0D
                                                                       !02752S0E
                                                                       !02752S0F
                                                                       !02752S0G
                                                                       !02752K03
                                                                       !02752L16
    if psem.pri^rsrvd4^prvt.len <> "   " and                           !02752L17
       psem.pri^rsrvd4^prvt.len <> "000" and                           !02752L18
                                                                       !02752U0B
       ( pct.options.version^num = "60" or                             !02752U0C
         pct.options.version^num = "01" ) then                         !02752U0D
                                                                       !02752U0E
                                                                       !02752U0F
                                                                       !02752U0G
        begin                                                          !02752L1A
        !!                                                             !02752L1B
        !delete address verification token from interal message!       !02752L1C
        !if it was in the external msg and formatted to the internal!  !02752L1D
        !!                                                             !02752L1E
        if pstm.data^flag = "0" then                                   !02752L1F
            movd( userdata, false )                                    !02752L1G
        else                                                           !02752L1H
            movd( userdata, true );                                    !02752L1I
                                                                       !02752L1J
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !02752L1K
                               intrn^msg^lmt^l,                        !02752L1L
                               tkn^id,,, userdata );                   !02752L1M
                                                                       !02752L1N
        if error <> compl^no^err^l       and                           !02752L1O
           error <> tkn^does^not^exist^l then                          !02752L1P
            begin                                                      !02752L1Q
            call logmessage^( 1112,, @del^err, net.myname,             !02752L1R
                              3, @pos^prod^g, @tkn^id );               !02752L1S
            call abend^( 1787 );                                       !02752L1T
            end;                                                       !02752L1U
        end;                                                           !02752L1V
                                                                       !02752L1W
                                                                       !02752L1X
                                                                       !02752L1Y
                                                                       !02752L1Z
!*******************************************************************!
!   BEGIN RPQ #25 - Bill Payment                   MCD / 2269       !
!-------------------------------------------------------------------!
    if psem.pt^tran^spcl^cde = "15" and
       pstm^^purchase^d then
       begin
       tkn^id ':=' rpq^bill^pymt^tkn^id^d ;
       rpq^bill^pymt^buf ':=' (($len(rpq^bill^pymt^buf))/2)
                                          * ["  "];
       rpq^bill^pymt^buf.city^cde ':='
                 psem.pri^rsrvd1^natl.bill^pay^info.city^cde for
            $len( rpq^bill^pymt^buf.city^cde);
       rpq^bill^pymt^buf.vendor^type ':='
                 psem.pri^rsrvd1^natl.bill^pay^info.vendor^type for
            $len( rpq^bill^pymt^buf.vendor^type);

       txt^lgth :=
          $len(psem.pri^rsrvd1^natl.bill^pay^info.amount);
       stat := ascii^fixed
               (psem.pri^rsrvd1^natl.bill^pay^info.amount,
                txt^lgth, rpq^bill^pymt^buf.amount);
       if not stat then
          begin
          call logmessage^(6000,,@conv^err,,3, @pos^prod^g);
          return false;
          end;

       rpq^bill^pymt^buf.invoice^num ':='
            psem.pri^rsrvd1^natl.bill^pay^info.invoice^num for
            $len( rpq^bill^pymt^buf.invoice^num);
       rpq^bill^pymt^buf.vendor^id ':='
            psem.pri^rsrvd1^natl.bill^pay^info.vendor^id for
            $len( rpq^bill^pymt^buf.vendor^id);
       rpq^bill^pymt^buf.merchant^id ':='
            psem.pri^rsrvd1^natl.bill^pay^info.merchant^id for
            $len( rpq^bill^pymt^buf.merchant^id);
       rpq^bill^pymt^buf.due^date ':='
            psem.pri^rsrvd1^natl.bill^pay^info.due^date for
            $len( rpq^bill^pymt^buf.due^date);
       rpq^bill^pymt^buf.fax^num ':='
            psem.pri^rsrvd1^natl.bill^pay^info.fax^num for
            $len( rpq^bill^pymt^buf.fax^num);
       rpq^bill^pymt^buf.paid^flg ':='
            psem.pri^rsrvd1^natl.bill^pay^info.paid^flg for
            $len(rpq^bill^pymt^buf.paid^flg);

!*********************************************************************!
!* BEGIN RPQ #25A-Bill Payment                                       *!
!---------------------------------------------------------------------!
       rpq^bill^pymt^buf.telecode^number ':='
            psem.pri^rsrvd1^natl.bill^pay^info.telecode^number for
            $len( rpq^bill^pymt^buf.telecode^number );
       rpq^bill^pymt^buf.cvv2            ':='
            psem.pri^rsrvd1^natl.bill^pay^info.cvv2 for
            $len( rpq^bill^pymt^buf.cvv2 );

       rpq^bill^pymt^buf.cardholder^id ':='
            psem.pri^rsrvd2^natl.bill^pay^info.cardholder^id for
            $len( rpq^bill^pymt^buf.cardholder^id );
!---------------------------------------------------------------------!
!* END   RPQ #25A-Bill Payment                                       *!
!*********************************************************************!

       tkn^ofst^g := $offset(pstm.srvcs[0]) +
               $min(($len(pstm.srvcs[0]) * pstm.num^services),
                    ($len(pstm.srvcs[0]) * $occurs(pstm.srvcs)));

       if pstm.data^flag = "0" then
          pos^user^data^flag := false
       else
          begin
          pos^user^data^flag := true;
          end;
       tkn^util^val := tkn^add^info(pstm, tkn^ofst^g,
                                    intrn^msg^lmt^l, tkn^id,
                                    rpq^bill^pymt^buf,
                                    $len( rpq^bill^pymt^buf ),,,,,
                                    pos^user^data^flag);

       if tkn^util^val <> compl^no^err^l and
          tkn^util^val <> tkn^exist^l then
          begin
          call logmessage^(6001,, @add^err,,3,@pos^prod^g, @tkn^id);
          return false;
          end;
       end;
!---------------------------------------------------------------------!
!    RPQ #25 - Bill Payment                        MCD / 2269         !
!*********************************************************************!
!*******************************************************************!
! BEGIN  RPQ #ID001 - Manejo Especial Campo P42                     !
!*******************************************************************!
    tkn^id ':=' rpq^p42^tkn^id^d;                ! "ID"
    rpq^p42^tkn.campo^p42.byte[0] ':='
                 psem.crd^accpt^id^cde.byte[0] for 15;
    rpq^p42^tkn.user^p42.byte[0]  ':='
                 psem.crd^accpt^id^cde.byte[0] for 2;
    rpq^p42^tkn.user^p42.byte[2]  ':=' "00";
    rpq^p42^tkn.user^p42.byte[4]  ':='
                 psem.crd^accpt^id^cde.byte[2] for 10;
    tkn^ofst^g := $offset(pstm.srvcs[0]) +
               $min(($len(pstm.srvcs[0]) * pstm.num^services),
                    ($len(pstm.srvcs[0]) * $occurs(pstm.srvcs)));

    if pstm.data^flag = "0" then
       pos^user^data^flag := false
    else
     begin
      pos^user^data^flag := true;
     end;
    tkn^util^val := tkn^add^info(pstm, tkn^ofst^g,
                                 intrn^msg^lmt^l, tkn^id,
                                 rpq^p42^tkn,
                                $len( rpq^p42^tkn ),,,,,
                                 pos^user^data^flag);
    if tkn^util^val <> compl^no^err^l and
       tkn^util^val <> tkn^exist^l then
       begin
        call logmessage^(5003,, @add^err,,3,@pos^prod^g, @tkn^id);
       end;
!*******************************************************************!
! END    RPQ #ID001 - Manejo Especial Campo P42                     !
!*******************************************************************!

    return true;                                                       !02753
    end;                                                               !02754
?section pos^frmt^sem^to^pstm^acct                                     !02755
?page "                               - pos^frmt^sem^to^pstm^acct"     !02755K00
                                                                       !02758
!#####################################################################!!02759
!#                                                                   #!!02760
!#                   POS^FRMT^SEM^T0^PSTM^ACCT                       #!!02761
!#                                                                   #!!02762
!#    NARRATIVE : THIS PROCEDURE FORMATS THE SEM ACCOUNT NUMBERS TO  #!!02763
!#                PSTM ACCOUNT NUMBERS.                              #!!02764
!#                                                                   #!!02765
!#    INPUT PARAMETERS:                                              #!!02766
!#          SEM       : MESSAGE POINTER TO EXTERNAL SEM.             #!!02767
!#                                                                   #!!02768
!#    OUTPUT PARAMETERS:                                             #!!02769
!#          PSTM      : MESSAGE POINTER TO INTERNAL PSTM.            #!!02770
!#                                                                   #!!02771
!#####################################################################!!02772
int proc pos^frmt^sem^to^pstm^acct( sem, pstm );                       !02773
int .sem( sem^def );                                                   !02774
int .pstm( pstm^def );                                                 !02775
    begin                                                              !02776
                                                                       !02776L00
                                                                       !02776M00
    wlform( noroom^trk1,                                               !02776M01
            "UNABLE TO ADD TRACK1 TOKEN, NO ROOM AVAILABLE" )          !02776M02
                                                                       !02776M03
    wlform( err^trk1,                                                  !02776M04
            "ERROR WHILE ATEMPTING TO ADD TRACK1 TOKEN ")              !02776M05
                                                                       !02776M06
    struct  .track1^tkn( track1^tkn^def );                             !02776M07
                                                                       !02776M08
    int      length,                                                   !02776M09
             tkn^lgth,                                                 !02776M0A
             dspy := false,                                            !02776M0B
             pos^userdata,                                             !02776M0C
             tkn^result,                                               !02776M0D
                                                                       !02776)00
             counter,                                                  !02776)01
             pan^lgth;                                                 !02776)02
                                                                       !02776)03
                                                                       !02776M0F
    string   tkn^id[0:1],                                              !02776M0G
            .fld^sep,                                                  !02776M0H
            .addr;                                                     !02776M0I
                                                                       !02776M0J
    if  psem.track1.data <> blanks for $len( psem.track1.data ) then   !02776M0K
        begin                                                          !02776M0L
        tkn^id ':=' track1^tkn^id^d;                                   !02776M0M
        rscan psem.track1.data while " " -> @addr;                     !02776M0N
        @addr := @addr[ +1 ];                                          !02776M0O
        length := @addr - @psem.track1.data;                           !02776M0P
        track1^tkn.val ':=' track1^start^sent^d &                      !02776M0Q
                            psem.track1.data for length &              !02776M0R
                            end^sent^d;                                !02776M0S
        tkn^lgth := 0;                                                 !02776M0T
        length := length + 2;                                          !02776M0U
        if  length.<15> then                                           !02776M0V
            begin                                                      !02776M0W
            track1^tkn.val.byte[ length ] ':=' " ";                    !02776M0X
            length := length + 1;                                      !02776M0Y
            end;                                                       !02776M0Z
        if  pstm.data^flag <> "0" then                                 !02776M10
            pos^userdata := true                                       !02776M11
        else                                                           !02776M12
            pos^userdata := false;                                     !02776M13
        tkn^result := tkn^add^info( pstm,                              !02776M14
                                    pstm^lgth^d( pstm ),               !02776M15
                                    intrn^msg^lmt^l,                   !02776M16
                                    tkn^id,                            !02776M17
                                    track1^tkn,                        !02776M18
                                    length,,                           !02776M19
                                    tkn^lgth,,,                        !02776M1A
                                    pos^userdata );                    !02776M1B
        if  tkn^result then                                            !02776M1C
            begin                                                      !02776M1D
            if  tkn^result = over^max^limit^l then                     !02776M1E
                call logmessage^( 1113,, @noroom^trk1,                 !02776M1F
                                   net.myname,                         !02776M1G
                                   2 )                                 !02776M1H
            else                                                       !02776M1I
            if  tkn^result = tkn^exist^l then                          !02776M1J
            else                                                       !02776M1K
                begin                                                  !02776M1L
                call logmessage^( 1114,, @err^trk1, net.myname, 3 );   !02776M1M
                                                                       !02776}00
                return false;                                          !02776}01
                                                                       !02776}02
                end;                                                   !02776M1O
            end;                                                       !02776M1P
        end;                                                           !02776M1Q
                                                                       !02776M1R
                                                                       !02776M1S
                                                                       !02776M1T
                                                                       !02776M1U
                                                                       !02777L01
                                                                       !02778
                                                                       !02778K00
    if  psem.track2.len  <> blanks for $len( psem.track2.len  ) and    !02778K01
        psem.track2.len  <> zeroes for $len( psem.track2.len  ) and    !02778K02
        psem.track2.data <> blanks for $len( psem.track2.data ) and    !02778K03
        psem.track2.data <> zeroes for $len( psem.track2.data ) then   !02778K04
                                                                       !02778K05
                                                                       !02779K00
                                                                       !02779K01
                                                                       !02779K02
        begin                                                          !02781
        if  not ascii^integer^( psem.track2.len, length ) or           !02782
                ( length > $len( pstm.tran.track2 ) - 2 ) then         !02783
            return false;                                              !02784
                                                                       !02785
        mov^( pstm.tran.track2, blanks );                              !02786
                                                                       !02786L00
        counter := -1;                                                 !02786L01
        while ( counter := counter + 1 ) < length and                  !02786L02
                psem.track2.data.byte[ counter ] <> " " do;            !02786L03
        pstm.tran.track2 ':=' start^sent^d &                           !02786L04
                              psem.track2.data for counter &           !02786L05
                              end^sent^d;                              !02786L06
                                                                       !02786L07
                                                                       !02787L00
                                                                       !02787L01
                                                                       !02787L02
                                                                       !02789
                                                                       !02789h00
        if psem.entry^mde = "01"             or                        !02790
!*********************************************************************
! BEGIN RPQ #COF 
!*********************************************************************
           psem.entry^mde = "10"             or
!*********************************************************************
! END RPQ #COF 
!*********************************************************************
            ( pstm.typ = pstm^response^d     and                       !02789h03
              pstm.pt^srv^entry^mde = "01" ) then                      !02789h04
            !                                                          !!02791
                                                                       !02789h07
                                                                       !02790h00
                                                                       !02790h01
                                                                       !02790h02
            ! Manually entered cardnumber                             !!02792
            !                                                         !!02793
            pstm.tran.track2.byte[0] := "M";                           !02794
                                                                       !02794x00
                                                                       !02794x01
                                                                       !02794x02
                                                                       !02795)00
        end                                                            !02795)01
    else                                                               !02795)02
        begin                                                          !02795)03
        if psem.pan.len <> blanks for $len( psem.pan.len ) then        !02795)04
            begin                                                      !02795)05
            pstm.tran.track2.byte[ 0 ] ':=' blanks for                 !02795)06
                                            $len( pstm.tran.track2 );  !02795)07
                                                                       !02795)08
            call ascii^integer^( psem.pan.len, pan^lgth ) ;            !02795)09
                                                                       !02795)0A
            !                                                         !!02795)0B
            ! Construct the PSTM Track2 using PAN and Expiration Date !!02795)0C
            ! from the SEM.                                           !!02795)0D
            !                                                         !!02795)0E
            if psem.exp^dat <> blanks for $len( psem.exp^dat ) then    !02795)0F
                begin                                                  !02795)0G
                pstm.tran.track2.byte[ 0 ] ':='                        !02795)0H
                    "M" &                                              !02795)0I
                    psem.pan.data for pan^lgth &                       !02795)0J
                    "=" &                                              !02795)0K
                    psem.exp^dat for $len( psem.exp^dat ) &            !02795)0L
                    "?";                                               !02795)0M
                end                                                    !02795)0N
            else                                                       !02795)0O
                begin                                                  !02795)0P
                pstm.tran.track2.byte[ 0 ] ':='                        !02795)0Q
                    "M" &                                              !02795)0R
                    psem.pan.data for pan^lgth &                       !02795)0S
                    "=" &                                              !02795)0T
                    "0000" &                                           !02795)0U
                    "?";                                               !02795)0V
                end;                                                   !02795)0W
            end;                                                       !02795)0X
        end;                                                           !02795)0Y
                                                                       !02795)0Z
                                                                       !02796
    if  psem.typ.byte[ 2 ] = "0" or                                    !02797
        psem.typ.byte[ 2 ] = "2" then                                  !02798
        mov^ ( pstm.tran.acct, zeroes )                                !02799
    else                                                               !02800
    if  ssem.acct1.len <> blanks for $len( ssem.acct1.len ) and        !02801
        ssem.acct1.len <> zeroes for $len( ssem.acct1.len ) then       !02802
        begin                                                          !02803
        if  not ascii^integer^( ssem.acct1.len, length ) then          !02804
            return false;                                              !02805
                                                                       !02806
        length := $min( length, $len( pstm.tran.acct ) );              !02807
                                                                       !02808
        pstm.tran.acct ':=' ssem.acct1.num for length &                !02809
             blanks for $len( pstm.tran.acct ) - length;               !02810
        end;                                                           !02811
                                                                       !02812
    return true;                                                       !02813
    end;                                                               !02814
                                                                       !02814K00
                                                                       !02814L00
                                                                       !02814L01
?section pos^frmt^sem^to^pstm^amt                                      !02814L02
?page "                                - pos^frmt^sem^to^pstm^amt"     !02814L03
!#####################################################################!
!#                                                                   #!
!#                   POS^FRMT^SEM^T0^PSTM^AMT                        #!
!#                                                                   #!
!#    NARRATIVE : THIS PROCEDURE FORMATS A SEM AMOUNT FIELD TO THE   #!
!#       BASE24 ATM AMOUNT AFTER APPLYING ANY CONVERSION FACTOR.     #!
!#                                                                   #!
!#    INPUT PARAMETERS:                                              #!
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!
!#       PSTM          : POINTER TO INTERNAL MESSAGE                 #!
!#                                                                   #!
!#    OUTPUT PARAMETERS:                                             #!
!#                                                                   #!
!#    RETURNS TRUE IF SUCCESSFUL WITH CONVERTED AMOUNT IN PSTM       #!
!#    RETURNS FALSE IF NOT SUCCESSFUL                                #!
!#                                                                   #!
!#####################################################################!
                                                                       !O0281400
                                                                       !O0281401
int proc pos^frmt^sem^to^pstm^amt( sem, pstm );                        !O0281402
                                                                       !O0281403
                                                                       !O0281404
struct   .sem( sem^def );                                              !02814L12
struct   .pstm( pstm^def );                                            !02814L13
                                                                       !02814y00
                                                                       !O0281405
                                                                       !O0281406
                                                                       !02814y02
                                                                       !02814L15
    begin                                                              !02814L16
                                                                       !02814L17
    fixed   pstm^amt  := 0f,                                           !02814L18
            pstm^amt2 := 0f,                                           !02814L19
            psem^amt  := 0f;                                           !02814L1A
                                                                       !02814r00
!*====================================================================*
! BEGIN RPQ #26 - Allways move amount-2 into PSTM
!*--------------------------------------------------------------------*
    fixed   temp^amt;
!*--------------------------------------------------------------------*
! END   RPQ #26 - Allways move amount-2 into PSTM
!*====================================================================*

                                                                       !N0281400
                                                                       !N0281401
                                                                       !02814r02
                                                                       !02814L1B
int subproc sub^convert^fixed^amt( pstm^amt, conv^rate );              !02814L1C
fixed   .pstm^amt;                                                     !02814L1D
string  .conv^rate;                                                    !02814L1E
                                                                       !02814L1F
    begin                                                              !02814L1G
                                                                       !02814L1H
    fixed  sell^rate := 0f;                                            !02814L1I
                                                                       !02814L1J
    int    sell^scale := 0;                                            !02814L1K
                                                                       !02814L1L
                                                                       !02814f00
    !                                                                 !!02814f01
    ! Determine if the multiple currency add-on is being used.  If it !!02814f02
    ! is, skip this processing.                                       !!02814f03
    !                                                                 !!02814f04
    if pct.options.mult^crncy = "Y" then                               !02814f05
        begin                                                          !02814f06
        return true;                                                   !02814f07
        end;                                                           !02814f08
                                                                       !02814f09
    !   acquirer converted, different from local -> convert!           !02814L1M
    if  ( psem.setl^crncy <> blanks     ! acq converted!               !02814L1N
                             for $len( psem.setl^crncy ) and           !02814L1O
          psem.setl^crncy <> local^crncy^cde^g                         !02814L1P
                             for $len( psem.setl^crncy ) )  or         !02814L1Q
    !   not acquirer converted, different from local -> convert!       !02814L1R
                                                                       !02814i00
        ( psem.setl^crncy = blanks for $len( psem.setl^crncy ) and     !02814i01
          psem.crncy^cde <> local^crncy^cde^g for                      !02814i02
              $len( psem.crncy^cde ) ) then                            !02814i03
                                                                       !02814i04
                                                                       !02814i05
                                                                       !02814i06
                                                                       !02814i07
        begin                                                          !02814L1U
                                                                       !02814L1V
        ! convert conversion rate for calculations!                    !02814L1W
        call ascii^integer( conv^rate[0], 1, sell^scale );             !02814L1X
        call ascii^fixed  ( conv^rate[1], 7, sell^rate );              !02814L1Y
                                                                       !02814L1Z
        case sell^scale of                                             !02814L20
            begin                                                      !02814L21
      ! 0!  pstm^amt := ( pstm^amt * sell^rate );                      !02814L22
      ! 1!  pstm^amt := ( pstm^amt * sell^rate ) / 10f;                !02814L23
      ! 2!  pstm^amt := ( pstm^amt * sell^rate ) / 100f;               !02814L24
      ! 3!  pstm^amt := ( pstm^amt * sell^rate ) / 1000f;              !02814L25
      ! 4!  pstm^amt := ( pstm^amt * sell^rate ) / 10000f;             !02814L26
      ! 5!  pstm^amt := ( pstm^amt * sell^rate ) / 100000f;            !02814L27
      ! 6!  pstm^amt := ( pstm^amt * sell^rate ) / 1000000f;           !02814L28
      ! 7!  pstm^amt := ( pstm^amt * sell^rate ) / 10000000f;          !02814L29
      ! 8!  pstm^amt := ( pstm^amt * sell^rate ) / 100000000f;         !02814L2A
      ! 9!  pstm^amt := ( pstm^amt * sell^rate ) / 1000000000f;        !02814L2B
      ! ?!  otherwise                                                  !02814L2C
                return false;                                          !02814L2D
            end;                                                       !02814L2E
        end;                                                           !02814L2F
                                                                       !02814L2G
    return true;                                                       !02814L2H
    end;                                                               !02814L2I
                                                                       !02814f0A
                                                                       !02814i08
!                                                                     !!02814i09
! This is the main body of proc pos^frmt^sem^to^pstm^amt              !!02814i0A
!                                                                     !!02814i0B
                                                                       !02814i0C
                                                                       !02814i0D
                                                                       !02814i0E
                                                                       !02814q00
    if pct.options.mult^crncy = "N" and                                !02814q01
       base24^rel^g >= 6            then                               !02814q02
                                                                       !02814q03
        begin                                                          !02814i0G
        if psem.setl^crncy <> blanks for $len( psem.setl^crncy ) then  !02814i0H
            begin                                                      !02814i0I
            if psem.setl^crncy <> pct.crncy^cde for                    !02814i0J
                   $len( psem.setl^crncy ) then                        !02814i0K
                begin                                                  !02814i0L
                return false;                                          !02814i0M
                end;                                                   !02814i0N
            end                                                        !02814i0O
        else                                                           !02814i0P
            begin                                                      !02814i0Q
            if psem.crncy^cde <> pct.crncy^cde for                     !02814i0R
                   $len( psem.setl^crncy ) then                        !02814i0S
                begin                                                  !02814i0T
                return false;                                          !02814i0U
                end;                                                   !02814i0V
            end;                                                       !02814i0W
        end;                                                           !02814i0X
                                                                       !02814i0Y
                                                                       !02814L2J
    if  pstm.typ = pstm^request^d or                                   !02814L2K
        pstm.typ = pstm^tran^advice^d then                             !02814L2L
        begin                                                          !02814L2M
        if  not pstm^inquiry^d( pstm ) then                            !02814L2N
            begin                                                      !02814L2O
                                                                       !N0281402
            if use^setl^crncy^amts^d( psem ) then                      !N0281403
                                                                       !N0281404
                                                                       !N0281405
                                                                       !N0281406
                                                                       !N0281407
                begin                                                  !02814L2R
                if  not ascii^fixed^( psem.setl^amt,                   !02814L2S
                                  pstm^amt ) then                      !02814L2T
                    return false;                                      !02814L2U
                if  not sub^convert^fixed^amt( pstm^amt,               !02814L2V
                                        pct.crncy.sell^rate ) then     !02814L2W
                    return false;                                      !02814L2X
                set ( pstm.tran.amt^1, pstm^amt );                     !02814L2Y
                end                                                    !02814L2Z
            else                                                       !02814L30
                begin                                                  !02814L31
                                                                       !02814i0Z
                if not ascii^fixed^( psem.tran^amt,                    !02814i0a
                                     pstm^amt ) then                   !02814i0b
                    begin                                              !02814i0c
                    return false;                                      !02814i0d
                    end;                                               !02814i0e
                                                                       !02814i0f
                if not sub^convert^fixed^amt(                          !02814i0g
                           pstm^amt,                                   !02814i0h
                           pct.crncy.sell^rate ) then                  !02814i0i
                    begin                                              !02814i0j
                    return false;                                      !02814i0k
                    end;                                               !02814i0l
                                                                       !02814i0m
                set( pstm.tran.amt^1, pstm^amt );                      !02814i0n
                                                                       !02814i0o
                                                                       !02814i0p
                                                                       !02814i0q
                                                                       !02814i0r
                end;                                                   !02814L39
                                                                       !02814j00
            if pct.options.mult^crncy = "N" and                        !02814j01
               ( psem.crncy^cde <> local^crncy^cde^g                   !02814j02
                     for $len( psem.crncy^cde ) ) then                 !02814j03
                begin                                                  !02814j04
                !                                                     !!02814j05
                ! Add the Original Currency 6.0 token                 !!02814j06
                !                                                     !!02814j07
                call pos^util^orig^crncy^tkn^add( sem, pstm );         !02814j08
                end;                                                   !02814j09
                                                                       !02814j0A
                                                                       !02814Z00
            if ( pos^pur^w^cash^back^d( sem )      or                  !02814Z01
                 pstm^pre^auth^d( pstm )           or                  !02814Z02
                 pstm^pre^auth^compl^d ( pstm ) ) and                  !02814Z03
                 psem.add^amts.b24^def.amt <> blanks                   !02814Z04
                         for $len( psem.add^amts.b24^def.amt ) then    !02814Z05
                                                                       !02814Z06
                                                                       !02814Z07
                                                                       !02814Z08
                begin                                                  !02814L3B
                                                                       !N0281408
                if use^setl^crncy^amts^d( psem ) then                  !N0281409
                                                                       !N028140A
                                                                       !N028140B
                                                                       !N028140C
                                                                       !N028140D
                    begin                                              !02814L3E
                    if  not ascii^fixed^( psem.add^amts.b24^def.amt,   !02814L3F
                                                  pstm^amt2 ) then     !02814L3G
                        return false;                                  !02814L3H
                                                                       !02814l00
                    if enhanced^crncy^conv^pos^d then                  !02814l01
                        begin                                          !02814l02
                        if not ascii^fixed^(                           !02814l03
                                   psem.add^amts.b24^def.setl^amt,     !02814l04
                                   pstm^amt2 ) then                    !02814l05
                            begin                                      !02814l06
                            return false;                              !02814l07
                            end;                                       !02814l08
                        end;                                           !02814l09
                                                                       !02814l0A
                    if  not sub^convert^fixed^amt( pstm^amt2,          !02814L3I
                                        pct.crncy.sell^rate ) then     !02814L3J
                        return false;                                  !02814L3K
                    set ( pstm.tran.amt^2, pstm^amt2 );                !02814L3L
                    end                                                !02814L3M
                else                                                   !02814L3N
                                                                       !02814i0s
                    begin                                              !02814i0t
                    if not ascii^fixed^( psem.add^amts.b24^def.amt,    !02814i0u
                                         pstm^amt2 ) then              !02814i0v
                        begin                                          !02814i0w
                        return false;                                  !02814i0x
                        end;                                           !02814i0y
                                                                       !02814i0z
                    if not sub^convert^fixed^amt(                      !02814i10
                               pstm^amt2,                              !02814i11
                               pct.crncy.sell^rate ) then              !02814i12
                        begin                                          !02814i13
                        return false;                                  !02814i14
                        end;                                           !02814i15
                                                                       !02814i16
                    set( pstm.tran.amt^2, pstm^amt2 );                 !02814i17
                    end;                                               !02814i18
                                                                       !02814i19
                                                                       !02814i1A
                                                                       !02814i1B
                                                                       !02814i1C
                end;                                                   !02814L3R

!**********************************************************************
! BEGIN RPQ #26 - Allways move amount-2 into PSTM
!**********************************************************************
            if pstm.typ = "0220" and
               ( pos^adjustment^d ( sem ) or
                 pos^adj^mdse^ret^d ( sem ) ) then
              begin
              end
            else
             Begin
              if psem.setl^crncy <> blanks
                               for $len( psem.setl^crncy ) then
                begin
                 if psem.add^amts.len <> "   " and
                    psem.add^amts.len <> "000"   then
                    begin
                     if  not ascii^fixed^( psem.add^amts.b24^def.amt,
                                           pstm^amt2 ) then
                         return false;
                     if  not sub^convert^fixed^amt( pstm^amt2,
                                         pct.crncy.sell^rate ) then
                         return false;
                     set ( pstm.tran.amt^2, pstm^amt2 );
                     if  fixed^ascii^( pstm.tran.rpq.rpq^fld.byte[0],
                                       pstm^amt2 ) then
                         return false;
                    end
                 else
                  begin
                   pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
                   pstm.tran.amt^2 := 0f;
                  end;
                end
              else
               begin
                if psem.add^amts.len <> "   " and
                   psem.add^amts.len <> "000"   then
                   begin
                   if  not ascii^fixed^( psem.add^amts.b24^def.amt,
                                         pstm.tran.amt^2 ) then
                        return false;
                   pstm.tran.rpq.rpq^fld.byte[0] ':='
                                 psem.add^amts.b24^def.amt for
                                 $len( psem.add^amts.b24^def.amt );
                   end
                else
                 begin
                   pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
                   pstm.tran.amt^2 := 0f;
                 end;
               end;

             End;
!*--------------------------------------------------------------------*
! END   RPQ #26 - Allways move amount-2 into PSTM
!**********************************************************************

            if  pos^adjustment^d( sem ) then                           !02814L3S
                begin                                                  !02814L3T
                                                                       !N028140E
                if use^setl^crncy^amts^d( psem ) then                  !N028140F
                                                                       !N028140G
                                                                       !N028140H
                                                                       !N028140I
                                                                       !N028140J
                    begin                                              !02814L3W
                    if  not ascii^fixed^( ssem.replacement.amt,        !02814L3X
                                          pstm^amt2 ) then             !02814L3Y
                        return false;                                  !02814L3Z
                                                                       !02814l0B
                    if enhanced^crncy^conv^pos^d then                  !02814l0C
                        begin                                          !02814l0D
                        if not ascii^fixed^(                           !02814l0E
                                   ssem.replacement.setl^amt,          !02814l0F
                                   pstm^amt2 ) then                    !02814l0G
                            begin                                      !02814l0H
                            return false;                              !02814l0I
                            end;                                       !02814l0J
                        end;                                           !02814l0K
                                                                       !02814l0L
                    if  not sub^convert^fixed^amt( pstm^amt2,          !02814L40
                                        pct.crncy.sell^rate ) then     !02814L41
                        return false;                                  !02814L42
                                                                       !02814i1D
                                                                       !02814i1E
                                                                       !02814i1F
                    set ( pstm.tran.amt^2, pstm^amt2 );                !02814L47
                    end                                                !02814L48
                else                                                   !02814L49
                    begin                                              !02814L4A
                                                                       !02814i1G
                    if not ascii^fixed^( ssem.replacement.amt,         !02814i1H
                                         pstm^amt2 ) then              !02814i1I
                        begin                                          !02814i1J
                        return false;                                  !02814i1K
                        end;                                           !02814i1L
                                                                       !02814i1M
                    if not sub^convert^fixed^amt(                      !02814i1N
                               pstm^amt2,                              !02814i1O
                               pct.crncy.sell^rate ) then              !02814i1P
                        begin                                          !02814i1Q
                        return false;                                  !02814i1R
                        end;                                           !02814i1S
                                                                       !02814i1T
                    set( pstm.tran.amt^2, pstm^amt2 );                 !02814i1U
                                                                       !02814i1V
                                                                       !02814i1W
                                                                       !02814i1X
                                                                       !02814i1Y
                    end;                                               !02814L4I
                end;                                                   !02814L4J
            end;                                                       !02814L4K
        if  psem.setl^crncy <> blanks                                  !02814L4L
                                 for $len( psem.setl^crncy ) then      !02814L4M
            begin                                                      !02814L4N
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814L4O
                                                   psem.setl^crncy );  !02814L4P
            move( pstm.tran.mult^crncy.setl^conv^rate,                 !02814L4Q
                                                psem.setl^conv^rat );  !02814L4R
                                                                       !02814i1Z
            end                                                        !02814i1a
        else                                                           !02814i1b
            begin                                                      !02814i1c
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814i1d
                  psem.crncy^cde );                                    !02814i1e
            movd( pstm.tran.mult^crncy.setl^conv^rate, "61000000" );   !02814i1f
            end;                                                       !02814i1g
                                                                       !02814i1h
        mov^( pstm.tran.mult^crncy.auth^crncy^cde,                     !02814i1i
              local^crncy^cde^g );                                     !02814i1j
        move( pstm.tran.mult^crncy.auth^conv^rate,                     !02814i1k
              pct.crncy.sell^rate );                                   !02814i1l
        pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();        !02814i1m
                                                                       !02814i1n
                                                                       !02814i1o
                                                                       !02814i1p
                                                                       !02814i1q
        end;                                                           !02814L4Y
                                                                       !02814L4Z
    if  pstm.typ = pstm^response^d then                                !02814L50
        begin                                                          !02814L51
                                                                       !O0281407
        if pstm^inquiry^d( pstm ) then                                 !O0281408
            begin                                                      !O0281409
            if psem.setl^crncy <> blanks                               !O028140A
                             for $len( psem.setl^crncy ) then          !O028140B
                begin                                                  !O028140C
                                                                       !O028140D
                                                                       !O028140E
                                                                       !O028140F
                                                                       !O028140G
                                                                       !02814r03
                                                                       !N028140K
                                                                       !N028140L
                                                                       !N028140M
                                                                       !02814r09
                                                                       !N028140N
                                                                       !O028140H
                call all^ascii^fixed^( psem.setl^amt,                  !O028140I
                                       pstm^amt );                     !O028140J
                                                                       !O028140K
                                                                       !O028140L
                                                                       !O028140M
                                                                       !O028140N
                                                                       !N028140Q
                                                                       !N028140R
                                                                       !N028140S
                                                                       !N028140T
                                                                       !02814r0A
                                                                       !N028140U
                                                                       !N028140V
                                                                       !N028140W
                                                                       !02814r0G
                                                                       !O028140O
                if not sub^convert^fixed^amt( pstm^amt,                !O028140P
                                     pct.crncy.sell^rate ) then        !O028140Q
                    begin                                              !O028140R
                    return false;                                      !O028140S
                                                                       !O028140T
                                                                       !O028140U
                                                                       !O028140V
                                                                       !O028140W
                                                                       !O028140X
                    end;                                               !O028140Y
                                                                       !O028140Z
                                                                       !02814i26
                                                                       !02814i27
                                                                       !O028140a
                set ( pstm.tran.amt^1, pstm^amt );                     !O028140b
                end                                                    !O028140c
            else                                                       !O028140d
                begin                                                  !O028140e
                call all^ascii^fixed^( psem.tran^amt,                  !O028140f
                                                                       !O028140g
                                                                       !O028140h
                                                                       !O028140i
                                                                       !O028140j
                                                                       !02814i28
                                           pstm^amt );                 !02814i29
                                                                       !N028140X
                                                                       !N028140Y
                                                                       !N028140Z
                                                                       !02814i2G
                                                                       !O028140k
                set( pstm.tran.amt^1, pstm^amt );                      !O028140l
                                                                       !O028140m
                                                                       !O028140n
                                                                       !O028140o
                                                                       !02814i2I
                                                                       !02814i2J
                                                                       !02814i2K
                                                                       !02814i2L
                                                                       !O028140p
                end;                                                   !O028140q
            end;                                                       !O028140r
                                                                       !O028140s
                                                                       !O028140t
                                                                       !O028140u
                                                                       !O028140v
                                                                       !02814L6V
        if  psem.setl^crncy <> blanks                                  !02814L6W
                                 for $len( psem.setl^crncy ) then      !02814L6X
            begin                                                      !02814L6Y
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814L6Z
                                                   psem.setl^crncy );  !02814L70
            move( pstm.tran.mult^crncy.setl^conv^rate,                 !02814L71
                                                psem.setl^conv^rat );  !02814L72
                                                                       !02814i2M
            end                                                        !02814i2N
        else                                                           !02814i2O
            begin                                                      !02814i2P
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814i2Q
                  psem.crncy^cde );                                    !02814i2R
            movd( pstm.tran.mult^crncy.setl^conv^rate, "61000000" );   !02814i2S
            end;                                                       !02814i2T
                                                                       !02814i2U
                                                                       !02814i2V
                                                                       !02814i2W
        if  psem.bill^crncy <> blanks                                  !02814L74
                                 for $len( psem.bill^crncy ) then      !02814L75
            begin                                                      !02814L76
            move( pstm.tran.mult^crncy.auth^crncy^cde,                 !02814L77
                                                   psem.bill^crncy );  !02814L78
            move( pstm.tran.mult^crncy.auth^conv^rate,                 !02814L79
                                                psem.bill^conv^rat );  !02814L7A
                                                                       !02814i2X
                                                                       !02814i2Y
                                                                       !02814i2Z
            end;                                                       !02814L7H
!**********************************************************************
! BEGIN RPQ #26 - Allways move amount-2 into PSTM
!*--------------------------------------------------------------------*
!             if psem.setl^crncy <> blanks
!                              for $len( psem.setl^crncy ) then
!               begin
!                if psem.add^amts.len <> "   " and
!                   psem.add^amts.len <> "000"   then
!                   begin
!                    if  not ascii^fixed^( psem.add^amts.b24^def.amt,
!                                          pstm^amt2 ) then
!                        return false;
!                    if  not sub^convert^fixed^amt( pstm^amt2,
!                                        pct.crncy.sell^rate ) then
!                        return false;
!                    set ( pstm.tran.amt^2, pstm^amt2 );
!                    if  fixed^ascii^( pstm.tran.rpq.rpq^fld.byte[0],
!                                      pstm^amt2 ) then
!                        return false;
!                   end
!                else
!                 begin
!                  pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
!                  pstm.tran.amt^2 := 0f;
!                 end;
!               end
!             else
!              begin
!               if psem.add^amts.len <> "   " and
!                  psem.add^amts.len <> "000"   then
!                  begin
!                  if  not ascii^fixed^( psem.add^amts.b24^def.amt,
!                                        pstm.tran.amt^2 ) then
!                       return false;
!                  pstm.tran.rpq.rpq^fld.byte[0] ':='
!                                psem.add^amts.b24^def.amt for
!                                $len( psem.add^amts.b24^def.amt );
!                  end
!               else
!                begin
!                  pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
!                  pstm.tran.amt^2 := 0f;
!                end;
!              end;

!*--------------------------------------------------------------------*
! END   RPQ #26 - Allways move amount-2 into PSTM
!**********************************************************************

        end;                                                           !02814L7I
                                                                       !02814L7J
    if  pstm.typ = pstm^rvsl^request^d then                            !02814L7K
        begin                                                          !02814L7L
                                                                       !N028140a
        if use^setl^crncy^amts^d( psem ) then                          !N028140b
                                                                       !N028140c
                                                                       !N028140d
                                                                       !N028140e
                                                                       !N028140f
            begin                                                      !02814L7O
            if  not ascii^fixed^( psem.setl^amt, pstm^amt ) then       !02814L7P
                return false;                                          !02814L7Q
            if  not sub^convert^fixed^amt( pstm^amt,                   !02814L7R
                                         pct.crncy.sell^rate ) then    !02814L7S
                return false;                                          !02814L7T
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814L7U
                                                   psem.setl^crncy );  !02814L7V
            move( pstm.tran.mult^crncy.setl^conv^rate,                 !02814L7W
                                                psem.setl^conv^rat );  !02814L7X
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !02814L7Y
            set ( pstm.tran.amt^1, pstm^amt );                         !02814L7Z
            end                                                        !02814L80
        else                                                           !02814L81
            begin                                                      !02814L82
                                                                       !02814i2a
            if not ascii^fixed^( psem.tran^amt, pstm^amt ) then        !02814i2b
                begin                                                  !02814i2c
                return false;                                          !02814i2d
                end;                                                   !02814i2e
                                                                       !02814i2f
            if not sub^convert^fixed^amt( pstm^amt,                    !02814i2g
                                          pct.crncy.sell^rate ) then   !02814i2h
                begin                                                  !02814i2i
                return false;                                          !02814i2j
                end;                                                   !02814i2k
                                                                       !02814i2l
                                                                       !02814i2m
                                                                       !02814i2n
                                                                       !02814i2o
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !02814L86
                                                   psem.crncy^cde );   !02814L87
                                                                       !02814i2p
            movd( pstm.tran.mult^crncy.setl^conv^rate, "61000000" );   !02814i2q
            set( pstm.tran.amt^1, pstm^amt );                          !02814i2r
                                                                       !02814i2s
                                                                       !02814i2t
                                                                       !02814i2u
            end;                                                       !02814L89
                                                                       !02814L8A
        if  ssem.replacement.amt <> blanks                             !02814L8B
                               for $len( ssem.replacement.amt ) then   !02814L8C
            begin                                                      !02814L8D
                                                                       !N028140g
            if use^setl^crncy^amts^d( psem ) then                      !N028140h
                                                                       !N028140i
                                                                       !N028140j
                                                                       !N028140k
                                                                       !N028140l
                begin                                                  !02814L8G
                if  not ascii^fixed^( ssem.replacement.amt,            !02814L8H
                                      pstm^amt2 ) then                 !02814L8I
                    return false;                                      !02814L8J
                                                                       !02814l0M
                if enhanced^crncy^conv^pos^d then                      !02814l0N
                    begin                                              !02814l0O
                    if not ascii^fixed^( ssem.replacement.setl^amt,    !02814l0P
                                         pstm^amt2 ) then              !02814l0Q
                        begin                                          !02814l0R
                        return false;                                  !02814l0S
                        end;                                           !02814l0T
                    end;                                               !02814l0U
                                                                       !02814l0V
                if  not sub^convert^fixed^amt( pstm^amt2,              !02814L8K
                                         pct.crncy.sell^rate ) then    !02814L8L
                    return false;                                      !02814L8M
                set ( pstm.tran.amt^2, pstm^amt2 );                    !02814L8N
                end                                                    !02814L8O
            else                                                       !02814L8P
                begin                                                  !02814L8Q
                                                                       !02814i2v
                if not ascii^fixed^( ssem.replacement.amt,             !02814i2w
                                     pstm^amt2 ) then                  !02814i2x
                    begin                                              !02814i2y
                    return false;                                      !02814i2z
                    end;                                               !02814i30
                                                                       !02814i31
                if not sub^convert^fixed^amt(                          !02814i32
                           pstm^amt2,                                  !02814i33
                           pct.crncy.sell^rate ) then                  !02814i34
                    begin                                              !02814i35
                    return false;                                      !02814i36
                    end;                                               !02814i37
                                                                       !02814i38
                set( pstm.tran.amt^2, pstm^amt2 );                     !02814i39
                                                                       !02814i3A
                                                                       !02814i3B
                                                                       !02814i3C
                                                                       !02814i3D
                end;                                                   !02814L8U
            end;                                                       !02814L8V
                                                                       !02814L8W
        if  psem.add^amts.b24^def.amt <> blanks for                    !02814L8X
                               $len( psem.add^amts.b24^def.amt ) then  !02814L8Y
        ! Reversal for a purchase with cash back                      !
            begin                                                      !02814L90
                                                                       !N028140m
            if use^setl^crncy^amts^d( psem ) then                      !N028140n
                                                                       !N028140o
                                                                       !N028140p
                                                                       !N028140q
                                                                       !N028140r
                begin                                                  !02814L93
                if  not ascii^fixed^( psem.add^amts.b24^def.amt,       !02814L94
                                      pstm^amt2 ) then                 !02814L95
                    return false;                                      !02814L96
                                                                       !02814l0W
                if enhanced^crncy^conv^pos^d then                      !02814l0X
                    begin                                              !02814l0Y
                    if not ascii^fixed^(                               !02814l0Z
                               psem.add^amts.b24^def.setl^amt,         !02814l0a
                               pstm^amt2 ) then                        !02814l0b
                        begin                                          !02814l0c
                        return false;                                  !02814l0d
                        end;                                           !02814l0e
                    end;                                               !02814l0f
                                                                       !02814l0g
                if  not sub^convert^fixed^amt( pstm^amt2,              !02814L97
                                         pct.crncy.sell^rate ) then    !02814L98
                    return false;                                      !02814L99
                set ( pstm.tran.amt^2, pstm^amt2 );                    !02814L9A
                end                                                    !02814L9B
            else                                                       !02814L9C
                begin                                                  !02814L9D
                                                                       !02814i3E
                if not ascii^fixed^( psem.add^amts.b24^def.amt,        !02814i3F
                                     pstm^amt2 ) then                  !02814i3G
                    begin                                              !02814i3H
                    return false;                                      !02814i3I
                    end;                                               !02814i3J
                                                                       !02814i3K
                if not sub^convert^fixed^amt(                          !02814i3L
                           pstm^amt2,                                  !02814i3M
                           pct.crncy.sell^rate ) then                  !02814i3N
                    begin                                              !02814i3O
                    return false;                                      !02814i3P
                    end;                                               !02814i3Q
                                                                       !02814i3R
                set( pstm.tran.amt^2, pstm^amt2 );                     !02814i3S
                                                                       !02814i3T
                                                                       !02814i3U
                                                                       !02814i3V
                                                                       !02814i3W
                end;                                                   !02814L9H
            end;                                                       !02814L9I
        end;                                                           !02814L9J
                                                                       !02814L9K
    if  pstm.typ = pstm^rvsl^advice^d then                             !02814L9L
        begin                                                          !02814L9M

!**********************************************************************
! BEGIN RPQ #26 - Allways move amount-2 into PSTM
!*--------------------------------------------------------------------*
              if psem.setl^crncy <> blanks
                               for $len( psem.setl^crncy ) then
                begin
                 if psem.add^amts.len <> "   " and
                    psem.add^amts.len <> "000"   then
                    begin
                     if  not ascii^fixed^( psem.add^amts.b24^def.amt,
                                           pstm^amt2 ) then
                         return false;
                     if  not sub^convert^fixed^amt( pstm^amt2,
                                         pct.crncy.sell^rate ) then
                         return false;
                     set ( pstm.tran.amt^2, pstm^amt2 );
                     if  fixed^ascii^( pstm.tran.rpq.rpq^fld.byte[0],
                                       pstm^amt2 ) then
                         return false;
                    end
                 else
                  begin
                   pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
                   pstm.tran.amt^2 := 0f;
                  end;
                end
              else
               begin
                if psem.add^amts.len <> "   " and
                   psem.add^amts.len <> "000"   then
                   begin
                   if  not ascii^fixed^( psem.add^amts.b24^def.amt,
                                         pstm.tran.amt^2 ) then
                        return false;
                   pstm.tran.rpq.rpq^fld.byte[0] ':='
                                 psem.add^amts.b24^def.amt for
                                 $len( psem.add^amts.b24^def.amt );
                   end
                else
                 begin
                   pstm.tran.rpq.rpq^fld.byte[0] ':=' "000000000000";
                   pstm.tran.amt^2 := 0f;
                 end;
               end;
!*--------------------------------------------------------------------*
! END   RPQ #26 - Allways move amount-2 into PSTM
!**********************************************************************
                                                                       !N028140s
        if use^setl^crncy^amts^d( psem ) then                          !N028140t
                                                                       !N028140u
                                                                       !N028140v
                                                                       !N028140w
                                                                       !N028140x
            begin                                                      !02814L9P
            if  not ascii^fixed^( psem.setl^amt, pstm^amt ) then       !02814L9Q
                return false;                                          !02814L9R
            if  not sub^convert^fixed^amt( pstm^amt,                   !02814L9S
                                                                       !02814%00
                                           pct.crncy.sell^rate ) then  !02814%01
                                                                       !02814%02
                return false;                                          !02814L9U
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !02814L9V
            set ( pstm.tran.amt^1, pstm^amt );                         !02814L9W
            end                                                        !02814L9X
        else                                                           !02814L9Y
            begin                                                      !02814L9Z
                                                                       !02814i3X
            if not ascii^fixed^( psem.tran^amt, pstm^amt ) then        !02814i3Y
                begin                                                  !02814i3Z
                return false;                                          !02814i3a
                end;                                                   !02814i3b
                                                                       !02814i3c
            if not sub^convert^fixed^amt(                              !02814i3d
                       pstm^amt,                                       !02814i3e
                                                                       !02814%03
                       pct.crncy.sell^rate ) then                      !02814%04
                                                                       !02814%05
                begin                                                  !02814i3g
                return false;                                          !02814i3h
                end;                                                   !02814i3i
                                                                       !02814i3j
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !02814i3k
            set( pstm.tran.amt^1, pstm^amt );                          !02814i3l
                                                                       !02814i3m
                                                                       !02814i3n
                                                                       !02814i3o
                                                                       !02814i3p
            end;                                                       !02814LA3
                                                                       !02814j0B
        if pct.options.mult^crncy = "N" and                            !02814j0C
           ( psem.crncy^cde <> local^crncy^cde^g                       !02814j0D
                 for $len( psem.crncy^cde ) ) then                     !02814j0E
            begin                                                      !02814j0F
            !                                                         !!02814j0G
            ! Add the Original Currency 6.0 token                     !!02814j0H
            !                                                         !!02814j0I
            call pos^util^orig^crncy^tkn^add( sem, pstm );             !02814j0J
            end;                                                       !02814j0K
                                                                       !02814j0L
                                                                       !02814LA4
        if  ssem.replacement.amt <> blanks                             !02814LA5
                                for $len( ssem.replacement.amt ) then  !02814LA6
            begin                                                      !02814LA7
                                                                       !N028140y
            if use^setl^crncy^amts^d( psem ) then                      !N028140z
                                                                       !N0281410
                                                                       !N0281411
                                                                       !N0281412
                                                                       !N0281413
                begin                                                  !02814LAA
                if  not ascii^fixed^( ssem.replacement.amt,            !02814LAB
                                      pstm^amt2 ) then                 !02814LAC
                    return false;                                      !02814LAD
                                                                       !02814l0h
                if enhanced^crncy^conv^pos^d then                      !02814l0i
                    begin                                              !02814l0j
                    if not ascii^fixed^( ssem.replacement.setl^amt,    !02814l0k
                                         pstm^amt2 ) then              !02814l0l
                        begin                                          !02814l0m
                        return false;                                  !02814l0n
                        end;                                           !02814l0o
                    end;                                               !02814l0p
                                                                       !02814l0q
                if  not sub^convert^fixed^amt( pstm^amt2,              !02814LAE
                       pstm.tran.mult^crncy.auth^conv^rate ) then      !02814LAF
                    return false;                                      !02814LAG
                set ( pstm.tran.amt^2, pstm^amt2 );                    !02814LAH
                end                                                    !02814LAI
            else                                                       !02814LAJ
                begin                                                  !02814LAK
                                                                       !02814i3q
                if not ascii^fixed^( ssem.replacement.amt,             !02814i3r
                                     pstm^amt2 ) then                  !02814i3s
                    begin                                              !02814i3t
                    return false;                                      !02814i3u
                    end;                                               !02814i3v
                                                                       !02814i3w
                if not sub^convert^fixed^amt(                          !02814i3x
                           pstm^amt2,                                  !02814i3y
                           pstm.tran.mult^crncy.auth^conv^rate ) then  !02814i3z
                    begin                                              !02814i40
                    return false;                                      !02814i41
                    end;                                               !02814i42
                                                                       !02814i43
                set( pstm.tran.amt^2, pstm^amt2 );                     !02814i44
                                                                       !02814i45
                                                                       !02814i46
                                                                       !02814i47
                                                                       !02814i48
                end;                                                   !02814LAO
            end;                                                       !02814LAP
                                                                       !02814LAQ
        if  psem.add^amts.b24^def.amt <> blanks for                    !02814LAR
                               $len( psem.add^amts.b24^def.amt ) then  !02814LAS
        ! Reversal for a purchase with cash back                      !
            begin                                                      !02814LAV
                                                                       !N0281414
            if use^setl^crncy^amts^d( psem ) then                      !N0281415
                                                                       !N0281416
                                                                       !N0281417
                                                                       !N0281418
                                                                       !N0281419
                begin                                                  !02814LAY
                if  not ascii^fixed^( psem.add^amts.b24^def.amt,       !02814LAZ
                                      pstm^amt2 ) then                 !02814LB0
                    return false;                                      !02814LB1
                                                                       !02814l0r
                if enhanced^crncy^conv^pos^d then                      !02814l0s
                    begin                                              !02814l0t
                    if not ascii^fixed^(                               !02814l0u
                               psem.add^amts.b24^def.setl^amt,         !02814l0v
                               pstm^amt2 ) then                        !02814l0w
                        begin                                          !02814l0x
                        return false;                                  !02814l0y
                        end;                                           !02814l0z
                    end;                                               !02814l10
                                                                       !02814l11
                if  not sub^convert^fixed^amt( pstm^amt2,              !02814LB2
                       pstm.tran.mult^crncy.auth^conv^rate ) then      !02814LB3
                    return false;                                      !02814LB4
                set ( pstm.tran.amt^2, pstm^amt2 );                    !02814LB5
                end                                                    !02814LB6
            else                                                       !02814LB7
                begin                                                  !02814LB8
                                                                       !02814i49
                if not ascii^fixed^( psem.add^amts.b24^def.amt,        !02814i4A
                                     pstm^amt2 ) then                  !02814i4B
                    begin                                              !02814i4C
                    return false;                                      !02814i4D
                    end;                                               !02814i4E
                                                                       !02814i4F
                if not sub^convert^fixed^amt(                          !02814i4G
                           pstm^amt2,                                  !02814i4H
                           pstm.tran.mult^crncy.auth^conv^rate ) then  !02814i4I
                    begin                                              !02814i4J
                    return false;                                      !02814i4K
                    end;                                               !02814i4L
                                                                       !02814i4M
                set( pstm.tran.amt^2, pstm^amt2 );                     !02814i4N
                                                                       !02814i4O
                                                                       !02814i4P
                                                                       !02814i4Q
                                                                       !02814i4R
                end;                                                   !02814LBC
            end;                                                       !02814LBD
        end;                                                           !02814LBE
                                                                       !02814LBF
    return true;                                                       !02814LBG
    end;                                                               !02814LBH
                                                                       !02814LBI
                                                                       !02814LBJ
?section pos^frmt^sem^to^pstm^tkn                                      !02814K01
?page                            "pos^frmt^sem^to^pstm^tkn"            !02814K02
!#####################################################################!!02814K03
!#                                                                   #!!02814K04
!#                    POS^FRMT^SEM^TO^PSTM^TKN                       #!!02814K05
!#                                                                   #!!02814K06
!#    This proc formats SEM token data to PSTM token data.           #!!02814K07
!#                                                                   #!!02814K08
!#    INPUT PARAMETERS:                                              #!!02814K09
!#        sem     :  Standard External Message                       #!!02814K0A
!#                                                                   #!!02814K0B
!#    OUTPUT PARAMETERS:                                             #!!02814K0C
!#        pstm     : POS Standard Internal Message                   #!!02814K0D
!#                                                                   #!!02814K0E
!#    RETURNS:                                                       #!!02814K0F
!#        True  = Format was successful                              #!!02814K0G
!#        False = Format was not successful                          #!!02814K0H
!#                                                                   #!!02814K0I
!#####################################################################!!02814K0J
int proc pos^frmt^sem^to^pstm^tkn( sem, pstm );                        !02814K0K
struct         .sem( sem^def );                                        !02814K0L
struct         .pstm( pstm^def );                                      !02814K0M
                                                                       !02814K0N
    begin                                                              !02814K0O
    int                                                                !02814K0P
                    pan^lgth,                                          !02814K0Q
                    resp,                                              !02814K0R
                    tkn^ofst;                                          !02814K0S
                                                                       !02814K0T
    string                                                             !02814K0U
                    bit[0:2],                                          !02814K0V
                   .pan[ 0:max^pan^lgth^l - 1 ];                       !02814K0W
                                                                       !02814K0X
    if psem.pri^rsrvd4^prvt.len <> "000" and                           !02814K0Y
       psem.pri^rsrvd4^prvt.len <> "   " and                           !02814K0Z
                                                                       !02814U00
       ( pct.options.version^num = "60" or                             !02814U01
         pct.options.version^num = "01" ) then                         !02814U02
                                                                       !02814U03
                                                                       !02814U04
                                                                       !02814U05
        begin                                                          !02814K11
        movd( bit, "063" );                                            !02814K12
                                                                       !02814K13
        pan^lgth := -1;                                                !02814K14
        while ( ( pan^lgth := pan^lgth + 1 ) < max^pan^lgth^l ) and    !02814K15
                  $numeric( psem.track2.data.byte[ pan^lgth ] ) do;    !02814K16
        init ( pan, " ", $occurs( pan ) );                             !02814K17
        movl ( pan, psem.track2.data, pan^lgth );                      !02814K18
                                                                       !02814K19
        if pstm.typ = pstm^response^d      or                          !02814K1A
                                                                       !02814w00
           pstm.typ = pstm^tran^advice^d   or                          !02814w01
                                                                       !02814w02
           pstm.typ = pstm^rvsl^response^d or                          !02814K1B
           pstm.typ = pstm^rvsl^advice^d   then                        !02814K1C
            resp := true                                               !02814K1D
        else                                                           !02814K1E
            resp := false;                                             !02814K1F
                                                                       !02814K1G
        if not hiswtkn^frmt^ext^tkn^to^int^tkn(                        !02814K1H
                                    pos^l, pstm, pstm^lgth^d( pstm ),  !02814K1I
                                                                       !02814M00
                                    psem.pri^rsrvd4^prvt.pos.add^data, !02814M01
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !02814M02
                                                                       !02814M03
                                                                       !02814M04
                                                                       !02814M05
                                                                       !02814M06
                                    psem.pri^rsrvd4^prvt.len, bit,     !02814K1L
                                    psem.retrvl^ref^num, pan,          !02814K1M
                                    pstm.data^flag, resp ) then        !02814K1N
            return false;                                              !02814K1O
        end;                                                           !02814K1P
                                                                       !02814K1Q
    return true;                                                       !02814K1R
    end;                                                               !02814K1S
                                                                       !02814K1T
?section pos^frmt^sem^to^pstm^tran                                     !02815
?page "                               - pos^frmt^sem^to^pstm^tran"     !02815K00
!#####################################################################!!02818
!#                                                                   #!!02819
!#                  POS^FRMT^SEM^T0^PSTM^TRAN                        #!!02820
!#                                                                   #!!02821
!#    NARRATIVE : THIS PROCEDURE FORMATS THE BASE24 INTERNAL POS     #!!02822
!#       TRANSACTION CODE FROM THE BIC ISO EXTERNAL POS MESSAGE.     #!!02823
!#                                                                   #!!02824
!#    INPUT PARAMETERS:                                              #!!02825
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!02826
!#                                                                   #!!02827
!#    OUTPUT PARAMETERS:                                             #!!02828
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!02829
!#                                                                   #!!02830
!#####################################################################!!02831
int proc pos^frmt^sem^to^pstm^tran( sem, pstm );                       !02832
int .sem( sem^def );                                                   !02833
int .pstm( pstm^def );                                                 !02834
    begin                                                              !02835
    wlform( inv^tran^code,                                             !02836
    "INVALID Transaction Code \\ Received from Co-network" )           !02837
    wlform( inv^card^type,                                             !02838
    "INVALID Card Type Received from Co-network" )                     !02839
    wlform( inv^acct,                                                  !02840
    "Account Type has not been assigned"  )                            !02841
                                                                       !02842
    define    sem^code^d( i ) = tran^tbl[ ( i ) * 4 + 0 ]#,            !02843
              pstm^code^d( i )  = tran^tbl[ ( i ) * 4 + 2 ]#;          !02844
                                                                       !02845
    int       x, lim;                                                  !02846
                                                                       !02847
    string    tran^tbl = 'p' := [                                      !02848
    !                                                                 !!02849
    !        + -  BICI tran code  'Pos Table'    + - BASE24 tran code !!02850
    !        |                                   |                    !!02851
    !        v                                   v                    !!02852
           "00",  ! Normal Purchase        !   "10",                   !02853
           "01",  ! Cash Advance           !   "15",                   !02854
                                                                       !02855`00
                                                                       !02855`01
           "02",  ! Adj - Merchandise Retrn!   "22",                   !02855`02
           "03",  ! Check Guarantee        !   "20",                   !02855`03
                                                                       !02855`04
           "04",  ! Check Verification     !   "19",                   !02857
           "09",  ! Purchase with Cash Back!   "18",                   !02858
           "14",  ! Adj - Cash Advance     !   "23",                   !02859
           "19",  ! Adj - Purc. /w csh back!   "24",                   !02860
           "20",  ! Merchandise Return     !   "14",                   !02861
                                                                       !02862`00
           "22",  ! Adj - Purchase         !   "21",                   !02862`01
                                                                       !02862`02
           "30",  ! Balance Inquiry        !   "17",                   !02863
           "31",  ! Balance Inquiry        !   "17",                   !02864
           "80",  ! Mail/Phone Order       !   "13",                   !02865
           "81",  ! Card Verification      !   "16",                   !02866
            0 ];                                                       !02867
                                                                       !02868
    literal   acct^tbl^lim^l        = 12;                              !02869
                                                                       !02870
    define    pstm^card^type^0^d = "0"#, !Unspecified                 !!02871
              pstm^card^type^1^d = "1"#, !Credit                      !!02872
              pstm^card^type^2^d = "2"#; !Debit                       !!02873
                                                                       !02874
    define    sem^from^acct^d( i )  = acct^tbl[ ( i ) * 6 + 0 ]#,      !02875
              sem^to^acct^d( i )    = acct^tbl[ ( i ) * 6 + 2 ]#,      !02876
              pstm^acct^typ^d( i )  = acct^tbl[ ( i ) * 6 + 4 ]#;      !02877
                                                                       !02878
    string    acct^tbl = 'p' := [                                      !02879
    !                                                                 !!02880
    !                                                                 !!02881
    !        + - BICI From Acct. Type                                 !!02882
    !        :       + - BICI To Acct. Type                           !!02883
    !        :       :    + - BASE24 Tran Code AA                     !!02884
    !        :       :    :              CARD | ACCT.                 !!02885
    !        v       v    v              v      v                     !!02886
            "00",  "00", "00",         ! None   None                  !!02887
            "00",  "00", "00",         ! None   DDA                   !!02888
            "00",  "00", "00",         ! None   Savings               !!02889
            "00",  "00", "00",         ! None   Credit                !!02890
            "00",  "00", "00",         ! Cr.Crd None                  !!02891
            "00",  "20", "01",         ! Cr.Crd DDA                   !!02892
            "00",  "10", "11",         ! Cr.Crd Savings               !!02893
            "00",  "30", "31",         ! Cr.Crd Credit                !!02894
            "00",  "00", "00",         ! Db.Crd None                  !!02895
            "20",  "00", "01",         ! Db.Crd DDA                   !!02896
            "10",  "00", "11",         ! Db.Crd Savings               !!02897
            "30",  "00", "31"];        ! Db.Crd Credit                !!02898
                                                                       !02899
    !                                                                 !!02900
    ! Verify the transaction code                                     !!02901
    !                                                                 !!02902
    x := -1;                                                           !02903
    while sem^code^d( x:=x+1 ) and  psem.proc^cde.tran^cde <>          !02904
          sem^code^d( x ) for $len( psem.proc^cde.tran^cde ) do;       !02905
                                                                       !02906
    if  not sem^code^d( x ) then                                       !02907
        begin                                                          !02908
        call logmessage^( 1090, , @inv^tran^code, net.myname, 2,       !02909
            @pos^prod^g, @psem.proc^cde.tran^cde );                    !02910
        return false;                                                  !02911
        end;                                                           !02912
                                                                       !02913
    ! Assign the Transaction code                                     !!02914
                                                                       !02915
    movl ( pstm.tran.tran^cde.tc, pstm^code^d( x ),                    !02916
        $len( pstm.tran.tran^cde.tc ) );                               !02917
                                                                       !02918
    !                                                                 !!02919
    ! Determine if this is a pre-auth message                         !!02920
    !                                                                 !!02921
    if  pstm.tran.tran^cde.tc = pstm^^purchase^d then                  !02922
        begin                                                          !02923
        if  psem.typ.byte[ 1 ] = "1" then                              !02924
            !                                                         !!02925
            ! This is a 01xx series message and therefore             !!02926
            ! a pre-auth message                                      !!02927
            !                                                         !!02928
            movd ( pstm.tran.tran^cde.tc, pstm^^pre^auth^pur^d )       !02929
        else                                                           !02930
        !                                                             !!02931
        ! This is a non-authorization message, determine if           !!02932
        ! this is a pre-auth completion                               !!02933
        !                                                             !!02934
        if  psem.pt^tran^spcl^cde = "06" then                          !02935
            movd ( pstm.tran.tran^cde.tc, pstm^^pre^auth^compl^d );    !02936
        end;                                                           !02937
                                                                       !02938
    !                                                                 !!02939
    ! Verify the Card Type and Account Interval                       !!02940
    !                                                                 !!02941
    if  psem.proc^cde.from^acct^typ = "00" and                         !02942
        psem.proc^cde.to^acct^typ   = "00"   then                      !02943
        movd ( pstm.tran.tran^cde.t, pstm^card^type^0^d )              !02944
    else                                                               !02945
    if  psem.proc^cde.from^acct^typ = "00" and                         !02946
        psem.proc^cde.to^acct^typ  <> "00"   then                      !02947
        movd ( pstm.tran.tran^cde.t, pstm^card^type^1^d )              !02948
    else                                                               !02949
    if  psem.proc^cde.from^acct^typ <> "00" and                        !02950
        psem.proc^cde.to^acct^typ   =  "00"   then                     !02951
        movd ( pstm.tran.tran^cde.t, pstm^card^type^2^d )              !02952
    else                                                               !02953
    if  psem.proc^cde.from^acct^typ <> "00" and                        !02954
        psem.proc^cde.to^acct^typ   <> "00"   then                     !02955
        begin                                                          !02956
        call logmessage^( 1095, , @inv^card^type, net.myname, 2,       !02957
            @pos^prod^g );                                             !02958
        return false;                                                  !02959
        end;                                                           !02960
                                                                       !02961
    x := -1; lim := 4;                                                 !02962
                                                                       !02963
    if  pstm.tran.tran^cde.t = pstm^card^type^1^d  then                !02964
        begin                                                          !02965
        x := 3; lim := 8;                                              !02966
        end                                                            !02967
    else                                                               !02968
    if  pstm.tran.tran^cde.t = pstm^card^type^2^d  then                !02969
        begin                                                          !02970
        x := 7; lim := 12;                                             !02971
        end;                                                           !02972
                                                                       !02973
    while ( x := x + 1 ) < lim  and ( ( psem.proc^cde.from^acct^typ <> !02974
         sem^from^acct^d( x ) for 2 ) or ( psem.proc^cde.to^acct^typ <>
         sem^to^acct^d( x ) for 2 ) )  do;                             !02977
                                                                       !02978
    if  x = lim  then                                                  !02979
        begin                                                          !02980
        call logmessage^( 1100, , @inv^acct, net.myname, 2,            !02981
            @pos^prod^g );                                             !02982
        return false;                                                  !02983
        end;                                                           !02984
                                                                       !02985
    ! Assign the Account Type                                         !!02986
                                                                       !02987
    movl ( pstm.tran.tran^cde.aa, pstm^acct^typ^d( x ),                !02988
        $len( pstm.tran.tran^cde.aa ) );                               !02989
                                                                       !02990
    ! Assign the Category Code                                        !!02991
                                                                       !02992
    move ( pstm.tran.tran^cde.c, psem.pri^rsrvd2^prvt.pos.category );  !02993
                                                                       !02994
    pos^tran^cde^g ':=' pstm.tran.tran^cde for pos^tran^cde^lgth^l;    !02995
    return true;                                                       !02996
    end;                                                               !02997
                                                                       !02997K00
?SECTION pos^frmt^sem^to^sem^tkn                                       !02997K01
?PAGE                                "pos^frmt^sem^to^sem^tkn"         !02997K02
!#####################################################################!!02997K03
!#                                                                   #!!02997K04
!#                   POS^FRMT^SEM^TO^SEM^TKN                         #!!02997K05
!#                                                                   #!!02997K06
!#    This proc formats tokens from an external request to an        #!!02997K07
!#    external response, or an external response to an external      #!!02997K08
!#    reversal.  The TKN record is used to determine which token     #!!02997K09
!#    will be placed in the new external message.                    #!!02997K0A
!#                                                                   #!!02997K0B
!#    INPUT PARAMETERS:                                              #!!02997K0C
!#        SEM     :  Standard External Message                       #!!02997K0D
!#        TKN^GRP :  Token group                                     #!!02997K0E
!#                                                                   #!!02997K0F
!#    OUTPUT PARAMETERS:                                             #!!02997K0G
!#                                                                   #!!02997K0H
!#####################################################################!!02997K0I
proc pos^frmt^sem^to^sem^tkn( sem, tkn^grp );                          !02997K0J
struct     .sem( sem^def );                                            !02997K0K
string     .tkn^grp;                                                   !02997K0L
                                                                       !02997K0M
    begin                                                              !02997K0N
                                                                       !02997K0O
    struct                                                             !02997K0P
                   .tkn^mem^rec( tkn^mem^rec^def );                    !02997K0Q
                                                                       !02997K0R
    int                                                                !02997K0S
                   .orig^ext^fld[ 0:                                   !02997K0T
                                                                       !02997M00
                     $len( psem.pri^rsrvd4^prvt.pos.add^data ) / 2  ]; !02997M01
                                                                       !02997M02
                                                                       !02997M03
                                                                       !02997M04
                                                                       !02997K0V
    string                                                             !02997K0W
                   .orig^ext^fld^s := @orig^ext^fld '<<' 1,            !02997K0X
                   .subtyp[ 0:1 ],                                     !02997K0Y
                   .typ[ 0:1 ];                                        !02997K0Z
                                                                       !02997K10
    movd( typ,    financial^typ^d   );                                 !02997K11
    movd( subtyp, tkn^dflt^subtyp^d );                                 !02997K12
                                                                       !02997K13
    if tkn^name^g <> invalid^name^d          and                       !02997K14
                                                                       !02997U00
       ( pct.options.version^num = "60" or                             !02997U01
         pct.options.version^num = "01" ) and                          !02997U02
                                                                       !02997U03
                                                                       !02997U04
                                                                       !02997U05
       get^tkn^mem^rec( pos^tkn^tbl,, tkn^grp, typ, subtyp,            !02997K16
                        tkn^mem^rec, trace^g.<pos^l> ) then            !02997K17
        begin                                                          !02997K18
                                                                       !02997M05
        orig^ext^fld ':=' psem.pri^rsrvd4^prvt.pos.add^data for        !02997M06
                          $len( psem.pri^rsrvd4^prvt.pos.add^data );   !02997M07
                                                                       !02997M08
                                                                       !02997M09
                                                                       !02997M0A
                                                                       !02997M0B
                                                                       !02997K1B
        if not hiswtkn^frmt^ext^tkn^to^ext^tkn(                        !02997K1C
                        pct.options.fixed^lgth^frmt,                   !02997K1D
                        pos^l, orig^ext^fld,                           !02997K1E
                                                                       !02997M0C
                        $len( psem.pri^rsrvd4^prvt.pos.add^data ),     !02997M0D
                       tkn^mem^rec, psem.pri^rsrvd4^prvt.pos.add^data, !02997M0E
                        $len( psem.pri^rsrvd4^prvt.pos.add^data ),     !02997M0F
                                                                       !02997M0G
                                                                       !02997M0H
                                                                       !02997M0I
                                                                       !02997M0J
                        psem.pri^rsrvd4^prvt.len,                      !02997K1I
                        psem.retrvl^ref^num, psem.pan.data ) then      !02997K1J
            begin                                                      !02997K1K
                                                                       !02997M0K
            psem.pri^rsrvd4^prvt.pos.add^data ':='                     !02997M0L
              [ $len( psem.pri^rsrvd4^prvt.pos.add^data ) * [ " " ] ]; !02997M0M
                                                                       !02997M0N
                                                                       !02997M0O
                                                                       !02997M0P
                                                                       !02997M0Q
                                                                       !02997K1N
            if pct.options.fixed^lgth^frmt then                        !02997K1O
                call integer^ascii^( psem.pri^rsrvd4^prvt.len,         !02997K1P
                                                                       !02997M0R
                           $len( psem.pri^rsrvd4^prvt.pos.add^data ) ) !02997M0S
                                                                       !02997M0T
                                                                       !02997M0U
                                                                       !02997M0V
            else                                                       !02997K1R
                psem.pri^rsrvd4^prvt.len ':=' "000";                   !02997K1S
            end;                                                       !02997K1T
        end                                                            !02997K1U
    else                                                               !02997K1V
        begin                                                          !02997K1W
                                                                       !02997M0W
        psem.pri^rsrvd4^prvt.pos.add^data ':='                         !02997M0X
             [ $len( psem.pri^rsrvd4^prvt.pos.add^data ) * [ " " ] ];  !02997M0Y
                                                                       !02997M0Z
                                                                       !02997M10
                                                                       !02997M11
                                                                       !02997M12
                                                                       !02997K1Z
        if pct.options.fixed^lgth^frmt then                            !02997K20
            call integer^ascii^( psem.pri^rsrvd4^prvt.len,             !02997K21
                                                                       !02997M13
                         $len( psem.pri^rsrvd4^prvt.pos.add^data ) )   !02997M14
                                                                       !02997M15
                                                                       !02997M16
                                                                       !02997M17
        else                                                           !02997K23
            psem.pri^rsrvd4^prvt.len ':=' "000";                       !02997K24
        end;                                                           !02997K25
    end;                                                               !02997K26
                                                                       !02997K27
?section pos^init^emf                                                  !02998
?page "                                        - pos^init^emf"         !02999
!#####################################################################!!03000
!#                                                                   #!!03001
!#                      POS^INIT^EMF                                 #!!03002
!#                                                                   #!!03003
!#    NARRATIVE : THIS PROCEDURE INITIALIZES THE GLOBAL POS TABLE    #!!03004
!#       FROM THE EXTERNAL MESSAGE FILE.                             #!!03005
!#                                                                   #!!03006
!#    INPUT PARAMETERS:                                              #!!03007
!#       EMF           : EMF RECORD                                  #!!03008
!#       POS           : POS BIT MAP TABLE                           #!!03009
                                                                       !03009K00
!#       TKN^GRPS      : POINTER TO STRUCTURE OF TOKEN GROUPS        #!!03009K01
                                                                       !03009K02
!#                                                                   #!!03010
!#    OUTPUT PARAMETERS:                                             #!!03011
!#                                                                   #!!03012
!#####################################################################!!03013
                                                                       !03014K00
int proc pos^init^emf( emf, pos, tkn^grps );                           !03014K01
                                                                       !03014K02
int     .emf( emf^def );                                               !03015
int .ext pos( pos^def );                                               !03016
                                                                       !03016K00
int     .tkn^grps( tkn^grp^def );                                      !03016K01
                                                                       !03016K02
    begin                                                              !03017
    wlform( bad^emf, "INVALID POS Message Type \\\\ found in EMF")     !03018
                                                                       !03019
    define   msg^type( i ) = msg^tbl[ ( i ) * 4 ]#;                    !03020
                                                                       !03021
    string   msg^tbl = 'p' := [                                        !03022
                                                                       !03023
              "0100",  ! POS pre-auth request                         !!03024
              "0110",  ! POS pre-auth response                        !!03025
              "0120",  ! POS pre-auth completion                      !!03026
              "0130",  ! POS pre-auth completion ack                  !!03027
              "0200",  ! POS request                                  !!03028
              "0210",  ! POS response                                 !!03029
              "0220",  ! POS completion                               !!03030
              "0230",  ! POS completion ack                           !!03031
              "0402",  ! POS card issuer reversal request             !!03032
              "0412",  ! POS card issuer reversal response            !!03033
              "0420",  ! POS acquirer reversal advice                 !!03034
              "0430",  ! POS reversal advice response                 !!03035
                  0 ];                                                 !03036
                                                                       !03037
                                                                       !03037K00
    string                                                             !03037K01
                .pbit^map[ 0:15 ],                                     !03037K02
                .sbit^map[ 0:15 ];                                     !03037K03
                                                                       !03037K04
                                                                       !03037K05
    int  .ext pos^tbl( pos^tbl^def );                                  !03038
                                                                       !03039
                                                                       !03040
    int i; i := -1;                                                    !03041
    while msg^type( i:=i+1 ) and emf.prikey.msg^typ <>                 !03042
          msg^type( i ) for $len( emf.prikey.msg^typ ) do;             !03043
                                                                       !03044
    if  not msg^type( i ) then                                         !03045
        begin                                                          !03046
        call logmessage^( 1105,, @bad^emf, net.myname, 2,              !03047
            @pos^prod^g, @emf.prikey.msg^typ );                        !03048
        return false;                                                  !03049
        end;                                                           !03050
                                                                       !03051
    @pos^tbl := $xadr( pos ) + dlen( pos^tbl ) * $dbl( i );            !03052
                                                                       !03053
    if  emf.prikey.in^out^ind <> "O" then                              !03054
        begin                                                          !03055
        call util^emf^bit^map( emf.fld^map, 0,                         !03056
            pos^tbl.preq^map, pos^tbl.sreq^map );                      !03057
                                                                       !03057K00
                                                                       !03057K01
        mov^( pos^tbl.full^mac^in, emf.full^msg^mac );                 !03057K02
                                                                       !03057K03
        call util^emf^bit^map( emf.mac^fld^map, 2,                     !03057K04
                               pos^tbl.pmac^map^in,                    !03057K05
                               pos^tbl.smac^map^in );                  !03057K06
                                                                       !03057K07
        call util^emf^bit^map( emf.fld^map, 3,                         !03057K08
                               pbit^map, sbit^map,                     !03057K09
                               pos^tbl.mac^in^req );                   !03057K0A
                                                                       !03057K0B
        end;                                                           !03058
                                                                       !03059
    if  emf.prikey.in^out^ind <> "I" then                              !03060
        begin                                                          !03061
        call util^emf^bit^map( emf.fld^map, 1,                         !03062
            pos^tbl.popt^map, pos^tbl.sopt^map );                      !03063
                                                                       !03064
                                                                       !03065K00
        call util^emf^bit^map( emf.fld^map, 3,                         !03065K01
                                                                       !03065K02
            pos^tbl.pbit^map, pos^tbl.sbit^map );                      !03066
                                                                       !03067
        call util^emf^ims^cde( emf, $occurs( pos^tbl.tran^tbl ),       !03068
            pos^tbl.tran^ctr, pos^tbl.tran^tbl );                      !03069
                                                                       !03069K00
                                                                       !03069K01
        mov^( pos^tbl.full^mac^out, emf.full^msg^mac );                !03069K02
                                                                       !03069K03
        call util^emf^bit^map( emf.mac^fld^map, 2,                     !03069K04
                               pos^tbl.pmac^map^out,                   !03069K05
                               pos^tbl.smac^map^out );                 !03069K06
        end;                                                           !03069K07
                                                                       !03069K08
    call hiswtkn^init^grp^tbl( emf, pct.fiid,                          !03069K09
                               pos^tbl.tkn^grp, tkn^grps );            !03069K0A
                                                                       !03069K0B
                                                                       !03069K0C
                                                                       !03070K00
                                                                       !03070K01
                                                                       !03070K02
    return true;                                                       !03072
    end;                                                               !03073
?section pos^init^get^lconf^info                                       !03074
?page "                                 - pos^init^get^lconf^info"     !03074K00
!#####################################################################!!03077
!#                                                                   #!!03078
!#                    POS^INIT^GET^LCONF^INFO                        #!!03079
!#                                                                   #!!03080
!#    NARRATIVE : THIS PROCEDURE RETRIEVES FILE ASSIGNMENTS AND      #!!03081
!#       PARAMS FROM THE LCONF.                                      #!!03082
!#                                                                   #!!03083
!#    INPUT PARAMETERS:                                              #!!03084
!#       LCONF^NUM    : LCONF FILE NUMBER                            #!!03085
!#                                                                   #!!03086
!#    OUTPUT PARAMETERS:                                             #!!03087
!#                                                                   #!!03088
!#####################################################################!!03089
int proc pos^init^get^lconf^info( lconf^num );                         !03090
int     lconf^num;                                                     !03091
    begin                                                              !03092
    wlform( bad^assign, "\? file name not found in the LCONF" )        !03093
    wlform( bad^pos,                                                   !03094
    "Invalid POS-LN-CUTOVER param found in the LCONF" )                !03095
                                                                       !03096K00
                                                                       !03096K01
                                                                       !03096K02
                                                                       !03098K00
                                                                       !03098L00
    wlform( bad^param,  "\? param not found in the LCONF" )            !03098L01
                                                                       !03098)00
    wlform( bad^param^dflt, "Invalid \? param - defaulting to 'N'" )   !03098)01
                                                                       !03098)02
                                                                       !03098L02
                                                                       !03098L03
                                                                       !03098L04
                                                                       !03098K02
    !                                                                 !!03099
                                                                       !03099K00
    ! This table contains the assigns used by POS!                     !03099K01
                                                                       !03099K02
                                                                       !03100K00
                                                                       !03100K01
    !                                                                 !!03101
    string  item^tbl = 'P' := [                                        !03102
    !                                                                 !!03103
    ! <item^type>     <item^name>                   <len> <req>       !!03104
    !              ....+....1....+....2....+....3..                   !!03105
                                                                       !03106)00
    !0!   "P",    "POS-LN-CUTOVER                  ", 14,   1,         !03106)01
    !1!   "P",    "POS-DISCR-DATA-PSTM-SUPPRS      ", 26,   0,         !03106)02
                                                                       !B0310600
    !2!   "P",    "POS-B24-TO-POS-ACCT-TYP-SUPPRS  ", 30,   0,         !B0310601
                                                                       !B0310602
                                                                       !B0310603
                                                                       !B0310604
                                                                       !03107K00
                                                                       !03107K01
                                                                       !03108
             0  ];                                                     !03109
                                                                       !03110
    literal item^type^len^l = 01,                                      !03111
            item^name^len^l = 32;                                      !03112
                                                                       !03113
    define  item^type^( i ) = item^tbl[ ( ( i ) * 35 ) + 00  ]#,       !03114
            item^name^( i ) = item^tbl[ ( ( i ) * 35 ) + 01  ]#,       !03115
            item^len^ ( i ) = item^tbl[ ( ( i ) * 35 ) + 33  ]#,       !03116
                                                                       !03117)00
                                                                       !E0311700
            item^req^ ( i ) = item^tbl[ ( ( i ) * 35 ) + 34  ]#;       !E0311701
                                                                       !E0311702
                                                                       !03117)02
                                                                       !03118
    struct  .lconf^key( lconf^key^def ),                               !03119
            .lconf( lconf^def );                                       !03120
                                                                       !03121
    int      error := false,                                           !03122
             ferror,                                                   !03123
             hour,                                                     !03124
                                                                       !03124:00
             i := -1,                                                  !03124:01
                                                                       !03124:02
             minute,                                                   !03125
             stat;                                                     !03126
                                                                       !03127
    string  .ptr;                                                      !03128
                                                                       !03129
                                                                       !03129)00
    !                                                                 !!03129)01
    ! Initialize the variable to its default.                         !!03129)02
    !                                                                 !!03129)03
    bici_g.supprs_pstm_discr_data := false;                            !03129)04
                                                                       !03129)05
                                                                       !B0312900
    bici_g.supprs^b24^to^pos^acct^typ := false;                        !B0312901
                                                                       !B0312902
                                                                       !03130
    lconf^key.user^fld1 ':=' " ";                                      !03131
    lconf^key.pro^name  ':=' net.myname for                            !03132
         $len( lconf^key.pro^name );                                   !03133
    !                                                                 !!03134
    ! Search for the assign in our table                              !!03135
    !                                                                 !!03136
                                                                       !03137:00
    i := -1;                                                           !03137:01
                                                                       !03137:02
    while item^type^( i := i + 1 ) do                                  !03138
        begin                                                          !03139
        lconf^key.item^typ  ':=' item^type^( i ) for item^type^len^l;  !03140
        lconf^key.item^name ':=' item^name^( i ) for item^name^len^l;  !03141
        !                                                             !!03142
        ! perform the call to lconf^read                              !!03143
        !                                                             !!03144
        if  ferror := lconf^read( lconf^num, lconf, lconf^key ) then   !03145
            begin                                                      !03146
            if  ferror <> feeof and ferror <> fenotfound then          !03147
                return( error := ferror );                             !03148
                                                                       !03149
            if  lconf^key.item^typ = "A" then                          !03150
                call logmessage^( 1110, , @bad^assign, net.myname,     !03151
                    3, , @lconf^key.item^name, item^len^( i ) )        !03152
            else                                                       !03153
            if  lconf^key.item^typ = "P" then                          !03154
                call logmessage^( 1115, , @bad^param, net.myname,      !03155
                    3, , @lconf^key.item^name, item^len^( i ) );       !03156
                                                                       !03157
            if  item^req^( i ) then                                    !03158
                error := ferror;                                       !03159
            end                                                        !03160
        else                                                           !03161
            begin                                                      !03162
            !                                                         !!03163
            ! Found a match                                           !!03164
            !                                                         !!03165
            case i of                                                  !03166
                begin                                                  !03167
            !0! begin   ! POS-LN-CUTOVER                              !!03168
                @ptr := numin( lconf.param^msg.ptxt, hour, 10, stat ); !03169
                if  stat or hour < 0 or hour > 24 or ptr <> ":" then   !03170
                    call logmessage^( 1120, , @bad^pos,                !03171
                       net.myname, 1, @pos^prod^g );                   !03172
                                                                       !03173
                @ptr := numin( ptr[1], minute, 10, stat );             !03174
                if  stat or minute < 0 or minute > 59 then             !03175
                    call logmessage^( 1125, , @bad^pos,                !03176
                        net.myname, 1, @pos^prod^g );                  !03177
                                                                       !03178
                pos^cutover^tim^g := ( hour * 100 ) + minute;          !03179
                end;                                                   !03180
                                                                       !03181
                                                                       !03181)00
            !1! begin   ! POS-DISCR-DATA-PSTM-SUPPRS !                 !03181)01
                if lconf.param^msg.ptxt = "y" or                       !03181)02
                   lconf.param^msg.ptxt = "Y" then                     !03181)03
                    begin                                              !03181)04
                    bici_g.supprs_pstm_discr_data := true;             !03181)05
                    end                                                !03181)06
                else                                                   !03181)07
                if lconf.param^msg.ptxt = "n" or                       !03181)08
                   lconf.param^msg.ptxt = "N" then                     !03181)09
                    begin                                              !03181)0A
                    bici_g.supprs_pstm_discr_data := false;            !03181)0B
                    end                                                !03181)0C
                else                                                   !03181)0D
                    begin                                              !03181)0E
                    bici_g.supprs_pstm_discr_data := false;            !03181)0F
                    call logmessage^( 1126, ! routing^code !,          !03181)0G
                                      @bad^param^dflt, net.myname, 1,  !03181)0H
                                      @pos^prod^g,                     !03181)0I
                                      @lconf.prikey.item^name,         !03181)0J
                                      item^len^( i ) );                !03181)0K
                    end;                                               !03181)0L
                end;                                                   !03181)0M
                                                                       !03181)0N
                                                                       !B0318100
            !2! begin   ! POS-B24-TO-POS-ACCT-TYP-SUPPRS !             !B0318101
                bici_g.supprs^b24^to^pos^acct^typ := false;            !B0318102
                if lconf.param^msg.ptxt = "y" or                       !B0318103
                   lconf.param^msg.ptxt = "Y" then                     !B0318104
                    begin                                              !B0318105
                    bici_g.supprs^b24^to^pos^acct^typ := true;         !B0318106
                    end                                                !B0318107
                end;                                                   !B0318108
                                                                       !B0318109
                                                                       !03182K00
                                                                       !03182K01
                                                                       !03182K02
            !?! otherwise                                              !03196
                    call programmatic^dump( 1100 );                    !03197
                end;                                                   !03198
            end;                                                       !03199
        end;                                                           !03200
    !                                                                 !!03201
    ! If a required assign or param not found, abend                  !!03202
    !                                                                 !!03203
                                                                       !03204
                                                                       !03204K00
    if  ( pos^cutover^tim^g = -1 ) then                                !03204K01
                                                                       !03204K02
                                                                       !03205K00
                                                                       !03205K01
        error := true;                                                 !03206
                                                                       !03207
    return ( not error );                                              !03208
                                                                       !03209
    end;                                                               !03210
?section pos^init^memory                                               !03211
?page "                                        - pos^init^memory"      !03212
!#####################################################################!!03213
!#                                                                   #!!03214
!#                      POS^INIT^MEM                                 #!!03215
!#                                                                   #!!03216
!#    NARRATIVE : THIS PROCEDURE INITIALIZES EXTENDED MEMORY BASED   #!!03217
!#       UPON REQUIREMENTS FOR BASE24-pos.                           #!!03218
!#                                                                   #!!03219
!#    INPUT PARAMETERS:                                              #!!03220
!#                                                                   #!!03221
!#    OUTPUT PARAMETERS:                                             #!!03222
                                                                       !03222K00
!#           SEG^SIZE   : SIZE OF THE EXTENDED SEGMENT NEEDED AFTER  #!!03222K01
!#                        POS INFORMATION IS INCLUDED                #!!03222K02
                                                                       !03222K03
!#                                                                   #!!03223
!#####################################################################!!03224
int proc pos^init^memory( seg^size );                                  !03225
int(32)  .seg^size;                                                    !03226
    begin                                                              !03227
                                                                       !03228
                                                                       !03228K00
    !!                                                                 !03228K01
    !if the TKN is present then determine how many POS ISO records!    !03228K02
    !exist so extended memory can be allocated for all of them!        !03228K03
    !!                                                                 !03228K04
    if tkn^num^g > 0 and                                               !03228K05
       not hiswtkn^calc^seg^size( tkn^num^g,                           !03228K06
                                  pos^tkn^tbl^size^g,                  !03228K07
                                  pos^l ) then                         !03228K08
        return false;                                                  !03228K09
                                                                       !03228K0A
    !!                                                                 !03228K0B
    !add the calculated size of the POS ISO TKN records, enough space! !03228K0C
    !for the POS TKN LOG record and the size of the POS TABLE DEF!     !03228K0D
    !!                                                                 !03228K0E
    seg^size := seg^size + pos^tkn^tbl^size^g +                        !03228K0F
                $dbl( $len( pos^def ) ) + $dbl( $len( tkn^def ) );     !03228K0G
                                                                       !03228K0H
                                                                       !03228K0I
                                                                       !03229K00
                                                                       !03229K01
    return true;                                                       !03230
    end;                                                               !03231
?section pos^init^pct                                                  !03232
?page "                                        - pos^init^pct"         !03233
!#################################################################### !!03234
!#                                                                  # !!03235
!#                        POS^INIT^PCT                              # !!03236
!#                                                                  # !!03237
!#  NARRATIVE: THIS PROCEDURE INITIALIZES THE POS PROCESS CONTROL   # !!03238
!#     TABLE INFORMATION.                                           # !!03239
!#                                                                  # !!03240
!#    INPUT PARAMETERS:                                             # !!03241
                                                                       !03241K00
!#       ICF     : INTERFACE CONFIGURATION FILE RECORD              #! !03241K01
!#       ICF^BUF : INTERFACE CONFIGURATION FILE RECORD              #! !03241K02
                                                                       !03241K03
!#                                                                  # !!03242
!#    OUTPUT PARAMETERS:                                            # !!03243
!#                                                                  # !!03244
!#################################################################### !!03245
int proc pos^init^pct( icf, icf^buf );                                 !03246
int .icf( icf^ptr^def );                                               !03247
int .icf^buf( icf^buf^def );                                           !03248
                                                                       !03249
    begin                                                              !03250
                                                                       !03250S00
    int            icfe_swch;                                          !03250S01
                                                                       !03250S02
    if base24^rel^g >= 6 then                                          !03250S03
        begin                                                          !03250S04
        icfe_swch := pos_init_pct_icfe( icf, icf^buf );                !03250S05
        return icfe_swch;                                              !03250S06
        end;                                                           !03250S07
                                                                       !03250S08
    if  pct.options.pos.id = pos^l then                                !03251
        begin                                                          !03252
        movl ( pos^pct.dest.name,  icf.pos.auth^pro,                   !03253
            $len( icf.pos.auth^pro ) );                                !03254
        use i; i := -1;                                                !03255
        while ( ( i := i +1 ) < $occurs( icf.pos.allowed^srvcs ) ) and !03256
             ( icf.pos.allowed^srvcs[i] <> "  " ) do                   !03257
            move ( pos^pct.allowed^srv[i], icf.pos.allowed^srvcs[i] ); !03258
                                                                       !03259
        set  ( pos^pct.num^srv,          i                        );   !03260
        drop i;                                                        !03261
        move ( pos^pct.timeout^flg,      icf.pos.timeout^flg      );   !03262
        move ( pos^pct.trans^allowed,    icf.pos.trans^allowed    );   !03263
        move ( pos^pct.phone^num,        icf.pos.rfrl^phone       );   !03264
        set  ( pos^pct.pre^auth^hld,     icf.pos.pre^auth^hld     );   !03265
        set  ( pos^pct.pre^auth^amt^dft, icf.pos.pre^auth^amt^dft );   !03266
        set  ( pos^pct.apprv^cde^lgth,   icf.pos.apprv^cde^lgth   );   !03267
        move ( pos^pct.retail^id,        icf.pos.dflt^retail^id   );   !03268
        move ( pos^pct.setl^entity,      icf.pos.setl^entity      );   !03269
                                                                       !03270
        move ( pos^pct.adj^flg,                                        !03271
            pos^pct.trans^allowed.adj^amt2^grtr^amt1 );                !03272
                                                                       !03273
        if  icf.pos.timer^lmts.outbound  >  0d  then                   !03274
            pos^pct.timers.outbound  :=  icf.pos.timer^lmts.outbound  * 100d;
                                                                       !03277
        if  icf.pos.timer^lmts.inbound   >  0d  then                   !03278
            pos^pct.timers.inbound   :=  icf.pos.timer^lmts.inbound   * 100d;
                                                                       !03281
        if  icf.pos.timer^lmts.compl     >  0d  then                   !03282
            pos^pct.timers.compl     :=  icf.pos.timer^lmts.compl     * 100d;
                                                                       !03285
        if  icf.pos.timer^lmts.compl^ack >  0d  then                   !03286
            pos^pct.timers.compl^ack :=  icf.pos.timer^lmts.compl^ack * 100d;
                                                                       !03289
        if  icf.pos.timer^lmts.isaf       >  0d  then                  !03290
            pos^pct.timers.saf       :=  icf.pos.timer^lmts.isaf       * 100d;
        end;                                                           !03293
                                                                       !03294
                                                                       !03295M00
                                                                       !03295M01
                                                                       !03295M02
    return true;                                                       !03338
    end;                                                               !03339
                                                                       !03339S00
?section pos_init_pct_icfe                                             !03339S01
?page "pos_init_pct_icfe"                                              !03339S02
!#################################################################### !!03339S03
!#                                                                  # !!03339S04
!#                      pos_init_pct_icfe                           # !!03339S05
!#                                                                  # !!03339S06
!#  NARRATIVE: this procedure initializes the POS process control   # !!03339S07
!#             table information.                                   # !!03339S08
!#                                                                  # !!03339S09
!#  INPUT PARAMETERS:                                               # !!03339S0A
!#      icfe          : Pointers to the icfe segments               # !!03339S0B
!#      icfe^buf      : Buffer containing the icfe segments         # !!03339S0C
!#                                                                  # !!03339S0D
!#  OUTPUT PARAMETERS:                                              # !!03339S0E
!#                                                                  # !!03339S0F
!#################################################################### !!03339S0G
int proc pos_init_pct_icfe( icfe, icfe^buf );                          !03339S0H
int            .icfe( icfe_ptr_def );                                  !03339S0I
int            .icfe^buf( icf^buf^def );                               !03339S0J
                                                                       !03339S0K
    begin                                                              !03339S0L
                                                                       !03339S0M
    int            i := -1;                                            !03339S0N
                                                                       !03339S0O
    if pct.options.pos.id = pos^l then                                 !03339S0P
        begin                                                          !03339S0Q
        movl ( pos^pct.dest.name, icfe.pos.auth_pro,                   !03339S0R
               $len( icfe.pos.auth_pro ) );                            !03339S0S
        while ( ( i := i +1 ) < $occurs(                               !03339S0T
                                icfe.pos.allowed_srvcs ) ) and         !03339S0U
              ( icfe.pos.allowed_srvcs[i] <> "  " ) do                 !03339S0V
            begin                                                      !03339S0W
            move ( pos^pct.allowed^srv[i], icfe.pos.allowed_srvcs[i]); !03339S0X
            end;                                                       !03339S0Y
                                                                       !03339S0Z
        set  ( pos^pct.num^srv,          i                         );  !03339S10
        move ( pos^pct.timeout^flg,      icfe.pos.timeout_flg      );  !03339S11
        move ( pos^pct.phone^num,        icfe.pos.rfrl_phone       );  !03339S12
        set  ( pos^pct.pre^auth^hld,     icfe.pos.pre_auth_hld     );  !03339S13
        set  ( pos^pct.pre^auth^amt^dft, icfe.pos.pre_auth_amt_dft );  !03339S14
        set  ( pos^pct.apprv^cde^lgth,   icfe.pos.apprv_cde_lgth   );  !03339S15
        move ( pos^pct.retail^id,        icfe.pos.dflt_retail_id   );  !03339S16
        move ( pos^pct.setl^entity,      icfe.pos.setl_entity      );  !03339S17
        move ( pos^pct.adj^flg,          icfe.pos.adj_flg          );  !03339S18
        move ( pos^pct.chrgbck^flg,      icfe.pos.chrgbck_flg      );  !03339S19
        move ( pos^pct.acq^txn^prfl,     icfe.pos.acq_txn_prfl     );  !03339S1A
        move ( pos^pct.iss^txn^prfl,     icfe.pos.iss_txn_prfl     );  !03339S1B
                                                                       !03339S1C
        if icfe.pos.timer_lmts.outbound > 0d then                      !03339S1D
            begin                                                      !03339S1E
            pos^pct.timers.outbound :=                                 !03339S1F
                icfe.pos.timer_lmts.outbound * 100d                    !03339S1G
            end;                                                       !03339S1H
                                                                       !03339S1I
        if icfe.pos.timer_lmts.inbound > 0d then                       !03339S1J
            begin                                                      !03339S1K
            pos^pct.timers.inbound :=                                  !03339S1L
                icfe.pos.timer_lmts.inbound * 100d                     !03339S1M
            end;                                                       !03339S1N
                                                                       !03339S1O
        if icfe.pos.timer_lmts.compl > 0d then                         !03339S1P
            begin                                                      !03339S1Q
            pos^pct.timers.compl :=                                    !03339S1R
                icfe.pos.timer_lmts.compl * 100d                       !03339S1S
            end;                                                       !03339S1T
                                                                       !03339S1U
        if icfe.pos.timer_lmts.compl_ack > 0d then                     !03339S1V
            begin                                                      !03339S1W
            pos^pct.timers.compl^ack :=                                !03339S1X
                icfe.pos.timer_lmts.compl_ack * 100d                   !03339S1Y
            end;                                                       !03339S1Z
                                                                       !03339S20
        if icfe.pos.timer_lmts.isaf > 0d then                          !03339S21
            begin                                                      !03339S22
            pos^pct.timers.saf := icfe.pos.timer_lmts.isaf * 100d      !03339S23
            end;                                                       !03339S24
                                                                       !03339S25
        end;                                                           !03339S26
                                                                       !03339S27
    return true;                                                       !03339S28
    end; ! of proc pos_init_pct_icfe                                 ! !03339S29
                                                                       !03339S2A
?section pos^pcs^health                                                !03340
?page "                                        - pos^pcs^health"       !03341
!#####################################################################!!03342
!#                                                                   #!!03343
!#                      POS^PCS^HEALTH                               #!!03344
!#                                                                   #!!03345
!#    NARRATIVE : THIS PROCEDURE FORMATS THE POS PORTION OF THE PCS  #!!03346
!#       RESPONSE FROM DATA RETRIEVED FROM TEH PCT TABLE.            #!!03347
!#                                                                   #!!03348
!#    INPUT PARAMETERS:                                              #!!03349
                                                                       !03349K00
!#       PCS^RESP : PCS HEALTH RESPONSE                              #!!03349K01
!#       PPD      : HEALTH SERVER PPD                                #!!03349K02
!#       TAG      : GUARDIAN REPLY TAG FROM THE REQUEST              #!!03349K03
                                                                       !03349K04
!#                                                                   #!!03350
!#    OUTPUT PARAMETERS:                                             #!!03351
!#                                                                   #!!03352
!#####################################################################!!03353
int proc pos^pcs^health( pcs^resp, ppd, tag );                         !03354
int .pcs^resp( si^pcs^resp^def );                                      !03355
int .ppd;                                                              !03356
int  tag;                                                              !03357
                                                                       !03358
    begin                                                              !03359
    use i;                                                             !03360
    pcs^resp.pos^perf.present       :=  true;                          !03361
    pcs^resp.pos^perf.out^rqst^lmt  :=  pos^pct.timers.outbound;       !03362
    pcs^resp.pos^perf.in^rqst^lmt   :=  pos^pct.timers.inbound;        !03363
                                                                       !03364
    for i := 0 to $occurs( pos^pct.perform ) -1 do                     !03365
        begin                                                          !03366
        pcs^resp.pos^perf.perf[i].out^rqst.cnt :=                      !03367
                       pos^pct.perform[i].outbound.count;              !03368
        pcs^resp.pos^perf.perf[i].out^rqst.timeouts :=                 !03369
                       pos^pct.perform[i].outbound.timeouts;           !03370
        pcs^resp.pos^perf.perf[i].out^rqst.ttl^time :=                 !03371
                       pos^pct.perform[i].outbound.ttl^tim;            !03372
        pcs^resp.pos^perf.perf[i].in^rqst.cnt :=                       !03373
                       pos^pct.perform[i].inbound.count;               !03374
        pcs^resp.pos^perf.perf[i].in^rqst.timeouts :=                  !03375
                       pos^pct.perform[i].inbound.timeouts;            !03376
        pcs^resp.pos^perf.perf[i].in^rqst.ttl^time :=                  !03377
                       pos^pct.perform[i].inbound.ttl^tim;             !03378
        end;                                                           !03379
    drop i;                                                            !03380
    return true;                                                       !03381
    end;                                                               !03382
                                                                       !03382300
?section pos^sem^del^tkns                                              !03382301
?page "pos^sem^del^tkns"                                               !03382302
!#####################################################################!!03382303
!#                                                                   #!!03382304
!#                         pos^sem^del^tkns                          #!!03382305
!#                                                                   #!!03382306
!#  This proc deletes the Acquirer Routing token, Transaction        #!!03382307
!#  Description token and Transaction Profile token from the         #!!03382308
!#  external message.                                                #!!03382309
!#                                                                   #!!0338230A
!#  INPUT PARAMETERS:                                                #!!0338230B
!#      sem - Pointer to the BASE24 External POS message.            #!!0338230C
!#                                                                   #!!0338230D
!#  OUTPUT PARAMETERS:                                               #!!0338230E
!#                                                                   #!!0338230F
!#  RETURN:                                                          #!!0338230G
!#      return_val -                                                 #!!0338230H
!#                                                                   #!!0338230I
!#####################################################################!!0338230J
proc pos^sem^del^tkns( sem );                                          !0338230K
int            .sem( sem^def );                                        !0338230L
                                                                       !0338230M
    begin                                                              !0338230N
                                                                       !0338230O
    wlform( del^err,                                                   !0338230P
        "Error while attempting to delete token \\ from the SEM " )    !0338230Q
                                                                       !0338230R
    struct         .acq^rte^tkn( acq_rte_tkn_def );                    !0338230S
    struct         .txn^descr^tkn( txn_descr_tkn_def );                !0338230T
    struct         .txn^prfl^tkn( txn_prfl_tkn_def );                  !0338230U
                                                                       !0338230V
    int             error;                                             !0338230W
    int            .ext^data^fld^i :=                                  !0338230X
                        wordaddr( @psem.pri^rsrvd4^prvt.data );        !0338230Y
    int             ext^lgth^i := 0;                                   !0338230Z
    int             ttl^tkn^data^lgth := 0;                            !0338230a
                                                                       !0338230b
    string          tkn^id[ 0:1 ];                                     !0338230c
                                                                       !0338230d
    !                                                                 !!0338230e
    ! Delete Acquirer Routing token from the external message         !!0338230f
    !                                                                 !!0338230g
    movd( tkn^id, acq^rte^tkn^id^d );                                  !0338230h
    shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );               !0338230i
                                                                       !0338230j
    error := tkn^del^info( ext^data^fld^i, 0,                          !0338230k
                           $len( psem.pri^rsrvd4^prvt.data ),          !0338230l
                           tkn^id,                                     !0338230m
                           ttl^tkn^data^lgth,                          !0338230n
                           true );                                     !0338230o
                                                                       !0338230p
    if error <> compl^no^err^l and                                     !0338230q
       error <> tkn^does^not^exist^l then                              !0338230r
        begin                                                          !0338230s
        call logmessage^( 1845, !routing code!, @del^err,              !0338230t
                          net.myname, evt_msg_severity_err_l,          !0338230u
                          @pos^prod^g, @tkn^id );                      !0338230v
        end;                                                           !0338230w
                                                                       !0338230x
    if error = compl^no^err^l then                                     !0338230y
        begin                                                          !0338230z
        !                                                             !!03382310
        ! token successfully deleted; update token data length        !!03382311
        !                                                             !!03382312
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !03382313
        call integer^ascii^( psem.pri^rsrvd4^prvt.len,                 !03382314
                             ttl^tkn^data^lgth );                      !03382315
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !03382316
        end;                                                           !03382317
                                                                       !03382318
    !                                                                 !!03382319
    ! Delete Transaction Description token from external message      !!0338231A
    !                                                                 !!0338231B
    movd( tkn^id, txn^descr^tkn^id^d );                                !0338231C
                                                                       !0338231D
    error := tkn^del^info( ext^data^fld^i, 0,                          !0338231E
                           $len( psem.pri^rsrvd4^prvt.data ),          !0338231F
                           tkn^id,                                     !0338231G
                           ttl^tkn^data^lgth,                          !0338231H
                           true );                                     !0338231I
                                                                       !0338231J
    if error <> compl^no^err^l and                                     !0338231K
       error <> tkn^does^not^exist^l then                              !0338231L
        begin                                                          !0338231M
        call logmessage^( 1847, !routing code!, @del^err,              !0338231N
                          net.myname, evt_msg_severity_err_l,          !0338231O
                          @pos^prod^g, @tkn^id );                      !0338231P
        end;                                                           !0338231Q
                                                                       !0338231R
    if error = compl^no^err^l then                                     !0338231S
        begin                                                          !0338231T
        !                                                             !!0338231U
        ! token successfully deleted; update token data length        !!0338231V
        !                                                             !!0338231W
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !0338231X
        call integer^ascii^( psem.pri^rsrvd4^prvt.len,                 !0338231Y
                             ttl^tkn^data^lgth );                      !0338231Z
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !0338231a
        end;                                                           !0338231b
                                                                       !0338231c
    !                                                                 !!0338231d
    ! Delete Transaction Profile token from external message          !!0338231e
    !                                                                 !!0338231f
    movd( tkn^id, txn^prfl^tkn^id^d );                                 !0338231g
                                                                       !0338231h
    error := tkn^del^info( ext^data^fld^i, 0,                          !0338231i
                           $len( psem.pri^rsrvd4^prvt.data ),          !0338231j
                           tkn^id,                                     !0338231k
                           ttl^tkn^data^lgth,                          !0338231l
                           true );                                     !0338231m
                                                                       !0338231n
    if error <> compl^no^err^l and                                     !0338231o
       error <> tkn^does^not^exist^l then                              !0338231p
        begin                                                          !0338231q
        call logmessage^( 1849, !routing code!, @del^err,              !0338231r
                          net.myname, evt_msg_severity_err_l,          !0338231s
                          @pos^prod^g, @tkn^id );                      !0338231t
        end;                                                           !0338231u
                                                                       !0338231v
    if error = compl^no^err^l then                                     !0338231w
        begin                                                          !0338231x
        !                                                             !!0338231y
        ! token successfully deleted; update token data length        !!0338231z
        !                                                             !!03382320
        reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !03382321
        call integer^ascii^( psem.pri^rsrvd4^prvt.len,                 !03382322
                             ttl^tkn^data^lgth );                      !03382323
        shift^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );           !03382324
        end;                                                           !03382325
                                                                       !03382326
    reset^ext^fld^d( psem.pri^rsrvd4^prvt, ext^lgth^i );               !03382327
                                                                       !03382328
    end; ! of pos^sem^del^tkns                                        !!03382329
                                                                       !0338232A
?section pos^tim^out^00^inbound^rqst                                   !03383
?page "                             - pos^tim^out^00^inbound^rqst"     !03383K00
!#####################################################################!!03386
!#                                                                   #!!03387
!#                     POS^TIM^OUT^00^INBOUND^RQST                   #!!03388
!#                                                                   #!!03389
!#    NARRATIVE : THIS PROCEDURE PROCESSES A TIMED OUT INBOUND       #!!03390
!#       TRANSACTION REQUEST.                                        #!!03391
!#                                                                   #!!03392
!#    INPUT PARAMETERS:                                              #!!03393
                                                                       !03394K00
                                                                       !03394K01
!#       USERBUF      : EXPIRED TIMER'S USERBUF EXTENSION            #!!03395
                                                                       !03395K00
!#       SUSP         : POINTER TO THE SUSPENDED TRANSACTION         #!!03395K01
                                                                       !03395K02
!#                                                                   #!!03396
!#    OUTPUT PARAMETERS:                                             #!!03397
!#                                                                   #!!03398
!#####################################################################!!03399
proc pos^tim^out^00^inbound^rqst( userbuf, susp );                     !03400
int    .userbuf( timer^userbuf^def );                                  !03401
int    .susp( susp^bici^def );                                         !03402
    begin                                                              !03403
    struct .sem( sem^def );                                            !03404
                                                                       !03404K00
                                                                       !03404K01
    int                                                                !03404K02
                 int^tran^cde[ 0:2 ];                                  !03404K03
                                                                       !03404K04
    string                                                             !03404K05
                .tran^cde := byteaddr( @int^tran^cde );                !03404K06
                                                                       !03404K07
                                                                       !03405
    if  pos^util^sem^expand( sem, susp.msg, susp.msg^lgth ) then       !03406
        begin                                                          !03407
                                                                       !03407K00
        int^tran^cde   ':=' userbuf.tran.tran^cde for 3;               !03407K01
        pos^tran^cde^g ':=' tran^cde for pos^tran^cde^lgth^l;          !03407K02
                                                                       !03407K03
                                                                       !03408K00
                                                                       !03408K01
                                                                       !03408I00
        call pos^0200^deny( susp.prikey.tran^tim, sem, susp.orig^net^pro,
                                                                       !03408I03
                                                                       !03409I00
                                                                       !03409I01
            pos^resp^cant^process^l, sub^timeout^l );                  !03410
        end;                                                           !03411
                                                                       !03412
    call pos^util^perform^updt( time^inbound^rqst^l, updt^on^to^l );   !03413
    end;                                                               !03414
?section pos^tim^out^01^outbound^rqst                                  !03415
?page "                            - pos^tim^out^01^outbound^rqst"     !03415K00
!#####################################################################!!03418
!#                                                                   #!!03419
!#                    POS^TIM^OUT^01^OUTBOUND^RQST                   #!!03420
!#                                                                   #!!03421
!#    NARRATIVE : THIS PROCEDURE PROCESSES A TIMED OUT OUTBOUND      #!!03422
!#       TRANSACTION.                                                #!!03423
!#                                                                   #!!03424
!#    INPUT PARAMETERS :                                             #!!03425
                                                                       !03426K00
                                                                       !03426K01
!#       USERBUF       : EXPIRED TIMER'S USERBUF EXTENSION           #!!03427
                                                                       !03427K00
!#       SUSP         : POINTER TO THE SUSPENDED TRANSACTION         #!!03427K01
                                                                       !03427K02
!#                                                                   #!!03428
!#    OUTPUT PARAMETERS:                                             #!!03429
!#                                                                   #!!03430
!#####################################################################!!03431
proc pos^tim^out^01^outbound^rqst( userbuf, susp );                    !03432
int    .userbuf( timer^userbuf^def );                                  !03433
int    .susp( susp^bici^def );                                         !03434
    begin                                                              !03435
                                                                       !03435I00
                                                                       !03435I01
    struct  .sem( sem^def );                                           !03435I02
                                                                       !03435M00
    int     .pstm( pstm^def ) := @susp.msg;                            !03435M01
                                                                       !03435M02
                                                                       !03435I03
    if ( pct.options.proto^typ = "03" ) then                           !03435I04
        begin                                                          !03435I05
        call pstm^frmt^b24^to^pos^sem( susp.msg, sem );                !03435I06
        call pstm^frmt^b24^to^pos^0200( susp.msg, sem );               !03435I07
        sem.isopsem.resp^cde ':=' "00";                                !03435I08
                                                                       !03435V00
        mov^( sem.isopsem.setl^dat, pct.setl.bic^dat.mm );             !03435V01
                                                                       !03435V02
        call pos^0210^deny( sem,                                       !03435I09
                            susp.orig^net^pro,                         !03435I0A
                                                                       !03435L00
                            pos^rvsl^timeout^l, susp.msg );            !03435L01
                                                                       !03435L02
                                                                       !03435L03
                                                                       !03435L04
        end;                                                           !03435I0C
                                                                       !03435I0D
                                                                       !03435I0E
                                                                       !03435M03
    if  pct.options.proto^typ <> "03" then                             !03435M04
        begin                                                          !03435M05
        movd( psem.typ,       tran^request^d   );                      !03435M06
        mov^( psem.resp^cde,  zeroes           );                      !03435M07
        mov^( psem.tran^dat,  pstm.tran^dat.mm );                      !03435M08
        mov^( psem.tran^tim,  pstm.tran^tim    );                      !03435M09
        mov^( psem.trace^num, zeroes           );                      !03435M0A
        end;                                                           !03435M0B
                                                                       !03435M0C
                                                                       !03435M0D
    call pstm^0200^route( susp.prikey, susp.msg, susp.orig^net^pro,    !03436
                                                                       !03436M00
                                                                       !03436O00
        pstm^resp^timeout^l, sub^timeout^l, pstm^stat^line^down^l,     !03436O01
                                                                       !03436O02
                                                                       !03436O03
                                                                       !03436O04
        sem );                                                         !03436M02
                                                                       !03436M03
                                                                       !03437M00
                                                                       !03437M01
                                                                       !03438
    call pos^util^perform^updt(                                        !03439
        time^outbound^rqst^l, updt^on^to^l );                          !03440
    end;                                                               !03441
?section pos^tim^out^02^saf                                            !03442
?page "                                        - pos^tim^out^02^saf"   !03443
!#####################################################################!!03444
!#                                                                   #!!03445
!#                      POS^TIM^OUT^02^SAF                           #!!03446
!#                                                                   #!!03447
!#    NARRATIVE : THIS PROCEDURE PROCESSES AN EXPIRED STORE AND      #!!03448
!#       FORWARD TIMER.                                              #!!03449
!#                                                                   #!!03450
!#    INPUT PARAMETERS:                                              #!!03451
                                                                       !03452K00
                                                                       !03452K01
!#       USERBUF       : EXPIRED TIMER'S USERBUF EXTENSION           #!!03453
!#       SAF           : STORE AND FORWARD MESSAGE                   #!!03454
!#                                                                   #!!03455
!#    OUTPUT PARAMETERS:                                             #!!03456
!#                                                                   #!!03457
!#####################################################################!!03458
proc pos^tim^out^02^saf( userbuf, saf );                               !03459
int    .userbuf( timer^userbuf^def );                                  !03460
int    .saf( saf^def );                                                !03461
    begin                                                              !03462
                                                                       !03463
    string .hdr( hdr^def );                                            !03464
                                                                       !03465
    if  @hdr := util^hdr^expand( saf.msg, saf.msg^lgth ) then          !03466
        begin                                                          !03467
        if  hdr.typ = tran^advice^d        then      !0220 -> 0221    !!03468
            hdr.typ ':=' tran^repeat^d;                                !03469
                                                                       !03470
        if  hdr.typ = rvsl^request^d       then      !0402 -> 0403    !!03471
            hdr.typ ':=' rvsl^request^repeat^d;                        !03472
                                                                       !03473
        if  hdr.typ = rvsl^advice^d        then      !0420 -> 0421    !!03474
            hdr.typ ':=' rvsl^repeat^d;                                !03475
                                                                       !03476
        if  hdr.typ = auth^advice^d        then      !0120 -> 0121    !!03477
            hdr.typ ':=' auth^repeat^d;                                !03478
                                                                       !03479
        end;                                                           !03480
    end;                                                               !03481
?section pos^tim^out^06^performance                                    !03482
?page "                              - pos^tim^out^06^performance"     !03482K00
!#####################################################################!!03485
!#                                                                   #!!03486
!#                      POS^TIM^OUT^06^PERFORMANCE                   #!!03487
!#                                                                   #!!03488
!#    NARRATIVE : THIS PROCEDURE PROCESSES AN EXPIRED PERFORMANCE    #!!03489
!#       TIMER FROM BASE24-pos.                                      #!!03490
!#                                                                   #!!03491
!#    INPUT PARAMETERS :                                             #!!03492
!#       USERBUF       : EXPIRED TIMER'S USERBUF                     #!!03493
!#       TIMER         : EXPIRED TIMER                               #!!03494
!#                                                                   #!!03495
!#    OUTPUT PARAMETERS:                                             #!!03496
!#                                                                   #!!03497
!#####################################################################!!03498
proc pos^tim^out^06^performance( timer, userbuf );                     !03499
int  .timer( timer^def );                                              !03500
int  .userbuf( timer^userbuf^def );                                    !03501
                                                                       !03502
    begin                                                              !03503
    use i;                                                             !03504
    for i := $occurs( pos^pct.perform ) - 1 downto 1 do                !03505
        pos^pct.perform[ i ] ':=' pos^pct.perform[ i-1 ] for           !03506
                                                                       !03507C00
            $len( pos^pct.perform );                                   !03507C01
                                                                       !03507C02
    drop i;                                                            !03508
                                                                       !03509
    pos^pct.perform[ 0 ] ':=' [ 0 ] & pos^pct.perform[ 0 ] for         !03510
                                                                       !03511C00
        $len( pos^pct.perform );                                       !03511C01
                                                                       !03511C02
                                                                       !03512
    end;                                                               !03513
?section pos^util^check^dup^rvsl                                       !03514
?page "                                 - pos^util^check^dup^rvsl"     !03514K00
!#####################################################################!!03517
!#                                                                   #!!03518
!#                     POS^UTIL^CHECK^DUP^RVSL                       #!!03519
!#                                                                   #!!03520
!#    NARRATIVE : THIS PROCEDURE DETERMINES IF THE INTERFACE HAS     #!!03521
!#       RECEIVED A DUPLICATE REVERSAL FROM THE CO-NETWORK AND       #!!03522
!#       UPDATES THE SETTLEMENT TOTALS TO RELECT THE REVERSAL IF     #!!03523
!#       THEY WERE NOT UPDATED DURING THE FIRST PASS OF THE REVERSAL.#!!03524
!#                                                                   #!!03525
!#    INPUT PARAMETERS:                                              #!!03526
!#       SEM           : BIC ISO EXTERNAL REVERSAL                   #!!03527
!#       PSTM          : BASE24 POS INTERNAL REVERSAL                #!!03528
!#                                                                   #!!03529
!#    OUTPUT PARAMETERS:                                             #!!03530
!#                                                                   #!!03531
!#####################################################################!!03532
int proc pos^util^check^dup^rvsl( sem, pstm ) variable;                !03533
int .sem( sem^def );                                                   !03534
int .pstm( pstm^def );                                                 !03535
    begin                                                              !03536
                                                                       !03536e00
    wlform( error, "Failure on ILF, File \F, Error #" )                !03536e01
                                                                       !03536e02
    wlform( lib^open^err,                                              !03536e03
            "Open Internal Error #, #, File \F, #, #, #, #."           !03536e04
            ','" Process abending" )                                   !03536e05
                                                                       !03536e06
    struct .ilf( ilf^def ),                                            !03537
           .prikey( prikey^def );                                      !03538
                                                                       !03539
                                                                       !03539e00
    fixed   last^addr^frmt2;                                           !03539e01
                                                                       !03539e02
    int(32) last^addr;                                                 !03540
                                                                       !03541
                                                                       !03541e00
    int     fnum;                                                      !03541e01
    int     ilf^lgth;                                                  !03541e02
    int     stat;                                                      !03541e03
                                                                       !03541e04
    struct .stat^detl( lib_stat_detl_def );                            !03541e05
                                                                       !03541e06
                                                                       !03542e00
                                                                       !03542e01
                                                                       !03542e02
                                                                       !03544
    if  not pct.setl.keep^ttls then                                    !03545
        return false;                                                  !03546
                                                                       !03547
    if  $param( sem ) then                                             !03548
        call pos^frmt^sem^to^prikey( sem, prikey );                    !03549
                                                                       !03550
    if  $param( pstm ) then                                            !03551
        call pstm^frmt^b24^to^prikey( pstm, prikey );                  !03552
                                                                       !03553
    if  ( fnum := util^ilf^get( prikey,                                !03554
            $len( prikey^def ), ilf, ilf^lgth ) ) then                 !03555
        begin                                                          !03556
        if  ilf.pos.typ = pstm^rvsl^advice^d then                      !03557
            begin                                                      !03558
                                                                       !03558e00
            if pct.ilf.cur.fcb.file^frmt = 2 then                      !03558e01
                begin                                                  !03558e02
                stat := lib_file_rec_addr( stat^detl,                  !03558e03
                                           fnum,                       !03558e04
                                           file_frmt_2_l,              !03558e05
                                           ! rec_addr_cur_32bit !,     !03558e06
                                           ! rec_addr_nxt_32bit !,     !03558e07
                                           last^addr^frmt2,            !03558e08
                                           ! rec_addr_nxt_64bit ! );   !03558e09
                end;                                                   !03558e0A
                                                                       !03558e0B
            if pct.ilf.cur.fcb.file^frmt <> 2 then                     !03558e0C
                begin                                                  !03558e0D
                stat := lib_file_rec_addr( stat^detl,                  !03558e0E
                                           fnum,                       !03558e0F
                                           file_frmt_1_l,              !03558e0G
                                           last^addr,                  !03558e0H
                                           ! rec_addr_nxt_32bit !,     !03558e0I
                                           ! rec_addr_cur_64bit !,     !03558e0J
                                           ! rec_addr_nxt_64bit ! );   !03558e0K
                                                                       !03558e0L
                end;                                                   !03558e0M
                                                                       !03558e0N
        case stat of                                                   !03558e0O
            begin                                                      !03558e0P
            lib_ok_l ->                                                !03558e0Q
                begin                                                  !03558e0R
                !                                                     !!03558e0S
                ! Returned address successful                         !!03558e0T
                !                                                     !!03558e0U
                end;                                                   !03558e0V
                                                                       !03558e0W
            lib_param_miss_l ->                                        !03558e0X
                begin                                                  !03558e0Y
                !                                                     !!03558e0Z
                ! Parameter missing.                                  !!03558e0a
                !                                                     !!03558e0b
                call log^message^( 1885,                               !03558e0c
                                   ! routing code !,                   !03558e0d
                                   @lib^open^err,                      !03558e0e
                                   net.myname,                         !03558e0f
                                   evt^msg^severity^crit^l,            !03558e0g
                                   stat^detl.cde1,                     !03558e0h
                                   stat^detl.cde2,                     !03558e0i
                                   @ilf^name^g,                        !03558e0j
                                   stat^detl.proc_num,                 !03558e0k
                                   stat,                               !03558e0l
                                   stat^detl.cde3,                     !03558e0m
                                   stat^detl.cde4 );                   !03558e0n
                call abend^( 3075 );                                   !03558e0o
                                                                       !03558e0p
                end; ! of case lib_param_miss_l                       !!03558e0q
                                                                       !03558e0r
            lib_stat_detl_see_l ->                                     !03558e0s
                begin                                                  !03558e0t
                if lib_nsk_file_sys_err_d( stat, stat^detl ) then      !03558e0u
                    begin                                              !03558e0v
                    !                                                 !!03558e0w
                    ! File system error.                              !!03558e0x
                    !                                                 !!03558e0y
                    call log^message^( 1890,                           !03558e0z
                                       ! routing code !,               !03558e10
                                       @error,                         !03558e11
                                       net.myname,                     !03558e12
                                       evt^msg^severity^crit^l,        !03558e13
                                       @ilf^name^g,                    !03558e14
                                       stat^detl.cde2 );               !03558e15
                    return false;                                      !03558e16
                    end ! of if NSK error                             !!03558e17
                else                                                   !03558e18
                    begin                                              !03558e19
                    !                                                 !!03558e1A
                    ! Internal error.                                 !!03558e1B
                    !                                                 !!03558e1C
                    call log^message^( 1895,                           !03558e1D
                                       ! routing code !,               !03558e1E
                                       @lib^open^err,                  !03558e1F
                                       net.myname,                     !03558e1G
                                       evt^msg^severity^crit^l,        !03558e1H
                                       stat^detl.cde1,                 !03558e1I
                                       stat^detl.cde2,                 !03558e1J
                                       @ilf^name^g,                    !03558e1K
                                       stat^detl.proc_num,             !03558e1L
                                       stat,                           !03558e1M
                                       stat^detl.cde3,                 !03558e1N
                                       stat^detl.cde4 );               !03558e1O
                    call abend^( 3080 );                               !03558e1P
                    end; ! of internal error                          !!03558e1Q
                end; ! of case lib_stat_detl_see_l                    !!03558e1R
                                                                       !03558e1S
            otherwise ->                                               !03558e1T
                begin                                                  !03558e1U
                !                                                     !!03558e1V
                ! Unrecognizable status.                              !!03558e1W
                !                                                     !!03558e1X
                call log^message^( 1900,                               !03558e1Y
                                   ! routing code !,                   !03558e1Z
                                   @lib^open^err,                      !03558e1a
                                   net.myname,                         !03558e1b
                                   evt^msg^severity^crit^l,            !03558e1c
                                   stat^detl.cde1,                     !03558e1d
                                   stat^detl.cde2,                     !03558e1e
                                   @ilf^name^g,                        !03558e1f
                                   stat^detl.proc_num,                 !03558e1g
                                   stat,                               !03558e1h
                                   stat^detl.cde3,                     !03558e1i
                                   stat^detl.cde4 );                   !03558e1j
                call abend^( 3085 );                                   !03558e1k
                end; ! of otherwise                                   !!03558e1l
            end; ! of case                                            !!03558e1m
                                                                       !03558e1n
            if fnum = pct.ilf.cur.fcb.filenum then                     !03558e1o
                begin                                                  !03558e1p
                if pct.ilf.cur.fcb.file^frmt = 2 then                  !03558e1q
                    begin                                              !03558e1r
                    if last^addr^frmt2 <>                              !03558e1s
                       pct.ilf^frmt2.cur.last^rvsl^addr then           !03558e1t
                        begin                                          !03558e1u
                        set( pct.ilf^frmt2.cur.last^rvsl^addr,         !03558e1v
                             last^addr^frmt2 );                        !03558e1w
                        end;                                           !03558e1x
                    end;                                               !03558e1y
                                                                       !03558e1z
                if pct.ilf.cur.fcb.file^frmt <> 2 then                 !03558e20
                    begin                                              !03558e21
                    if last^addr <> pct.ilf.cur.last^rvsl^addr then    !03558e22
                        begin                                          !03558e23
                        set( pct.ilf.cur.last^rvsl^addr, last^addr );  !03558e24
                        end;                                           !03558e25
                    end;                                               !03558e26
                call pos^util^updt^setl^ttls( ilf );                   !03558e27
                call util^itf^updt;                                    !03558e28
                end;                                                   !03558e29
                                                                       !03558e2A
            if fnum = pct.ilf.fltg.fcb.filenum then                    !03558e2B
                begin                                                  !03558e2C
                if pct.ilf.fltg.fcb.file^frmt = 2 then                 !03558e2D
                    begin                                              !03558e2E
                    if last^addr^frmt2 <>                              !03558e2F
                       pct.ilf^frmt2.fltg.last^rvsl^addr then          !03558e2G
                        begin                                          !03558e2H
                        set( pct.ilf^frmt2.fltg.last^rvsl^addr,        !03558e2I
                             last^addr^frmt2 );                        !03558e2J
                        end;                                           !03558e2K
                    end;                                               !03558e2L
                                                                       !03558e2M
                if pct.ilf.fltg.fcb.file^frmt <> 2 then                !03558e2N
                    begin                                              !03558e2O
                    if last^addr <> pct.ilf.fltg.last^rvsl^addr then   !03558e2P
                        begin                                          !03558e2Q
                        set( pct.ilf.fltg.last^rvsl^addr, last^addr ); !03558e2R
                        end;                                           !03558e2S
                    end;                                               !03558e2T
                call pos^util^updt^setl^ttls( ilf );                   !03558e2U
                call util^itf^updt;                                    !03558e2V
                end;                                                   !03558e2W
                                                                       !03558e2X
                                                                       !03559e00
                                                                       !03559e01
                                                                       !03559e02
            return true;                                               !03575
            end;                                                       !03576
        end;                                                           !03577
    return false;                                                      !03578
    end;                                                               !03579
                                                                       !03579j00
?section pos^util^frmt^enhanced^rc                                     !03579j01
?page "pos^util^frmt^enhanced^rc"                                      !03579j02
!#####################################################################!!03579j03
!#                                                                   #!!03579j04
!#                     pos^util^frmt^enhanced^rc                     #!!03579j05
!#                                                                   #!!03579j06
!#  This procedure overrides the Response Code if Enhanced Response  #!!03579j07
!#  Code Mapping is supported.                                       #!!03579j08
!#                                                                   #!!03579j09
!#  INPUT PARAMETERS:                                                #!!03579j0A
!#      sem     -  the external message that matches the PSTM        #!!03579j0B
!#      pstm    -  standard internal message (PSTM)                  #!!03579j0C
!#      flag    -  indicates direction to format.                    #!!03579j0D
!#                                                                   #!!03579j0E
!#  OUTPUT PARAMETERS:                                               #!!03579j0F
!#      sem     -  the external message that matches the PSTM        #!!03579j0G
!#      pstm    -  standard internal message (PSTM)                  #!!03579j0H
!#                                                                   #!!03579j0I
!#####################################################################!!03579j0J
proc pos^util^frmt^enhanced^rc( sem, pstm, flag );                     !03579j0K
int        .sem( sem^def );                                            !03579j0L
int        .pstm( pstm^def );                                          !03579j0M
int         flag;                                                      !03579j0N
    begin                                                              !03579j0O
    define          pstm^unauth^usg^resp^d = "050"#;                   !03579j0P
                                                                       !03579j0Q
    literal         resp^cde^len^l = 2;                                !03579j0R
                                                                       !03579j0S
?page "subproc pos^frmt^emv^rc^to^pstm of pos^util^frmt^enhanced^rc"   !03579j0T
    !#################################################################!!03579j0U
    !#                                                               #!!03579j0V
    !#                     pos^frmt^emv^rc^to^pstm                   #!!03579j0W
    !#                                                               #!!03579j0X
    !#  This procedure overrides the PSTM Response Code if Enhanced  #!!03579j0Y
    !#  EMV Response Code Mapping is supported.                      #!!03579j0Z
    !#                                                               #!!03579j0a
    !#################################################################!!03579j0b
    subproc pos^frmt^emv^rc^to^pstm;                                   !03579j0c
        begin                                                          !03579j0d
        define          emv^sem^code^d( i ) =                          !03579j0e
                            emv^resp^tbl[ ( i ) * 5 + 0 ] #;           !03579j0f
        define          emv^pstm^code^d( i ) =                         !03579j0g
                            emv^resp^tbl[ ( i ) * 5 + 2 ] #;           !03579j0h
                                                                       !03579j0i
        int             i;                                             !03579j0j
                                                                       !03579j0k
        string          emv^resp^tbl = 'P' := [                        !03579j0l
            !                                                         !!03579j0m
            ! BICI      PSTM                                          !!03579j0n
            ! Codes     Codes                                         !!03579j0o
            !  .         .                                            !!03579j0p
            !  .         .                                            !!03579j0q
            !  v         v                                            !!03579j0r
                                                                       !03579j0s
             "U0",     "400",  ! ARQC Failure                         !!03579j0t
             "U1",     "401",  ! HSM Parameter Error                  !!03579j0u
             "U2",     "402",  ! HSM Failure                          !!03579j0v
             "U3",     "403",  ! KEYI Record Not Found                !!03579j0w
             "U4",     "404",  ! ATC Check Failure                    !!03579j0x
             "U5",     "405",  ! CVR Decline                          !!03579j0y
             "U6",     "406",  ! TVR Decline                          !!03579j0z
             "U7",     "407",  ! Reason Online Code Decline           !!03579j10
             "U8",     "408",  ! Fallback Decline                     !!03579j11
             "V0",     "130",  ! ARQC Failure Referral                !!03579j12
             "V1",     "131",  ! CVR Referral                         !!03579j13
             "V2",     "132",  ! TVR Referral                         !!03579j14
             "V3",     "133",  ! Reason Online Code Referral          !!03579j15
             "V4",     "134",  ! Fallback Referral                    !!03579j16
             "V7",     "910",  ! ARQC Failure Capture                 !!03579j17
             "V8",     "911",  ! CVR Capture                          !!03579j18
             "V9",     "912",  ! TVR Capture                          !!03579j19
            0 ];                                                       !03579j1A
                                                                       !03579j1B
        i := -1;                                                       !03579j1C
        while emv^sem^code^d( i := i + 1 ) and                         !03579j1D
              psem.resp^cde <> emv^sem^code^d( i ) for                 !03579j1E
                  resp^cde^len^l do;                                   !03579j1F
        if emv^sem^code^d( i ) then                                    !03579j1G
            begin                                                      !03579j1H
            pstm.tran.resp^cde ':=' emv^pstm^code^d( i ) for           !03579j1I
                                    $len( pstm.tran.resp^cde );        !03579j1J
            end;                                                       !03579j1K
        end; ! end subproc pos^frmt^emv^rc^to^pstm                    !!03579j1L
                                                                       !03579j1M
?page "subproc pstm^frmt^emv^rc^to^sem of pos^util^frmt^enhanced^rc"   !03579j1N
    !#################################################################!!03579j1O
    !#                                                               #!!03579j1P
    !#                     pstm^frmt^emv^rc^to^sem                   #!!03579j1Q
    !#                                                               #!!03579j1R
    !#  This procedure overrides the SEM Response Code if Enhanced   #!!03579j1S
    !#  EMV Response Code Mapping is supported.                      #!!03579j1T
    !#                                                               #!!03579j1U
    !#################################################################!!03579j1V
    subproc pstm^frmt^emv^rc^to^sem;                                   !03579j1W
        begin                                                          !03579j1X
        define          emv^pstm^code^d( i ) =                         !03579j1Y
                            emv^resp^tbl[ ( i ) * 5 + 0 ] #;           !03579j1Z
        define          emv^sem^code^d( i ) =                          !03579j1a
                            emv^resp^tbl[ ( i ) * 5 + 3 ] #;           !03579j1b
                                                                       !03579j1c
        int             i;                                             !03579j1d
                                                                       !03579j1e
        string          emv^resp^tbl = 'P' := [                        !03579j1f
            !                                                         !!03579j1g
            ! PSTM      BIC ISO                                       !!03579j1h
            ! Codes     Codes                                         !!03579j1i
            !  .         .                                            !!03579j1j
            !  .         .                                            !!03579j1k
            !  v         v                                            !!03579j1l
             "130",     "V0",   ! ARQC Failure Referral               !!03579j1m
             "131",     "V1",   ! CVR Referral                        !!03579j1n
             "132",     "V2",   ! TVR Referral                        !!03579j1o
             "133",     "V3",   ! Reason Online Code Referral         !!03579j1p
             "134",     "V4",   ! Fallback Referral                   !!03579j1q
             "400",     "U0",   ! ARQC Failure                        !!03579j1r
             "401",     "U1",   ! HSM Parameter Error                 !!03579j1s
             "402",     "U2",   ! HSM Failure                         !!03579j1t
             "403",     "U3",   ! KEYI Record Not Found               !!03579j1u
             "404",     "U4",   ! ATC Check Failure                   !!03579j1v
             "405",     "U5",   ! CVR Decline                         !!03579j1w
             "406",     "U6",   ! TVR Decline                         !!03579j1x
             "407",     "U7",   ! Reason Online Code Decline          !!03579j1y
             "408",     "U8",   ! Fallback Decline                    !!03579j1z
             "910",     "V7",   ! ARQC Failure Capture                !!03579j20
             "911",     "V8",   ! CVR Capture                         !!03579j21
             "912",     "V9",   ! TVR Capture                         !!03579j22
            0 ]; ! end of emv^resp^tbl                                !!03579j23
                                                                       !03579j24
        i := -1;                                                       !03579j25
        while emv^pstm^code^d( i := i + 1 ) and                        !03579j26
              pstm.tran.resp^cde <> emv^pstm^code^d( i ) for           !03579j27
                  $len( pstm.tran.resp^cde ) do;                       !03579j28
                                                                       !03579j29
        if emv^pstm^code^d( i ) then                                   !03579j2A
            begin                                                      !03579j2B
            psem.resp^cde ':=' emv^sem^code^d( i ) for                 !03579j2C
                               resp^cde^len^l;                         !03579j2D
            end;                                                       !03579j2E
        end; ! end subproc pstm^frmt^emv^rc^to^sem                    !!03579j2F
                                                                       !03579j2G
?page "pos^util^frmt^enhanced^rc"                                      !03579j2H
    !#################################################################!!03579j2I
    !#                                                               #!!03579j2J
    !#  This is the main body of PROC pos^util^frmt^enhanced^rc      #!!03579j2K
    !#                                                               #!!03579j2L
    !#################################################################!!03579j2M
                                                                       !03579j2N
    if not enhanced^emv^rc^map^pos^d then                              !03579j2O
        begin                                                          !03579j2P
        return;                                                        !03579j2Q
        end;                                                           !03579j2R
                                                                       !03579j2S
    if flag = int^to^ext^l then                                        !03579j2T
        begin                                                          !03579j2U
        call pstm^frmt^emv^rc^to^sem;                                  !03579j2V
        end;                                                           !03579j2W
                                                                       !03579j2X
    if flag = ext^to^int^l then                                        !03579j2Y
        begin                                                          !03579j2Z
        call pos^frmt^emv^rc^to^pstm;                                  !03579j2a
        end;                                                           !03579j2b
    end;                                                               !03579j2c
                                                                       !03579j2d
?section pos^util^hdr^verify                                           !03580
?page "                                        - pos^util^hdr^verify"  !03581
                                                                       !03582
!#####################################################################!!03583
!#                                                                   #!!03584
!#                     POS^UTIL^HDR^VERIFY                           #!!03585
!#                                                                   #!!03586
!#    NARRATIVE : THIS PROCEDURE VERIFIES THE BIT MAPS IN AN         #!!03587
!#       EXTERNAL POS MESSAGE FROM THE CO-NETWORK.                   #!!03588
!#                                                                   #!!03589
!#    INPUT PARAMETERS:                                              #!!03590
!#       HDR           : MESSAGE TEXT POINTER                        #!!03591
!#                                                                   #!!03592
!#    OUTPUT PARAMETERS:                                             #!!03593
                                                                       !03593K00
!#       FULL^MSG^MAC : FLAG THAT INDICATES IF FULL MESSAGE MAC'ING  #!!03593K01
!#       PMAC^MAP     : PRIMARY MAC BIT MAP                          #!!03593K02
!#       SMAC^MAP     : SECONDARY MAC BIT MAP                        #!!03593K03
                                                                       !03593K04
!#                                                                   #!!03594
!#####################################################################!!03595
                                                                       !03595K00
int proc pos^util^hdr^verify( hdr, full^msg^mac, pmac^map,             !03595K01
                              smac^map, mac^in^req );                  !03595K02
string .hdr( hdr^def );                                                !03595K03
string .full^msg^mac;                                                  !03595K04
string .pmac^map;                                                      !03595K05
string .smac^map;                                                      !03595K06
int    .mac^in^req;                                                    !03595K07
                                                                       !03595K08
                                                                       !03595K09
                                                                       !03596K00
                                                                       !03596K01
                                                                       !03596K02
    begin                                                              !03598
                                                                       !03599
    if  hdr.typ = auth^request^d then                                  !03600
                                                                       !03600K00
        begin                                                          !03600K01
        mov^( full^msg^mac, pos.p0100.full^mac^in     );               !03600K02
        movl( pmac^map,     pos.p0100.pmac^map^in, 16 );               !03600K03
        movl( smac^map,     pos.p0100.smac^map^in, 16 );               !03600K04
        set ( mac^in^req,   pos.p0100.mac^in^req      );               !03600K05
                                                                       !03600K06
        return util^hdr^verify( hdr,                                   !03601
            pos.p0100.preq^map, pos.p0100.sreq^map );                  !03602
                                                                       !03602K00
        end;                                                           !03602K01
                                                                       !03602K02
                                                                       !03603
    if  hdr.typ = auth^response^d then                                 !03604
                                                                       !03604K00
        begin                                                          !03604K01
        mov^( full^msg^mac, pos.p0110.full^mac^in     );               !03604K02
        movl( pmac^map,     pos.p0110.pmac^map^in, 16 );               !03604K03
        movl( smac^map,     pos.p0110.smac^map^in, 16 );               !03604K04
        set ( mac^in^req,   pos.p0110.mac^in^req      );               !03604K05
                                                                       !03604K06
        return util^hdr^verify( hdr,                                   !03605
            pos.p0110.preq^map, pos.p0110.sreq^map );                  !03606
                                                                       !03606K00
        end;                                                           !03606K01
                                                                       !03606K02
                                                                       !03607
    if  hdr.typ = auth^advice^d or hdr.typ = auth^repeat^d then        !03608
                                                                       !03608K00
        begin                                                          !03608K01
        mov^( full^msg^mac, pos.p0120.full^mac^in     );               !03608K02
        movl( pmac^map,     pos.p0120.pmac^map^in, 16 );               !03608K03
        movl( smac^map,     pos.p0120.smac^map^in, 16 );               !03608K04
        set ( mac^in^req,   pos.p0120.mac^in^req      );               !03608K05
                                                                       !03608K06
        return util^hdr^verify( hdr,                                   !03609
            pos.p0120.preq^map, pos.p0120.sreq^map );                  !03610
                                                                       !03610K00
        end;                                                           !03610K01
                                                                       !03610K02
                                                                       !03611
    if  hdr.typ = auth^acknowledge^d then                              !03612
                                                                       !03612K00
        begin                                                          !03612K01
        mov^( full^msg^mac, pos.p0130.full^mac^in     );               !03612K02
        movl( pmac^map,     pos.p0130.pmac^map^in, 16 );               !03612K03
        movl( smac^map,     pos.p0130.smac^map^in, 16 );               !03612K04
        set ( mac^in^req,   pos.p0130.mac^in^req      );               !03612K05
                                                                       !03612K06
        return util^hdr^verify( hdr,                                   !03613
            pos.p0130.preq^map, pos.p0130.sreq^map );                  !03614
                                                                       !03614K00
        end;                                                           !03614K01
                                                                       !03614K02
                                                                       !03615
    if  hdr.typ = tran^request^d then                                  !03616
                                                                       !03616K00
        begin                                                          !03616K01
        mov^( full^msg^mac, pos.p0200.full^mac^in     );               !03616K02
        movl( pmac^map,     pos.p0200.pmac^map^in, 16 );               !03616K03
        movl( smac^map,     pos.p0200.smac^map^in, 16 );               !03616K04
        set ( mac^in^req,   pos.p0200.mac^in^req      );               !03616K05
                                                                       !03616K06
        return util^hdr^verify( hdr,                                   !03617
            pos.p0200.preq^map, pos.p0200.sreq^map );                  !03618
                                                                       !03618K00
        end;                                                           !03618K01
                                                                       !03618K02
                                                                       !03619
    if  hdr.typ = tran^response^d then                                 !03620
                                                                       !03620K00
        begin                                                          !03620K01
        mov^( full^msg^mac, pos.p0210.full^mac^in     );               !03620K02
        movl( pmac^map,     pos.p0210.pmac^map^in, 16 );               !03620K03
        movl( smac^map,     pos.p0210.smac^map^in, 16 );               !03620K04
        set ( mac^in^req,   pos.p0210.mac^in^req      );               !03620K05
                                                                       !03620K06
        return util^hdr^verify( hdr,                                   !03621
            pos.p0210.preq^map, pos.p0210.sreq^map );                  !03622
                                                                       !03622K00
        end;                                                           !03622K01
                                                                       !03622K02
                                                                       !03623
    if  hdr.typ = tran^advice^d or hdr.typ = tran^repeat^d then        !03624
                                                                       !03624K00
        begin                                                          !03624K01
        mov^( full^msg^mac, pos.p0220.full^mac^in     );               !03624K02
        movl( pmac^map,     pos.p0220.pmac^map^in, 16 );               !03624K03
        movl( smac^map,     pos.p0220.smac^map^in, 16 );               !03624K04
        set ( mac^in^req,   pos.p0220.mac^in^req      );               !03624K05
                                                                       !03624K06
        return util^hdr^verify( hdr,                                   !03625
            pos.p0220.preq^map, pos.p0220.sreq^map );                  !03626
                                                                       !03626K00
        end;                                                           !03626K01
                                                                       !03626K02
                                                                       !03627
    if  hdr.typ = tran^acknowledge^d then                              !03628
                                                                       !03628K00
        begin                                                          !03628K01
        mov^( full^msg^mac, pos.p0230.full^mac^in     );               !03628K02
        movl( pmac^map,     pos.p0230.pmac^map^in, 16 );               !03628K03
        movl( smac^map,     pos.p0230.smac^map^in, 16 );               !03628K04
        set ( mac^in^req,   pos.p0230.mac^in^req      );               !03628K05
                                                                       !03628K06
        return util^hdr^verify( hdr,                                   !03629
            pos.p0230.preq^map, pos.p0230.sreq^map );                  !03630
                                                                       !03630K00
        end;                                                           !03630K01
                                                                       !03630K02
                                                                       !03631
    if  hdr.typ = rvsl^request^d or hdr.typ = rvsl^request^repeat^d then
                                                                       !03631K00
        begin                                                          !03631K01
        mov^( full^msg^mac, pos.p0402.full^mac^in     );               !03631K02
        movl( pmac^map,     pos.p0402.pmac^map^in, 16 );               !03631K03
        movl( smac^map,     pos.p0402.smac^map^in, 16 );               !03631K04
        set ( mac^in^req,   pos.p0402.mac^in^req      );               !03631K05
                                                                       !03631K06
        return util^hdr^verify( hdr,                                   !03634
            pos.p0402.preq^map, pos.p0402.sreq^map );                  !03635
                                                                       !03635K00
        end;                                                           !03635K01
                                                                       !03635K02
                                                                       !03636
    if  hdr.typ = rvsl^response^d  then                                !03637
                                                                       !03637K00
        begin                                                          !03637K01
        mov^( full^msg^mac, pos.p0412.full^mac^in     );               !03637K02
        movl( pmac^map,     pos.p0412.pmac^map^in, 16 );               !03637K03
        movl( smac^map,     pos.p0412.smac^map^in, 16 );               !03637K04
        set ( mac^in^req,   pos.p0412.mac^in^req      );               !03637K05
                                                                       !03637K06
        return util^hdr^verify( hdr,                                   !03638
            pos.p0412.preq^map, pos.p0412.sreq^map );                  !03639
                                                                       !03639K00
        end;                                                           !03639K01
                                                                       !03639K02
                                                                       !03640
    if  hdr.typ = rvsl^advice^d or hdr.typ = rvsl^repeat^d then        !03641
                                                                       !03641K00
        begin                                                          !03641K01
        mov^( full^msg^mac, pos.p0420.full^mac^in     );               !03641K02
        movl( pmac^map,     pos.p0420.pmac^map^in, 16 );               !03641K03
        movl( smac^map,     pos.p0420.smac^map^in, 16 );               !03641K04
        set ( mac^in^req,   pos.p0420.mac^in^req      );               !03641K05
                                                                       !03641K06
        return util^hdr^verify( hdr,                                   !03642
            pos.p0420.preq^map, pos.p0420.sreq^map );                  !03643
                                                                       !03643K00
        end;                                                           !03643K01
                                                                       !03643K02
                                                                       !03644
    if  hdr.typ = rvsl^acknowledge^d then                              !03645
                                                                       !03645K00
        begin                                                          !03645K01
        mov^( full^msg^mac, pos.p0430.full^mac^in     );               !03645K02
        movl( pmac^map,     pos.p0430.pmac^map^in, 16 );               !03645K03
        movl( smac^map,     pos.p0430.smac^map^in, 16 );               !03645K04
        set ( mac^in^req,   pos.p0430.mac^in^req      );               !03645K05
                                                                       !03645K06
        return util^hdr^verify( hdr,                                   !03646
            pos.p0430.preq^map, pos.p0430.sreq^map );                  !03647
                                                                       !03647K00
        end;                                                           !03647K01
                                                                       !03647K02
                                                                       !03648
    return( 1 ); ! Invalid Message Type !                              !03649
    end;                                                               !03650
?section pos^util^ilf^compress                                         !03651
?page "                                   - pos^util^ilf^compress"     !03651K00
!#####################################################################!!03654
!#                                                                   #!!03655
!#                     POS^UTIL^ILF^COMPRESS                         #!!03656
!#                                                                   #!!03657
!#    NARRATIVE : THIS PROCEDURE COMPRESSES THE PSTM INTO THE POS    #!!03658
!#       PORTION OF THE ILF.                                         #!!03659
!#                                                                   #!!03660
!#    INPUT PARAMETERS:                                              #!!03661
!#       B24^MSG       : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!03662
!#                                                                   #!!03663
!#    OUTPUT PARAMETERS:                                             #!!03664
!#       ILF           : POINTER TO ILF RECORD                       #!!03665
!#                                                                   #!!03666
!#####################################################################!!03667
proc pos^util^ilf^compress( ilf, b24^msg );                            !03668
int  .ilf( ilf^def );                                                  !03669
int  .b24^msg;                                                         !03670
                                                                       !03671
    begin                                                              !03672
    int .pstm( pstm^def ) := @b24^msg;                                 !03673
                                                                       !03674
!@*****************************************************************@!
!@ BEGIN RPQ #290 New fields in the ILF
!@-----------------------------------------------------------------@!
    ilf.sem.user^fld.byte[0] ':=' pstm.retl^sic^cde for
                            $len( pstm.retl^sic^cde );

    ilf.sem.user^fld.byte[4] ':=' pstm.crd^accpt^id^num for
                            $len( pstm.crd^accpt^id^num );

    ilf.sem.user^fld.byte[15] ':=' " ";
!@-----------------------------------------------------------------@!
!@ END   RPQ #290 New fields in the ILF
!@*****************************************************************@!
                                                                       !03674K00
    call hiswilf^compress( ilf, b24^msg );                             !03674K01
                                                                       !03674K02
                                                                       !03674K03
                                                                       !03675K00
                                                                       !03675K01
                                                                       !03675K02
    !!                                                                 !03730D01
    ! Transfer address verification status from the PSTM to the ILF!   !03730D02
    !!                                                                 !03730D03
    if pstm.addr^typ = av^addr^typ^d then                              !03730D04
        move( ilf.pos.addr^vrfy^stat, pstm.addr^flds.addr^vrfy^stat )  !03730D05
                                                                       !03730K00
                                                                       !03730K01
                                                                       !03730K02
                                                                       !03730D08
                                                                       !03731
    end;                                                               !03732
?section pos^util^ilf^expand                                           !03733
?page "                                        - pos^util^ilf^expand"  !03734
!#####################################################################!!03735
!#                                                                   #!!03736
!#                       POS^UTIL^ILF^EXPAND                         #!!03737
!#                                                                   #!!03738
!#    NARRATIVE : THIS PROCEDURE EXPANDS THE POS PORTION OF THE ILF  #!!03739
!#       INTO THE PSTM FORMAT.                                       #!!03740
!#                                                                   #!!03741
!#    INPUT PARAMETERS :                                             #!!03742
!#       ILF           : POINTER TO ILF RECORD                       #!!03743
!#                                                                   #!!03744
!#    OUTPUT PARAMETERS:                                             #!!03745
!#       B24^MSG       : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!03746
!#                                                                   #!!03747
!#####################################################################!!03748
proc pos^util^ilf^expand( ilf, b24^msg );                              !03749
int  .ilf( ilf^def );                                                  !03750
int  .b24^msg;                                                         !03751
                                                                       !03752
    begin                                                              !03753
    int  .pstm( pstm^def ) := @b24^msg;                                !03754
                                                                       !03755
                                                                       !03755K00
                                                                       !03755|00
    call hiswilf^expand( ilf, b24^msg, pos^pct.num^srv );              !03755|01
                                                                       !03755|02
                                                                       !03755K02
                                                                       !03755K03
!@*****************************************************************@!
!@ BEGIN RPQ #290 New fields in the ILF
!@-----------------------------------------------------------------@!

    pstm.retl^sic^cde     ':=' ilf.sem.user^fld.byte[0] for
                               $len( pstm.retl^sic^cde );

    pstm.crd^accpt^id^num ':=' ilf.sem.user^fld.byte[4] for
                               $len( pstm.crd^accpt^id^num );

!@-----------------------------------------------------------------@!
!@ END   RPQ #290 New fields in the ILF
!@*****************************************************************@!
                                                                       !03756K00
                                                                       !03756K01
                                                                       !03756K02
    call integer^ascii^( pstm.prod^id, pct.options.pos.id         );   !03774
                                                                       !03775K00
                                                                       !03775K01
                                                                       !03775K02
    movd( pstm.tran.orig,            "BICI"                       );   !03799
                                                                       !03800K00
                                                                       !03800#00
    !                                                                 !!03800#01
    ! Populate original data elements from the ILF.                   !!03800#02
    !                                                                 !!03800#03
                                                                       !03800+00
                                                                       !03800+01
                                                                       !03800700
    movl( pstm.orig^data.msg^typ,      ilf.pos.typ,  2 );              !03800701
                                                                       !03800702
    move( pstm.orig^data.tran^seq^num, ilf.pos.seq^num );              !03800+03
                                                                       !03800+04
                                                                       !03800#06
                                                                       !03800#07
                                                                       !03800+05
                                                                       !03800+06
    movl( pstm.orig^data.trn^dat,      ilf.pos.tran^dat.mm,            !03800+07
          $len( pstm.orig^data.trn^dat ) );                            !03800+08
    move( pstm.orig^data.trn^tim, ilf.pos.tran^tim );                  !03800+09
    movl( pstm.orig^data.b24^post^dat, ilf.pos.post^dat.mm,            !03800+0A
          $len( pstm.orig^data.b24^post^dat ) );                       !03800+0B
                                                                       !03800+0C
    !!                                                                 !03829D01
    ! Transfer address verification status from the ILF to the PSTM!   !03829D02
    !!                                                                 !03829D03
    move( pstm.addr^flds.addr^vrfy^stat,  ilf.pos.addr^vrfy^stat  );   !03829D04
                                                                       !03829D05
                                                                       !03830K00
                                                                       !03830K01
                                                                       !03830K02
    set ( pstm.num^services,         pos^pct.num^srv              );   !03835
                                                                       !03836
    use i;                                                             !03837
    for i:= 0 to pstm.num^services - 1 do                              !03838
        begin                                                          !03839
        move( pstm.srvcs[i].typ,        pos^pct.allowed^srv[i].srv );  !03840
                                                                       !03840L00
        move( pstm.srvcs[i].tran^profile,                              !03840L01
                                     ilf.pos.tran.dft^capture^flg  );  !03840L02
                                                                       !03840L03
                                                                       !03841L00
                                                                       !03841L01
        set ( pstm.srvcs[i].flr^lmt,        0d                     );  !03842
        set ( pstm.srvcs[i].tran^lmt,       0d                     );  !03843
        end;                                                           !03844
    drop i;                                                            !03845
    end;                                                               !03846
                                                                       !03846j00
?section pos^util^orig^crncy^tkn^add                                   !03846j01
?page "pos^util^orig^crncy^tkn^add"                                    !03846j02
!#####################################################################!!03846j03
!#                                                                   #!!03846j04
!#                     pos^util^orig^crncy^tkn^add                   #!!03846j05
!#                                                                   #!!03846j06
!#  This procedure adds the Original Currency Token to the PSTM.     #!!03846j07
!#                                                                   #!!03846j08
!#  INPUT PARAMETERS:                                                #!!03846j09
!#      sem     -  the external message that matches the PSTM        #!!03846j0A
!#                                                                   #!!03846j0B
!#  OUTPUT PARAMETERS:                                               #!!03846j0C
!#      pstm    -  the PSTM that the token should be appended to     #!!03846j0D
!#                                                                   #!!03846j0E
!#####################################################################!!03846j0F
proc pos^util^orig^crncy^tkn^add( sem, pstm );                         !03846j0G
int        .sem( sem^def );                                            !03846j0H
int        .pstm( pstm^def );                                          !03846j0I
    begin                                                              !03846j0J
    wlform( noroom^pstm,                                               !03846j0K
            "UNABLE TO ADD ORIGINAL CRNCY TOKEN TO PSTM (NO ROOM): "   !03846j0L
            ',' " PAN: \\\\\\\\\\\\\\\\\\\, SEQ NUM : \\\\\\\\\\\\ " ) !03846j0M
                                                                       !03846j0N
    wlform( err^adtkn,                                                 !03846j0O
            "UNABLE TO ADD ORIGINAL CRNCY TOKEN TO PSTM: "             !03846j0P
            ',' " PAN: \\\\\\\\\\\\\\\\\\\, SEQ NUM: \\\\\\\\\\\\"     !03846j0Q
            ',' " ERR: #" )                                            !03846j0R
                                                                       !03846j0S
    wlform( err^rdtkn,                                                 !03846j0T
            "UNABLE TO READ ORIGINAL CRNCY TOKEN FROM PSTM:"           !03846j0U
            ',' " PAN: \\\\\\\\\\\\\\\\\\\, SEQ NUM: \\\\\\\\\\\\"     !03846j0V
            ',' " ERR: #" )                                            !03846j0W
                                                                       !03846j0X
    struct         .orig^crncy^60^tkn( orig^crncy^60^tkn^def );        !03846j0Y
                                                                       !03846j0Z
    int             datalgth := 26;                                    !03846j0a
    int             dspy := false;                                     !03846j0b
    int             lgth;                                              !03846j0c
    int             ofst;                                              !03846j0d
    int             pan^lgth := -1;                                    !03846j0e
    int            .pbit^map := wordaddr( @sem.isopsem.pri^bit^map );  !03846j0f
    int             pos^userdata;                                      !03846j0g
    int            .sbit^map :=                                        !03846j0h
                        wordaddr( @sem.isopsem.secndry^bit^map );      !03846j0i
    int             tkn^len;                                           !03846j0j
    int            .tkn^ptr ( orig^crncy^60^tkn^def );                 !03846j0k
    int             tkn^result;                                        !03846j0l
                                                                       !03846j0m
    string         .discdata[ 0:25 ] := [ 26 * [" "] ];                !03846j0n
    string         .pan[ 0:max^pan^lgth^l - 1 ] :=                     !03846j0o
                        [ max^pan^lgth^l * [" "] ];                    !03846j0p
    string          tkn^id[ 0:1 ];                                     !03846j0q
                                                                       !03846j0r
                                                                       !03846j0s
    if base24^rel^g >= 5 then                                          !03846j0t
        begin                                                          !03846j0u
        orig^crncy^60^tkn ':=' blanks for $len( orig^crncy^60^tkn );   !03846j0v
                                                                       !03846j0w
        tkn^id ':=' orig^crncy^60^tkn^id^d;                            !03846j0x
                                                                       !03846j0y
        call ascii^fixed( psem.tran^amt, $len( psem.tran^amt ),        !03846j0z
                          orig^crncy^60^tkn.amt^1 );                   !03846j10
                                                                       !03846j11
        orig^crncy^60^tkn.amt^2 := 0f;                                 !03846j12
                                                                       !03846j13
        if psem.add^amts.b24^def.amt <>                                !03846j14
               blanks for $len( psem.add^amts.b24^def.amt ) then       !03846j15
            begin                                                      !03846j16
                                                                       !03846l00
                                                                       !03846l01
            if ( psem.setl^crncy = blanks for                          !03846l02
                     $len( psem.setl^crncy ) or                        !03846l03
                 enhanced^crncy^conv^pos^d ) then                      !03846l04
                                                                       !03846l05
                begin                                                  !03846j19
                call ascii^fixed( psem.add^amts.b24^def.amt,           !03846j1A
                                  $len( psem.add^amts.b24^def.amt ),   !03846j1B
                                  orig^crncy^60^tkn.amt^2 );           !03846j1C
                end;                                                   !03846j1D
            end;                                                       !03846j1E
                                                                       !03846j1F
        orig^crncy^60^tkn.crncy^cde ':='                               !03846j1G
            psem.crncy^cde for $len( orig^crncy^60^tkn.crncy^cde );    !03846j1H
        orig^crncy^60^tkn.conv^rate ':='                               !03846j1I
            psem.setl^conv^rat for                                     !03846j1J
            $len( orig^crncy^60^tkn.conv^rate );                       !03846j1K
        orig^crncy^60^tkn.conv^dat ':='                                !03846j1L
            psem.conv^dat for $len( orig^crncy^60^tkn.conv^dat );      !03846j1M
                                                                       !03846j1N
        @tkn^ptr := @orig^crncy^60^tkn;                                !03846j1O
        lgth := $len( orig^crncy^60^tkn );                             !03846j1P
                                                                       !03846j1Q
        ofst := $offset( pstm.srvcs ) +                                !03846j1R
                ( pos^pct.num^srv * $len( pstm.srvcs ) );              !03846j1S
                                                                       !03846j1T
        if pstm.data^flag <> "0" then                                  !03846j1U
            begin                                                      !03846j1V
            pos^userdata := true;                                      !03846j1W
            end                                                        !03846j1X
        else                                                           !03846j1Y
            begin                                                      !03846j1Z
            pos^userdata := false;                                     !03846j1a
            end;                                                       !03846j1b
                                                                       !03846j1c
        tkn^result := tkn^add^info( pstm,                              !03846j1d
                                    ofst,                              !03846j1e
                                    max^msg^lgth^l,                    !03846j1f
                                    tkn^id,                            !03846j1g
                                    tkn^ptr,                           !03846j1h
                                    lgth,                              !03846j1i
                                    ! max^tkn^buf^lgth !,              !03846j1j
                                    tkn^len,                           !03846j1k
                                    dspy,                              !03846j1l
                                    ! tkn^ebcdic^flg !,                !03846j1m
                                    pos^userdata );                    !03846j1n
                                                                       !03846j1o
        if tkn^result then                                             !03846j1p
            begin                                                      !03846j1q
            while ( ( pan^lgth := pan^lgth + 1 ) <                     !03846j1r
                      max^pan^lgth^l ) and                             !03846j1s
                  $numeric( psem.track2.data.byte[ pan^lgth ] ) do;    !03846j1t
            init ( pan, " ", $occurs( pan ) );                         !03846j1u
            movl ( pan, psem.track2.data, pan^lgth );                  !03846j1v
            !                                                         !!03846j1w
            ! If token already exists then retrieve it                !!03846j1x
            !                                                         !!03846j1y
            if tkn^result = tkn^exist^l then                           !03846j1z
                begin                                                  !03846j20
                tkn^result := 0;                                       !03846j21
                tkn^result := tkn^get^info( pstm,                      !03846j22
                                            ofst,                      !03846j23
                                            max^msg^lgth^l,            !03846j24
                                            tkn^id,                    !03846j25
                                            @orig^crncy^60^tkn,        !03846j26
                                            tkn^len );                 !03846j27
                if tkn^result then                                     !03846j28
                    begin                                              !03846j29
                    call log^message^( 4000, ! routing^code !,         !03846j2A
                                       @err^rdtkn,  net.myname,        !03846j2B
                                       evt^msg^severity^crit^l,        !03846j2C
                                       @pan, @pstm.seq^num,            !03846j2D
                                       tkn^result );                   !03846j2E
                    call abend^( 4000 );                               !03846j2F
                    end                                                !03846j2G
                else                                                   !03846j2H
                    begin                                              !03846j2I
                    if psem.add^amts.b24^def.amt <> blanks for         !03846j2J
                           $len( psem.add^amts.b24^def.amt ) then      !03846j2K
                        begin                                          !03846j2L
                                                                       !03846l06
                                                                       !03846l07
                        if ( psem.setl^crncy = blanks for              !03846l08
                                 $len( psem.setl^crncy ) or            !03846l09
                             enhanced^crncy^conv^pos^d ) then          !03846l0A
                                                                       !03846l0B
                            begin                                      !03846j2O
                            call ascii^fixed(                          !03846j2P
                                     psem.add^amts.b24^def.amt,        !03846j2Q
                                     $len( psem.add^amts.              !03846j2R
                                               b24^def.amt ),          !03846j2S
                                     orig^crncy^60^tkn.amt^2);         !03846j2T
                            end;                                       !03846j2U
                        end;                                           !03846j2V
                    end;                                               !03846j2W
                end                                                    !03846j2X
            else                                                       !03846j2Y
            if tkn^result = over^max^limit^l then                      !03846j2Z
                begin                                                  !03846j2a
                call log^message^( 4005, ! routing^code !,             !03846j2b
                                   @noroom^pstm, net.myname,           !03846j2c
                                   evt_msg_severity_err_l,             !03846j2d
                                   @pan, @pstm.seq^num );              !03846j2e
                end                                                    !03846j2f
            else                                                       !03846j2g
                begin                                                  !03846j2h
                call log^message^( 4010, ! routing^code !,             !03846j2i
                                   @err^adtkn, net.myname,             !03846j2j
                                   evt_msg_severity_crit_l,            !03846j2k
                                   @pan, @pstm.seq^num, tkn^result );  !03846j2l
                call abend^( 4010 );                                   !03846j2m
                end;                                                   !03846j2n
            end; ! tkn^result <> 0                                    !!03846j2o
        end; ! base24^rel^g >= 5                                      !!03846j2p
    end;                                                               !03846j2q
                                                                       !03846j2r
?section pos^util^perform^updt                                         !03847
?page "                                   - pos^util^perform^updt"     !03847K00
!#####################################################################!!03850
!#                                                                   #!!03851
!#                     POS^UTIL^PERFORM^UPDT                         #!!03852
!#                                                                   #!!03853
!#    NARRATIVE : THIS PROCEDURE UPDATES THE PERFORMANCE DATA        #!!03854
!#       FOR BASE24-pos.                                             #!!03855
!#                                                                   #!!03856
!#    INPUT PARAMETERS:                                              #!!03857
                                                                       !03858K00
                                                                       !03858K01
!#       TIMER^TYP     : TIMER TYPE OF TRANSACTION                   #!!03859
!#       UPDT^TYP      :                                             #!!03860
!#       START^TIM     : TRANSACTION START TIME                      #!!03861
!#       END^TIM       : TRANSACTION END TIME                        #!!03862
!#                                                                   #!!03863
!#    OUTPUT PARAMETERS:                                             #!!03864
!#                                                                   #!!03865
!#####################################################################!!03866
proc pos^util^perform^updt( timer^typ, updt^typ, start^tim,            !03867
    end^tim ) variable;                                                !03868
int   timer^typ;                                                       !03869
int   updt^typ;                                                        !03870
fixed start^tim;                                                       !03871
fixed end^tim;                                                         !03872
     begin                                                             !03873
                                                                       !03873K00
                                                                       !03873K01
     if not $param( timer^typ ) or not $param( updt^typ ) then         !03873K02
        call abend^( 1800 );                                           !03873K03
                                                                       !03873K04
                                                                       !03873K05
     if  updt^typ = updt^on^resp^l then                                !03874
                                                                       !03875
         ! Update the performance data to reflect this transactions   !!03876
                                                                       !03877
         begin                                                         !03878
         if  timer^typ = time^outbound^rqst^l then                     !03879
             begin                                                     !03880
             pos^pct.perform.outbound.count :=                         !03881
                 pos^pct.perform.outbound.count + 1d;                  !03882
                                                                       !03883
             pos^pct.perform.outbound.ttl^tim :=                       !03884
                 pos^pct.perform.outbound.ttl^tim +                    !03885
                 ( end^tim - start^tim );                              !03886
             end                                                       !03887
         else                                                          !03888
         if  timer^typ = time^inbound^rqst^l then                      !03889
             begin                                                     !03890
             pos^pct.perform.inbound.count :=                          !03891
                 pos^pct.perform.inbound.count + 1d;                   !03892
                                                                       !03893
             pos^pct.perform.inbound.ttl^tim :=                        !03894
                 pos^pct.perform.inbound.ttl^tim +                     !03895
                 ( end^tim - start^tim );                              !03896
             end;                                                      !03897
         end;                                                          !03898
                                                                       !03899
     if  updt^typ = updt^on^to^l then                                  !03900
                                                                       !03901
         ! Update the peformance data to reflect the timeout          !!03902
                                                                       !03903
         begin                                                         !03904
         if  timer^typ = time^outbound^rqst^l then                     !03905
             begin                                                     !03906
                                                                       !03906K00
             pos^pct.perform.outbound.timeouts :=                      !03906K01
                 pos^pct.perform.outbound.timeouts + 1d;               !03906K02
                                                                       !03906K03
                                                                       !03907K00
                                                                       !03907K01
                                                                       !03907K02
             end                                                       !03912
         else                                                          !03913
         if  timer^typ = time^inbound^rqst^l then                      !03914
             begin                                                     !03915
                                                                       !03915K00
             pos^pct.perform.inbound.timeouts :=                       !03915K01
                 pos^pct.perform.inbound.timeouts + 1d;                !03915K02
                                                                       !03915K03
                                                                       !03916K00
                                                                       !03916K01
                                                                       !03916K02
             end;                                                      !03921
         end;                                                          !03922
     end;                                                              !03923
?section pos^util^saf^send                                             !03924
?page "                                        - pos^util^saf^send"    !03925
                                                                       !03926
!#####################################################################!!03927
!#                                                                   #!!03928
!#                     POS^UTIL^SAF^SEND                             #!!03929
!#                                                                   #!!03930
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS AN EXTERNAL       #!!03931
!#       MESSAGE RETRIEVED FROM THE STORE AND FORWARD FILE.          #!!03932
!#                                                                   #!!03933
!#    INPUT PARAMETERS:                                              #!!03934
!#                                                                   #!!03935
!#    OUTPUT PARAMETERS:                                             #!!03936
!#       EXTMSG        : EXTERNAL MESSAGE                            #!!03937
!#       EXTLGTH       : EXTERNAL MESSAGE LENGTH                     #!!03938
!#       LOG^ACK^REQ   : LOGICAL ACKNOWLEDGEMENT REQUIRED (BOOLEAN)  #!!03939
!#       LIMIT         :                                             #!!03940
!#                                                                   #!!03941
!#####################################################################!!03942
proc pos^util^saf^send( extmsg, extlgth, log^ack^req, limit );         !03943
string  .extmsg;                                                       !03944
int     .extlgth;                                                      !03945
int     .log^ack^req;                                                  !03946
int(32) .limit;                                                        !03947
    begin                                                              !03948
                                                                       !03948K00
    wlform( saf^rec, "MAC Generation failure on SAF Record -" ','      !03948K01
                     " SAF Record follows : " )                        !03948K02
                                                                       !03948K03
                                                                       !03949K00
                                                                       !03949K01
                                                                       !03950
    struct  .sem( sem^def );                                           !03951
                                                                       !03952
                                                                       !03952K00
    int      error;                                                    !03952K01
                                                                       !03952K02
                                                                       !03953K00
                                                                       !03953K01
                                                                       !03953K02
                                                                       !03955
                                                                       !03955K00
    if  pos^util^sem^expand( sem, extmsg, extlgth ) then               !03955K01
                                                                       !03955K02
                                                                       !03956K00
                                                                       !03956K01
                                                                       !03956K02
        begin                                                          !03960
        call util^gmt^ascii( psem.xmit^dat^tim );                      !03961
        call integer^ascii^( psem.trace^num, trace^num^g );            !03962
                                                                       !03963
        if  psem.typ = rvsl^response^d  then                           !03964
            ! system ack to a response sent                           !!03965
            log^ack^req := true;                                       !03966
                                                                       !03967
                                                                       !03967K00
        if error := pos^util^sem^collapse( sem, extmsg, extlgth,       !03967K01
                                           gen^saf^mac^l ) then        !03967K02
            begin                                                      !03967K03
            if error = mac^operation^failed^l then                     !03967K04
                begin                                                  !03967K05
                call util^saf^delete;                                  !03967K06
                call logmessage^( 1137,, @saf^rec, net.myname,         !03967K07
                                  2, @pos^prod^g );                    !03967K08
                call log^message( 1138,, extmsg, $min( max^logger^l,   !03967K09
                                  extlgth ), net.myname,               !03967K0A
                                  2, @pos^prod^g );                    !03967K0B
                end;                                                   !03967K0C
            set( extlgth, 0 );                                         !03967K0D
            end;                                                       !03967K0E
                                                                       !03967K0F
                                                                       !03968K00
                                                                       !03968K01
        limit  := pos^pct.timers.saf;                                  !03969
        end;                                                           !03970
                                                                       !03971K00
                                                                       !03971K01
                                                                       !03971K02
                                                                       !03973
    end;                                                               !03974
                                                                       !03974)00
?section pos^util^sem^adjust^trk                                       !03974)01
?page "                                 - pos^util^sem^adjust^trk"     !03974)02
!#####################################################################!!03974)03
!#                                                                   #!!03974)04
!#                      POS^UTIL^SEM^ADJUST^TRK                      #!!03974)05
!#                                                                   #!!03974)06
!#    NARRATIVE : THIS PROC CLEAR/ENABLE THE BITMAP2 AND BITMAP35    #!!03974)07
!#                ON CHECKING THE VARIOUS CONDITIONS.                #!!03974)08
!#                                                                   #!!03974)09
!#    INPUT PARAMETERS:                                              #!!03974)0A
!#       SEM           : STANDARD EXTERNAL MESSAGE                   #!!03974)0B
!#       PSTM          : PSTM MESSAGE                                #!!03974)0C
!#                                                                   #!!03974)0D
!#    OUTPUT PARAMETERS:                                             #!!03974)0E
!#       SEM           : STANDARD EXTERNAL MESSAGE                   #!!03974)0F
!#                                                                   #!!03974)0G
!#####################################################################!!03974)0H
proc pos^util^sem^adjust^trk( sem, pstm ) extensible;                  !03974)0I
struct  .pstm( pstm^def );                                             !03974)0J
struct  .sem( sem^def );                                               !03974)0K
    begin                                                              !03974)0L
    define   msg^type( i ) = msg^tbl[ ( i ) * 4 ]#;                    !03974)0M
                                                                       !03974)0N
    string   msg^tbl = 'p' := [                                        !03974)0O
                                                                       !03974)0P
              "0100",  ! POS pre-auth request!                         !03974)0Q
              "0110",  ! POS pre-auth response!                        !03974)0R
              "0120",  ! POS pre-auth completion!                      !03974)0S
              "0130",  ! POS pre-auth completion ack!                  !03974)0T
              "0200",  ! POS request!                                  !03974)0U
              "0210",  ! POS response!                                 !03974)0V
              "0220",  ! POS completion!                               !03974)0W
              "0230",  ! POS completion ack!                           !03974)0X
              "0402",  ! POS card issuer reversal request!             !03974)0Y
              "0412",  ! POS card issuer reversal response!            !03974)0Z
              "0420",  ! POS acquirer reversal advice!                 !03974)0a
              "0430",  ! POS reversal advice response!                 !03974)0b
              "0500",  ! POS reconciliation request!                   !03974)0c
              "0520",  ! POS reconciliation advice!                    !03974)0d
              "0530",  ! POS reconciliation acknowledgement!           !03974)0e
                  0 ];                                                 !03974)0f
                                                                       !03974)0g
    int  .ext pos^tbl( pos^tbl^def ) ;                                 !03974)0h
                                                                       !03974)0i
    int       bit^map[ 0:7 ] := [ 8 * [0] ],                           !03974)0j
              i := -1,                                                 !03974)0k
              opt^map[ 0:7 ] := [ 8 * [0] ],                           !03974)0l
              man^map[ 0:7 ] := [ 8 * [0] ];                           !03974)0m
                                                                       !03974)0n
    if not $param( sem ) or not $param( pstm ) then                    !03974)0o
        begin                                                          !03974)0p
        call programmatic^dump( 1983 );                                !03974)0q
        end;                                                           !03974)0r
                                                                       !03974)0s
    while msg^type( i:=i+1 ) and  psem.typ <>                          !03974)0t
        msg^type( i ) for $len( psem.typ ) do ;                        !03974)0u
                                                                       !03974)0v
    if msg^type( i ) then                                              !03974)0w
        begin                                                          !03974)0x
        @pos^tbl := $xadr( pos ) + dlen( pos^tbl ) * $dbl( i );        !03974)0y
        call hexchar^binaryx( pos^tbl.popt^map, 32, opt^map );         !03974)0z
        call hexchar^binaryx( pos^tbl.pbit^map, 32, man^map );         !03974)10
        end;                                                           !03974)11
                                                                       !03974)12
    call hexchar^binary( psem.pri^bit^map, 32, bit^map );              !03974)13
                                                                       !03974)14
    !                                                                 !!03974)15
    ! When the PSTM contains swiped track data, if P-35 (Track data)  !!03974)16
    ! is mandatory and P-2 (PAN) is optional, turn off the bit for    !!03974)17
    ! P-2.                                                            !!03974)18
    !                                                                 !!03974)19
    if ( testbit( man^map, 1 ) and testbit( man^map, 34 ) ) and        !03974)1A
       testbit( opt^map, 1 ) and                                       !03974)1B
       pstm.tran.track2 = ";" then                                     !03974)1C
        begin                                                          !03974)1D
        call clearbit( bit^map, 1 );                                   !03974)1E
        end;                                                           !03974)1F
                                                                       !03974)1G
    !                                                                 !!03974)1H
    ! When the PSTM contains manually constructed track data, if P-2  !!03974)1I
    ! (PAN) is mandatory and P-35 (track data) is optional, turn off  !!03974)1J
    ! the bit for P-35.                                               !!03974)1K
    !                                                                 !!03974)1L
    if ( testbit( man^map, 1 ) and testbit( man^map, 34 ) ) and        !03974)1M
       testbit( opt^map, 34 ) and                                      !03974)1N
       pstm.tran.track2 = "M" then                                     !03974)1O
        begin                                                          !03974)1P
        call clearbit( bit^map, 34 );                                  !03974)1Q
        end;                                                           !03974)1R
                                                                       !03974)1S
    call binary^hexchar( psem.pri^bit^map, 32, bit^map );              !03974)1T
                                                                       !03974)1U
    end; ! of pos^util^sem^adjust^trk                                 !!03974)1V
                                                                       !03974)1W
?section pos^util^sem^collapse                                         !03975
?page "                                   - pos^util^sem^collapse"     !03975K00
!#####################################################################!!03978
!#                                                                   #!!03979
!#                    POS^UTIL^SEM^COLLAPSE                          #!!03980
!#                                                                   #!!03981
!#    NARRATIVE : THIS PROCEDURE COLLAPSES THE STANDARD EXTERNAL     #!!03982
!#       MESSAGE TO AN EXTERNAL MESSAGE.                             #!!03983
!#                                                                   #!!03984
!#    INPUT PARAMETERS:                                              #!!03985
!#       SEM           : STANDARD MESSAGE                            #!!03986
                                                                       !03986K00
!#       GENERATE^MAC  : FLAG TO INCDICATE IF MAC IS TO BE GENERATED #!!03986K01
!#       PSTM          : POINTER TO THE INTERNAL MESSAGE             #!!03986K02
                                                                       !03986K03
!#                                                                   #!!03987
!#    OUTPUT PARAMETERS:                                             #!!03988
!#       EXTMSG        : EXTERNAL MESSAGE                            #!!03989
                                                                       !03989K00
!#       MSG^LENGTH    : LENGTH OF THE COLLAPSED MESSAGE             #!!03989K01
                                                                       !03989K02
!#                                                                   #!!03990
!#####################################################################!!03991
                                                                       !03991K00
int proc pos^util^sem^collapse( sem, extmsg, msg^length,               !03991K01
                                generate^mac, pstm )variable;          !03991K02
                                                                       !03991K03
                                                                       !03992K00
                                                                       !03992K01
string .sem( sem^def );                                                !03993
string .extmsg;                                                        !03994
                                                                       !03994K00
int    .msg^length;                                                    !03994K01
int     generate^mac;                                                  !03994K02
int    .pstm( pstm^def );                                              !03994K03
                                                                       !03994K04
    begin                                                              !03995
    wlform( bad^msg, "FAILURE to FORMAT POS \\\\ Message - Field #" )  !03996
                                                                       !03997
    define   msg^type( i ) = msg^tbl[ ( i ) * 4 ]#;                    !03998
    string   msg^tbl = 'p' := [                                        !03999
              "0100",  ! POS pre-auth request                         !!04000
              "0110",  ! POS pre-auth response                        !!04001
              "0120",  ! POS pre-auth completion                      !!04002
              "0130",  ! POS pre-auth completion ack                  !!04003
              "0200",  ! POS request                                  !!04004
              "0210",  ! POS response                                 !!04005
              "0220",  ! POS completion                               !!04006
              "0230",  ! POS completion ack                           !!04007
              "0402",  ! POS card issuer reversal request             !!04008
              "0412",  ! POS card issuer reversal response            !!04009
              "0420",  ! POS acquirer reversal advice                 !!04010
              "0430",  ! POS reversal advice response                 !!04011
                  0 ];                                                 !04012
                                                                       !04013
    int       bit^map[ 0:7 ] := [ 8 * [0] ],                           !04014
                                                                       !04014K00
              full^mac,                                                !04014K01
              i,                                                       !04014K02
              ims^length := 0,                                         !04014K03
              mac^lgth,                                                !04014K04
              mac^map[ 0:7 ] := [ 8 * [0] ],                           !04014K05
              mac^ofst,                                                !04014K06
              opt^map[ 0:7 ] := [ 8 * [0] ],                           !04014K07
              pin^ofst,                                                !04014K08
             .ext pos^tbl( pos^tbl^def ),                              !04014K09
              reject,                                                  !04014K0A
              repeat^flg;                                              !04014K0B
                                                                       !04014K0C
    string                                                             !04014K0D
             .mac^buf[ 0:$len( msg^def ) - 1 ],                        !04014K0E
             .mac^value[ 0:15 ],                                       !04014K0F
             .pin^value[ 0:15 ];                                       !04014K0G
                                                                       !04014K0H
    if not $param( sem ) or not $param( extmsg ) or                    !04014K0I
       not $param( msg^length ) then                                   !04014K0J
        call abend^( 1900 );                                           !04014K0K
                                                                       !04014K0L
    set( mac^ofst,   0 );                                              !04014K0M
    set( pin^ofst,   0 );                                              !04014K0N
    set( repeat^flg, 0 );                                              !04014K0O
                                                                       !K0401400
    if psem.typ <> "0100" and                                          !K0401401
       psem.typ <> "0200" then                                         !K0401402
        begin                                                          !K0401403
        set( comb^xlate^mac^generate^g, false );                       !K0401404
        end;                                                           !K0401405
                                                                       !K0401406
                                                                       !04014K0P
    if psem.typ = "0221" or psem.typ = "0421" then                     !04014K0Q
        begin                                                          !04014K0R
        movd( psem.typ.byte[3], "0" );                                 !04014K0S
        set( repeat^flg, true );                                       !04014K0T
        end;                                                           !04014K0U
                                                                       !04014K0V
                                                                       !04014K0W
                                                                       !04015K00
                                                                       !04015K01
                                                                       !04015K02
    !                                                                 !!04020
    ! First, determine the optional fields and ims tran codes         !!04021
    !                                                                 !!04022
                                                                       !04022K00
    i := -1;                                                           !04022K01
                                                                       !04022K02
                                                                       !04023K00
                                                                       !04023K01
    while msg^type( i:=i+1 ) and  psem.typ <>                          !04024
          msg^type( i ) for $len( psem.typ ) do;                       !04025
                                                                       !04026
    if  msg^type( i ) then                                             !04027
        begin                                                          !04028
        @pos^tbl := $xadr( pos ) + $dbl( $len( pos^tbl ) * i );        !04029
        call hexchar^binaryx( pos^tbl.popt^map, 32, opt^map );         !04030
                                                                       !04030K00
        call hexchar^binaryx( pos^tbl.pmac^map^out,                    !04030K01
                              16, mac^map[ 0 ] );                      !04030K02
        call hexchar^binaryx( pos^tbl.smac^map^out,                    !04030K03
                              16, mac^map[ 4 ] );                      !04030K04
                                                                       !04030K05
        if pos^tbl.full^mac^out = "Y" then                             !04030K06
            set( full^mac, true )                                      !04030K07
        else                                                           !04030K08
        if pos^tbl.full^mac^out = "N" then                             !04030K09
            set( full^mac, false )                                     !04030K0A
        else                                                           !04030K0B
            set( full^mac, pct.mac.full^msg^mac );                     !04030K0C
                                                                       !04030K0D
                                                                       !04030K0E
        ims^length := util^ims^get( pos^tran^cde^g, extmsg,            !04031
                      pos^tbl.tran^ctr,  pos^tbl.tran^tbl );           !04032
        end;                                                           !04033
                                                                       !04034
                                                                       !04034K00
    if repeat^flg then                                                 !04034K01
        movd( psem.typ.byte[3], "1" );                                 !04034K02
                                                                       !04034K03
                                                                       !04034K04
    if  pct.options.fixed^lgth^frmt then                               !04035
        !                                                             !!04036
        ! Fixed length field format                                   !!04037
        !                                                             !!04038
        begin                                                          !04039
        call integer^ascii^( psem.pan.len,    $len( psem.pan.data ) ); !04040
        call integer^ascii^( psem.acq^inst^id.len,                     !04041
            $len( psem.acq^inst^id.num ) );                            !04042
        call integer^ascii^( psem.frwd^inst^id.len,                    !04043
            $len( psem.frwd^inst^id.num ) );                           !04044
                                                                       !04045
                                                                       !04045M00
                                                                       !04045M01
        call integer^ascii^( psem.track1.len, $len( psem.track1.data ) );
        call integer^ascii^( psem.track2.len, $len( psem.track2.data ) );
        call integer^ascii^( psem.track3.len, $len( psem.track3.data ) );
                                                                       !04045M08
                                                                       !04050
        call integer^ascii^( ssem.setl^inst.len,                       !04051
            $len( ssem.setl^inst.id^num ) );                           !04052
        call integer^ascii^( ssem.rcv^inst.len,                        !04053
            $len( ssem.rcv^inst.id^num ) );                            !04054
                                                                       !04055
        call integer^ascii^( ssem.secndry^rsrvd3^prvt.len,             !04056
             $len( ssem.secndry^rsrvd3^prvt.b24.crd^iss^id^num ) );    !04057
                                                                       !04058
        call integer^ascii^( ssem.acct1.len,  $len( ssem.acct1.num ) );
                                                                       !04061
        call integer^ascii^( psem.resp^data.len,                       !04062
            $len( psem.resp^data.bal ) );                              !04063
        call integer^ascii^( psem.add^amts.len,                        !04064
            $len( psem.add^amts.b24^def.amt ) );                       !04065
                                                                       !04066
        call integer^ascii^( ssem.secndry^rsrvd3^prvt.len,             !04067
            $len( ssem.secndry^rsrvd3^prvt.b24 ) -                     !04068
            $len( ssem.secndry^rsrvd3^prvt.b24.reserved ) );           !04069
        call integer^ascii^( ssem.secndry^rsrvd4^prvt.len,             !04070
            $len( ssem.secndry^rsrvd4^prvt.pos ) -                     !04071
            $len( ssem.secndry^rsrvd4^prvt.pos.reserved ) );           !04072
        end;                                                           !04073
                                                                       !04074
    if  psem.xmit^dat^tim = zeroes for 10 or                           !04075
        psem.xmit^dat^tim = blanks for 10 then                         !04076
        call util^gmt^ascii( psem.xmit^dat^tim );                      !04077
                                                                       !04078
    !                                                                 !!04079
    ! Adjust the bit maps for optional data fields                    !!04080
    !                                                                 !!04081
    call hexchar^binary( psem.pri^bit^map, 32, bit^map );              !04082
    call util^sem^adjust( sem, bit^map[0], bit^map[4],                 !04083
        opt^map[0],  opt^map[4] );                                     !04084
                                                                       !04085
                                                                       !04085K00
    !!                                                                 !04085K01
    !if combined pin translate mac generate command is used the pin!   !04085K02
    !bit ( bit 52 ) will be turned off so it must be turned back on!   !04085K03
    !before the message is collapsed!                                  !04085K04
    !!                                                                 !04085K05
    if comb^xlate^mac^generate^g  and                                  !04085K06
       not testbit( bit^map, 51 ) then                                 !04085K07
        call setbit( bit^map, 51 );                                    !04085K08
                                                                       !04085K09
                                                                       !04085P00
    !if field 95 is present, it could be turned off if amount 2 is    !!04085P01
    !0, since the 30 bytes of filler are now sent as 0s and not       !!04085P02
    !spaces. Under these conditions bit 95 needs to be turned back    !!04085P03
    !on before the message is collapsed.                              !!04085P04
                                                                       !L0408500
    if $param( pstm ) then                                             !L0408501
        begin                                                          !L0408502
                                                                       !L0408503
                                                                       !L0408504
                                                                       !L0408505
        if ( pstm.typ = pstm^request^d or                              !L0408506
             pstm.typ = pstm^tran^advice^d ) and                       !L0408507
             pstm^adjustments^d( pstm ) and                            !L0408508
           ( pstm.tran.amt^2 = 0f and                                  !L0408509
             ssem.replacement = zeroes                                 !L040850A
                 for $len( ssem.replacement ) ) then                   !L040850B
                                                                       !L040850C
                                                                       !04085d00
                                                                       !L040850D
                 begin                                                 !L040850E
                                                                       !L040850F
                                                                       !04085d02
                                                                       !L040850G
                 call setbit( bit^map, 94 );                           !L040850H
                                                                       !L040850I
                                                                       !04085d03
                                                                       !L040850J
                                                                       !L040850K
                 call setbit( bit^map,  0 );                           !L040850L
                 end;                                                  !L040850M
                                                                       !L040850N
                                                                       !04085d06
                                                                       !04085P0C
                                                                       !L040850O
                                                                       !L040850P
        if pstm.typ = pstm^rvsl^request^d and                          !L040850Q
           ( pstm.tran.amt^2 = 0f and                                  !L040850R
             ssem.replacement = zeroes                                 !L040850S
                 for $len( ssem.replacement ) ) then                   !L040850T
                                                                       !L040850U
                                                                       !04085d07
                                                                       !L040850V
                 begin                                                 !L040850W
                                                                       !L040850X
                                                                       !04085d09
                                                                       !L040850Y
                 call setbit( bit^map, 94 );                           !L040850Z
                                                                       !L040850a
                                                                       !04085d0A
                                                                       !L040850b
                                                                       !L040850c
                 call setbit( bit^map,  0 );                           !L040850d
                 end;                                                  !L040850e
        end ! of $param check                                         !!L040850f
    else                                                               !L040850g
    if not $param( pstm ) then                                         !L040850h
        !                                                             !!L040850i
        ! messages de-queued from SAF do not have PSTM available      !!L040850j
        !                                                             !!L040850k
        begin                                                          !L040850l
        if ( psem.typ = "022" or psem.typ = "04" ) and                 !L040850m
           pos^adjustment^d( sem ) and                                 !L040850n
           ssem.replacement =                                          !L040850o
                [ $len( ssem.replacement ) * ["0"] ]  then             !L040850p
            begin                                                      !L040850q
            call setbit( bit^map, 94 );                                !L040850r
            call setbit( bit^map,  0 );                                !L040850s
            end;                                                       !L040850t
        end; ! of not $param check                                    !!L040850u
                                                                       !L040850v
                                                                       !04085d0D
                                                                       !04085P0I
                                                                       !04085K0A
    call binary^hexchar( psem.pri^bit^map, 32, bit^map );              !04086
                                                                       !04087
                                                                       !04087K00
    set( mac^lgth, 0 );                                                !04087K01
                                                                       !04087K02
    !                                                                 !!04088
    ! Collapse the external message                                   !!04089
    !                                                                 !!04090
                                                                       !04090K00
    if  reject := util^sem^collapse( sem, extmsg[ims^length],          !04090K01
                                     msg^length, mac^map, full^mac,    !04090K02
                                     mac^buf, mac^lgth, pin^ofst,      !04090K03
                                     mac^ofst ) then                   !04090K04
                                                                       !04090K05
                                                                       !04091K00
                                                                       !04091K01
                                                                       !04091K02
        begin                                                          !04093
        call logmessage^( 1145,, @bad^msg, net.myname, 2,              !04094
            @pos^prod^g, @psem.typ, reject );                          !04095
        return false;                                                  !04096
        end;                                                           !04097
                                                                       !04097K00
                                                                       !04097K01
    if $param( generate^mac ) and                                      !04097K02
       mac^lgth > 0           then                                     !04097K03
        begin                                                          !04097K04
        movl( mac^value, zeroes, $occurs( mac^value ) );               !04097K05
                                                                       !04097K06
        if comb^xlate^mac^generate^g then                              !04097K07
            begin                                                      !04097K08
            if reject := pos^util^xlate^mac^generate( mac^buf,         !04097K09
                                  mac^lgth, mac^value, mac^ofst,       !04097K0A
                                  pin^value, pstm ) then               !04097K0B
                begin                                                  !04097K0C
                set( comb^xlate^mac^generate^g, false );               !04097K0D
                return reject;                                         !04097K0E
                end                                                    !04097K0F
            else                                                       !04097K0G
                begin                                                  !04097K0H
                                                                       !04097L00
                extmsg[ pin^ofst '+' ims^length ] ':=' pin^value for   !04097L01
                                                                       !04097L02
                                                                       !04097L03
                                                                       !04097L04
                                        $occurs( pin^value );          !04097K0J
                                                                       !04097K0K
                                                                       !04097L05
                extmsg[ ( msg^length '+' ims^length ) -                !04097L06
                                $occurs( mac^value ) ] ':='            !04097L07
                                                                       !04097L08
                                                                       !04097L09
                                                                       !04097L0A
                                mac^value for $occurs( mac^value );    !04097K0M
                                                                       !04097K0N
                set( comb^xlate^mac^generate^g, false );               !04097K0O
                end;                                                   !04097K0P
            end                                                        !04097K0Q
        else                                                           !04097K0R
            begin                                                      !04097K0S
            if reject := util^mac^generate( mac^buf, mac^lgth,         !04097K0T
                                            mac^value ) then           !04097K0U
                return reject                                          !04097K0V
            else                                                       !04097K0W
                                                                       !04097L0B
                extmsg[ ( msg^length '+' ims^length ) -                !04097L0C
                                $occurs( mac^value ) ] ':='            !04097L0D
                                                                       !04097L0E
                                                                       !04097L0F
                                                                       !04097L0G
                                mac^value for $occurs( mac^value );    !04097K0Y
            end;                                                       !04097K0Z
        end;                                                           !04097K10
                                                                       !04097K11
    msg^length := ims^length '+' msg^length;                           !04097K12
                                                                       !04097K13
    return reject;                                                     !04097K14
                                                                       !04097K15
                                                                       !04098K00
                                                                       !04098K01
                                                                       !04098K02
    end;                                                               !04100
?section pos^util^sem^expand                                           !04101
?page "                                        - pos^util^sem^expand"  !04102
                                                                       !04103
!#####################################################################!!04104
!#                                                                   #!!04105
!#                   POS^UTIL^SEM^EXPAND                             #!!04106
!#                                                                   #!!04107
!#    NARRATIVE : THIS PROCEDURE EXPANDS THE EXTERNAL MESSAGE TO A   #!!04108
!#       STANDARD EXTERNAL MESSAGE.                                  #!!04109
!#                                                                   #!!04110
!#    INPUT PARAMETERS:                                              #!!04111
!#       EXTMSG        : EXTERNAL MESSAGE                            #!!04112
!#       EXTLGTH       : EXTERNAL MESSAGE LENGTH                     #!!04113
                                                                       !04113K00
!#       FULL^MSG^MAC  : FLAG INDICATING IF FULL MESSAGE IS MAC'ED   #!!04113K01
!#       PMAC^MAP      : PRIMARY MAC BIT MAP                         #!!04113K02
!#       SMAC^MAP      : SECONDARY MAC BIT MAP                       #!!04113K03
!#       MAC^IN^REQ    : MAC INBOUND REQUIRED                        #!!04113K04
                                                                       !04113K05
!#                                                                   #!!04114
!#    OUTPUT PARAMETERS:                                             #!!04115
!#       SEM           : STANDARD MESSAGE                            #!!04116
!#       REJECT        : REJECT FIELD IF ANY                         #!!04117
!#                                                                   #!!04118
!#####################################################################!!04119
                                                                       !04119K00
int proc pos^util^sem^expand( sem, extmsg, extlgth, reject,            !04119K01
                              full^msg^mac, pmac^map,                  !04119K02
                              smac^map, mac^in^req ) variable;         !04119K03
                                                                       !04119K04
                                                                       !04120K00
                                                                       !04120K01
string .sem( sem^def );                                                !04121
string .extmsg;                                                        !04122
int     extlgth;                                                       !04123
int    .reject;                                                        !04124
                                                                       !04124K00
string .full^msg^mac;                                                  !04124K01
string .pmac^map;                                                      !04124K02
string .smac^map;                                                      !04124K03
int    .mac^in^req;                                                    !04124K04
                                                                       !04124K05
                                                                       !04124K06
    begin                                                              !04125
    wlform( bad^msg, "FAILURE to EXPAND POS \\\\ Message - Field #" )  !04126
                                                                       !04127
                                                                       !04127K00
    int                                                                !04127K01
             field,                                                    !04127K02
             full^mac,                                                 !04127K03
             length,                                                   !04127K04
             mac^inbound,                                              !04127K05
             mac^lgth;                                                 !04127K06
                                                                       !04127K07
    string                                                             !04127K08
            .mac^buf[ 0:$len( msg^def ) - 1 ],                         !04127K09
            .mac^value[ 0:15 ],                                        !04127K0A
            .pri^mac^map[ 0:15 ],                                      !04127K0B
            .sec^mac^map[ 0:15 ];                                      !04127K0C
                                                                       !04127c00
                                                                       !04127<00
    string          key_dir_s   := "I";                                !04127<01
                                                                       !04127<02
                                                                       !04127c02
    if not $param( sem )    or not $param( extmsg ) or                 !04127K0E
       not $param( extlgth) then                                       !04127K0F
        call abend^( 2000 );                                           !04127K0G
                                                                       !04127K0H
    set( mac^lgth, 0 );                                                !04127K0I
    if $param( full^msg^mac ) and                                      !04127K0J
       $param( pmac^map )     and                                      !04127K0K
       $param( smac^map )     and                                      !04127K0L
       $param( mac^in^req )   then                                     !04127K0M
        begin                                                          !04127K0N
        if full^msg^mac = "Y" then                                     !04127K0O
            set( full^mac, true )                                      !04127K0P
        else                                                           !04127K0Q
        if full^msg^mac = "N" then                                     !04127K0R
            set( full^mac, false )                                     !04127K0S
        else                                                           !04127K0T
            set( full^mac, pct.mac.full^msg^mac );                     !04127K0U
                                                                       !04127K0V
        movl( pri^mac^map, pmac^map, 16 );                             !04127K0W
        movl( sec^mac^map, smac^map, 16 );                             !04127K0X
        set(  mac^inbound, mac^in^req );                               !04127K0Y
        end                                                            !04127K0Z
    else                                                               !04127K10
        begin                                                          !04127K11
        set( full^mac,     false     );                                !04127K12
        movl( pri^mac^map, nulls, 16 );                                !04127K13
        movl( sec^mac^map, nulls, 16 );                                !04127K14
        set(  mac^inbound, false     );                                !04127K15
        end;                                                           !04127K16
                                                                       !04127K17
                                                                       !04128K00
                                                                       !04128K01
                                                                       !04129
    if  not $param( sem ) or not $param( extmsg ) then                 !04130
        call programmatic^dump( 0900 );                                !04131
                                                                       !04132
    length := if $param( extlgth ) then extlgth else $len( msg^def );  !04133
                                                                       !04134
    if  extmsg <> iso^identifier^d then                                !04135
        @extmsg := util^hdr^expand( extmsg, length );                  !04136
    !                                                                 !!04137
    ! Expand the external message                                     !!04138
    !                                                                 !!04139
                                                                       !04139K00
    if  field := util^sem^expand( sem, extmsg, length, full^mac,       !04139K01
                                                                       !04139Q00
                                                                       !04139Q01
                                  pri^mac^map, sec^mac^map,            !04139Q02
                                  mac^inbound, mac^buf, mac^lgth,      !04139Q03
                                  mac^value ) then                     !04139Q04
                                                                       !04139Q05
                                                                       !04140K00
                                                                       !04140K01
        begin                                                          !04141
        if  $param( reject ) then                                      !04142
                                                                       !04142K00
            begin                                                      !04142K01
            reject := field;                                           !04142K02
            if field = bit^64^mac^err^l then                           !04142K03
                set( field, bit^64^l )                                 !04142K04
            else                                                       !04142K05
            if field = bit^128^mac^err^l then                          !04142K06
                set( field, bit^128^l );                               !04142K07
            end;                                                       !04142K08
                                                                       !04142K09
                                                                       !04143K00
                                                                       !04143K01
                                                                       !04144
        call logmessage^( 1150,, @bad^msg, net.myname, 2,              !04145
            @pos^prod^g, @psem.typ, field );                           !04146
        return false;                                                  !04147
        end;                                                           !04148
                                                                       !04149
                                                                       !04149K00
    if $param( full^msg^mac ) and                                      !04149K01
       $param( pmac^map )     and                                      !04149K02
       $param( smac^map )     and                                      !04149K03
       $param( mac^in^req )   and                                      !04149K04
       mac^lgth > 0           then                                     !04149K05
        begin                                                          !04149K06
                                                                       !04149c00
                                                                       !04149<00
                                                                       !04149<01
                                                                       !04149<02
        reject := util^mac^verify( mac^buf,                            !04149c07
                                   mac^lgth,                           !04149c08
                                   mac^value,                          !04149c09
                                   ! incr^counter !,                   !04149c0A
                                   ! key !,                            !04149c0B
                                   ! chk^dgts !,                       !04149c0C
                                   key_dir_s );                        !04149c0D
                                                                       !04149c0E
                                                                       !04149c0F
                                                                       !04149c0G
                                                                       !04149c0H
        if reject then                                                 !04149K09
            return false;                                              !04149K0A
        end;                                                           !04149K0B
                                                                       !04149K0C
                                                                       !04149K0D
    return true;                                                       !04150
    end;                                                               !04151
?section pos^util^send^pstm                                            !04152
?page "                                        - pos^util^send^pstm"   !04153
!#####################################################################!!04154
!#                                                                   #!!04155
!#                    POS^UTIL^SEND^PSTM                             #!!04156
!#                                                                   #!!04157
!#    NARRATIVE : THIS PROCEDURE SENDS AN INTERNAL MESSAGE TO THE    #!!04158
!#       DESTINATION PROVIDED BY THE CALLING PROCEDURE.              #!!04159
!#                                                                   #!!04160
!#    INPUT PARAMETERS:                                              #!!04161
!#       PSTM          : POINTER TO THE BASE24 INTERNAL POS MESSAGE  #!!04162
!#       DEST          : PROCESS TO WHICH THE PSTM IS TO BE SENT     #!!04163
!#                                                                   #!!04164
!#    OUTPUT PARAMETERS:                                             #!!04165
!#                                                                   #!!04166
!#####################################################################!!04167
int proc pos^util^send^pstm( pstm, dest );                             !04168
int    .pstm( pstm^def );                                              !04169
int    .ext dest;                                                      !04170
    begin                                                              !04171
    wlform( trace, "T - pos^util^send^pstm (type: \\\\)" )             !04172
                                                                       !04172)00
    wlform( get^err, "Error # while attempting to get token \\ " )     !04172)01
                                                                       !04172)02
                                                                       !04173
                                                                       !04173)00
    struct .track1^tkn( track1^tkn^def );                              !04173)01
    int     error;                                                     !04173)02
                                                                       !04173)03
    int     length,                                                    !04174
           .msg [ 0:wlen( msg^def ) ],                                 !04175
            user^data^lgth := 0;                                       !04176
                                                                       !04177
                                                                       !04177)00
    int     tkn^lgth;                                                  !04177)01
                                                                       !04177)02
    string .mtp;                                                       !04178
                                                                       !04178)00
    string  tkn^id[ 0:1 ];                                             !04178)01
                                                                       !04178)02
                                                                       !04179
    if  trace^g.<pos^l> then                                           !04180
        call logmessage^( 1155,, @trace, net.myname,                   !04181
            0, @pos^prod^g, @pstm.typ );                               !04182
                                                                       !04183
    if  dest = "GATEWAY " then                                         !04184
        begin                                                          !04185
        call initialize^message( msg, net.gateway^dest );              !04186
        msg^category := msg^category^templateroute;                    !04187
        msg^subcategory^offset := $offset( pstm.tran.track2.byte[1] ); !04188
        end                                                            !04189
    else                                                               !04190
        begin                                                          !04191
        call initialize^message( msg,,, msg^sym^dest );                !04192
        msg^category := msg^category^passthru;                         !04193
        end;                                                           !04194
                                                                       !04194)00
    if bici_g.supprs_pstm_discr_data and                               !04194)01
       pstm.typ = pstm^response^d     then                             !04194)02
        begin                                                          !04194)03
        call supprs_trk2_discr_data( pstm.tran.track2,                 !04194)04
                                     $len( pstm.tran.track2 ) );       !04194)05
        if base24^rel^g >= 5 then                                      !04194)06
            begin                                                      !04194)07
            tkn^id ':=' track1^tkn^id^d;                               !04194)08
            error := tkn^get^info( pstm,                               !04194)09
                                   pstm^lgth^d( pstm ),                !04194)0A
                                   intrn^msg^lmt^l,                    !04194)0B
                                   tkn^id,                             !04194)0C
                                   @track1^tkn,                        !04194)0D
                                   tkn^lgth );                         !04194)0E
            if error = compl^no^err^l then                             !04194)0F
                begin                                                  !04194)0G
                call supprs_trk1_discr_data( track1^tkn,               !04194)0H
                                             tkn^lgth );               !04194)0I
                end                                                    !04194)0J
            else                                                       !04194)0K
                begin                                                  !04194)0L
                if error <> tkn^does^not^exist^l then                  !04194)0M
                    begin                                              !04194)0N
                    call logmessage^( 1156, ! routing code !,          !04194)0O
                                      @get^err, net.myname, 3,         !04194)0P
                                      @pos^prod^g, error, @tkn^id );   !04194)0Q
                    end;                                               !04194)0R
                end;                                                   !04194)0S
            end;                                                       !04194)0T
        end;                                                           !04194)0U
                                                                       !04194)0V
                                                                       !04195
    use i; i := 0;                                                     !04196
    while ( ( i := i + 1 ) < $len( pstm.tran.track2 ) ) and            !04197
          ( $numeric( pstm.tran.track2.byte[i] ) )  do;                !04198
    msg^subcategory^length := i - 1;                                   !04199
    drop i;                                                            !04200
                                                                       !04201
    set^text;                                                          !04202
    if  pstm.num^services > $occurs( pstm.srvcs ) then                 !04203
        pstm.num^services := $occurs( pstm.srvcs );                    !04204
                                                                       !04205
                                                                       !04205K00
    call hiswutil^calc^intrn^msg^lgth( pstm, $len( pstm ), length,     !04205K01
                                       pos^l, base24^rel^g );          !04205K02
                                                                       !04205K03
                                                                       !04205K04
                                                                       !04206K00
                                                                       !04206K01
                                                                       !04206K02
    mtp          ':=' pstm.typ for length;                             !04208
    msg^sym^dest ':=' dest for 8;                                      !04209
    msg^length    :=  length;                                          !04210
                                                                       !04210R00
                                                                       !I0421000
    if trace^num^g = 18259 then                                        !I0421001
                                                                       !I0421002
        begin                                                          !04210R02
        incr^trace( trace^num^g );                                     !04210R03
        end;                                                           !04210R04
                                                                       !04210R05
    msg^pro^1     :=  trace^num^g;                                     !04211
                                                                       !04212
                                                                       !04213K00
                                                                       !04213K01
                                                                       !04213K02
    if  not netwrite( msg ) then                                       !04224
        return false;                                                  !04225
                                                                       !04226
    return true;                                                       !04227
    end;                                                               !04228
?section pos^util^send^sem                                             !04229
?page "                                        - pos^util^send^sem"    !04230
                                                                       !04231
!#####################################################################!!04232
!#                                                                   #!!04233
!#                       POS^UTIL^SEND^SEM                           #!!04234
!#                                                                   #!!04235
!#    NARRATIVE : THIS PROCEDURE FORMATS AN EXTERNAL MESSAGE FROM A  #!!04236
!#       STANDARD EXTERNAL MESSAGE AND SENDS IT TO THE STATION.      #!!04237
!#                                                                   #!!04238
!#    INPUT PARAMETERS:                                              #!!04239
!#       SEM           : POINTER TO THE BIC ISO EXTERNAL MESSAGE     #!!04240
!#       DEST          : STATION TO WHICH THE MESSAGE IS TO BE SENT  #!!04241
                                                                       !04241K00
!#       DELAY         : TIME MESSAGE IS ALLOWED TO SIT IN A QUEUE   #!!04241K01
!#       ACK           : FLAG THAT INDICATES IF LOGICAL ACK REQUIRED #!!04241K02
!#       PSTM          : POINTER TO THE INTERNAL MESSAGE             #!!04241K03
                                                                       !04241K04
                                                                       !04242K00
                                                                       !04242K01
                                                                       !04242K02
!#                                                                   #!!04244
!#    OUTPUT PARAMETERS:                                             #!!04245
!#                                                                   #!!04246
!#####################################################################!!04247
                                                                       !04247K00
int proc pos^util^send^sem( sem, dest, delay, ack, pstm ) variable;    !04247K01
                                                                       !04247K02
                                                                       !04248K00
                                                                       !04248K01
int     .sem( sem^def );                                               !04249
int .ext dest;                                                         !04250
int      delay;                                                        !04251
int      ack;                                                          !04252
                                                                       !04252K00
int     .pstm( pstm^def );                                             !04252K01
    begin                                                              !04252K02
    int                                                                !04252K03
              error,                                                   !04252K04
             .msg[ 0:wlen( msg^def ) + msg^hsys ];                     !04252K05
                                                                       !04252K06
                                                                       !04253K00
                                                                       !04253K01
                                                                       !04253K02
                                                                       !04257
    string   .mtp := byteaddr( @msg + msg^hsys );                      !04258
                                                                       !04259
    if  not $param( sem ) or not $param( dest ) then                   !04260
        call programmatic^dump( 1500 );                                !04261
                                                                       !04262
                                                                       !04262K00
    if not ( error := pos^util^sem^collapse( sem, mtp, msg^length,     !04262K01
                                             gen^mac^l, pstm ) ) then  !04262K02
                                                                       !04262K03
                                                                       !04263K00
                                                                       !04263K01
        begin                                                          !04264
        msg^ack^req   :=  if $param( ack ) then ack else false;        !04265
        msg^tl2       :=  if $param( delay ) then $max( 0, delay )     !04266
            else qtime^l;                                              !04267
                                                                       !04268
                                                                       !04269K00
        if not util^send^sem( mtp, msg^length, dest,                   !04269K01
                              msg^tl2, msg^ack^req ) then              !04269K02
            return true;                                               !04269K03
        end;                                                           !04269K04
                                                                       !04269K05
    return error;                                                      !04269K06
                                                                       !04269K07
                                                                       !04270K00
                                                                       !04270K01
                                                                       !04270K02
    end;                                                               !04274
?section pos^util^updt^setl^ttls                                       !04275
?page "                                 - pos^util^updt^setl^ttls"     !04275K00
!#####################################################################!!04278
!#                                                                   #!!04279
!#                    POS^UTIL^UPDT^SETL^TTLS                        #!!04280
!#                                                                   #!!04281
!#    NARRATIVE : THIS PROCEDURE UPDATES THE POS SETTLEMENT TOTALS.  #!!04282
!#                                                                   #!!04283
!#    INPUT PARAMETERS:                                              #!!04284
!#       ILF          : ILF RECORD FOR TRANSACTION                   #!!04285
!#                                                                   #!!04286
!#    OUTPUT PARAMETERS:                                             #!!04287
!#                                                                   #!!04288
!#####################################################################!!04289
proc pos^util^updt^setl^ttls( ilf );                                   !04290
int    .ilf( ilf^def );                                                !04291
                                                                       !04292
    begin                                                              !04293
                                                                       !04293L00
                                                                       !04293L01
    fixed  amt1 := 0f,                                                 !04293L02
           amt2 := 0f;                                                 !04293L03
                                                                       !04293L04
                                                                       !04293L05
    int .ext ttls( ttl^def );                                          !04294
                                                                       !04295
    string  .post^dat[ 0:5 ];                                          !04296
                                                                       !04297
                                                                       !04297L00
                                                                       !04297L01
int subproc sub^convert^fixed^amt( pstm^amt, conv^rate );              !04297L02
fixed   .pstm^amt;                                                     !04297L03
string  .conv^rate;                                                    !04297L04
                                                                       !04297L05
    begin                                                              !04297L06
                                                                       !04297L07
    fixed  buy^rate := 0f;                                             !04297L08
                                                                       !04297L09
    int    buy^scale := 0;                                             !04297L0A
                                                                       !04297L0B
    if  pct.crncy^cde <> local^crncy^cde^g                             !04297L0C
                             for $len( pct.crncy^cde ) then            !04297L0D
        begin                                                          !04297L0E
        call ascii^integer( conv^rate[0], 1, buy^scale );              !04297L0F
        call ascii^fixed  ( conv^rate[1], 7, buy^rate );               !04297L0G
                                                                       !04297L0H
        case buy^scale of                                              !04297L0I
            begin                                                      !04297L0J
       !0!  pstm^amt := ( pstm^amt * buy^rate );                       !04297L0K
       !1!  pstm^amt := ( pstm^amt * buy^rate ) / 10f;                 !04297L0L
       !2!  pstm^amt := ( pstm^amt * buy^rate ) / 100f;                !04297L0M
       !3!  pstm^amt := ( pstm^amt * buy^rate ) / 1000f;               !04297L0N
       !4!  pstm^amt := ( pstm^amt * buy^rate ) / 10000f;              !04297L0O
       !5!  pstm^amt := ( pstm^amt * buy^rate ) / 100000f;             !04297L0P
       !6!  pstm^amt := ( pstm^amt * buy^rate ) / 1000000f;            !04297L0Q
       !7!  pstm^amt := ( pstm^amt * buy^rate ) / 10000000f;           !04297L0R
       !8!  pstm^amt := ( pstm^amt * buy^rate ) / 100000000f;          !04297L0S
       !9!  pstm^amt := ( pstm^amt * buy^rate ) / 1000000000f;         !04297L0T
       !?!  otherwise                                                  !04297L0U
                return false;                                          !04297L0V
            end;                                                       !04297L0W
        end;                                                           !04297L0X
                                                                       !04297L0Y
    return true;                                                       !04297L0Z
    end;                                                               !04297L10
                                                                       !04297e00
    !                                                                 !!04297e01
    ! Determine if the multiple currency add-on is being used.  If it !!04297e02
    ! is, skip this processing.                                       !!04297e03
    !                                                                 !!04297e04
    if pct.options.mult^crncy = "Y" then                               !04297e05
        begin                                                          !04297e06
        return;                                                        !04297e07
        end;                                                           !04297e08
                                                                       !04297e09
                                                                       !04297L11
                                                                       !04297L12
    if  not pct.setl.keep^ttls then                                    !04298
                                                                       !04299
        !  The interface does not keep settlement totals              !!04300
                                                                       !04301
        return;                                                        !04302
                                                                       !04303
                                                                       !04303M00
    if  ilf.pos.tran.resp > "009"  then                                !04303M01
                                                                       !04303M02
                                                                       !04304M00
                                                                       !04304M01
                                                                       !04305
        !  The transaction was not approved                           !!04306
                                                                       !04307
        return;                                                        !04308
                                                                       !04309
                                                                       !04309L00
    post^dat ':=' ilf.pos.post^dat for $len( ilf.pos.post^dat );       !04309L01
    if  not pct.setl.seven^days then                                   !04309L02
        while  hiswutil^weekend^or^holiday( post^dat,                  !04309L03
            pct.setl.holiday, $occurs( pct.setl.holiday ) ) do         !04309L04
                call julian^to^yymmdd( ( yymmdd^to^julian(             !04309L05
                    post^dat ) + 1d ), post^dat );                     !04309L06
                                                                       !04309L07
    if  post^dat = ttl^tbl.cur.dat[ 0 ] for                            !04309L08
                                                                       !04309L09
                                                                       !04310L00
                                                                       !04310L01
            $len( ilf.pos.post^dat ) then                              !04311
        begin                                                          !04312
        if  ilf.pos.tran.crd^ln = pct.ln for $len( ilf.pos.tran.crd^ln ) then
            @ttls := @ttl^tbl.cur.acq                                  !04315
        else                                                           !04316
        if  ilf.pos.term^ln = pct.ln for $len( ilf.pos.term^ln ) then  !04317
                                                                       !04317K00
            @ttls := @ttl^tbl.cur.iss                                  !04317K01
        else                                                           !04317K02
            return;                                                    !04317K03
                                                                       !04317K04
                                                                       !04318K00
                                                                       !04318K01
        end                                                            !04319
    else                                                               !04320
                                                                       !04320L00
    if  post^dat = ttl^tbl.prev.dat[ 0 ] for                           !04320L01
                                                                       !04320L02
                                                                       !04321L00
                                                                       !04321L01
            $len( ilf.pos.post^dat ) then                              !04322
        begin                                                          !04323
        if  ilf.pos.tran.crd^ln = pct.ln for $len( ilf.pos.tran.crd^ln ) then
            @ttls := @ttl^tbl.prev.acq                                 !04326
        else                                                           !04327
        if  ilf.pos.term^ln = pct.ln for $len( ilf.pos.term^ln ) then  !04328
                                                                       !04328K00
                                                                       !04328K01
            @ttls := @ttl^tbl.prev.iss                                 !04328K02
        else                                                           !04328K03
            return;                                                    !04328K04
                                                                       !04328K05
                                                                       !04329K00
                                                                       !04329K01
        end                                                            !04330
    else                                                               !04331
                                                                       !04331L00
    if  post^dat = ttl^tbl.nxt.dat[ 0 ] for                            !04331L01
                                                                       !04331L02
                                                                       !04332L00
                                                                       !04332L01
            $len( ilf.pos.post^dat ) then                              !04333
        begin                                                          !04334
        if  ilf.pos.tran.crd^ln = pct.ln for $len( ilf.pos.tran.crd^ln ) then
            @ttls := @ttl^tbl.nxt.acq                                  !04337
        else                                                           !04338
        if  ilf.pos.term^ln = pct.ln for $len( ilf.pos.term^ln ) then  !04339
                                                                       !04339K00
            @ttls := @ttl^tbl.nxt.iss                                  !04339K01
        else                                                           !04339K02
            return;                                                    !04339K03
                                                                       !04339K04
                                                                       !04340K00
                                                                       !04340K01
        end                                                            !04341
    else                                                               !04342
        return;                                                        !04343
                                                                       !04343L00
                                                                       !04343L01
    !  if using currency conversion, totals must be kept in!           !04343L02
    !  shared network currency.!                                       !04343L03
    if  ilf.pos.tran.mult^crncy.setl^crncy^cde <> blanks               !04343L04
              for $len( ilf.pos.tran.mult^crncy.setl^crncy^cde ) and   !04343L05
        ilf.pos.tran.mult^crncy.setl^crncy^cde <> zeroes               !04343L06
              for $len( ilf.pos.tran.mult^crncy.setl^crncy^cde ) and   !04343L07
        ilf.pos.tran.mult^crncy.setl^crncy^cde <> local^crncy^cde^g    !04343L08
              for $len( ilf.pos.tran.mult^crncy.setl^crncy^cde ) then  !04343L09
        begin                                                          !04343L0A
        amt1 := ilf.pos.tran.amt^1;                                    !04343L0B
        call sub^convert^fixed^amt( amt1,                              !04343L0C
                             ilf.pos.tran.mult^crncy.setl^conv^rate ); !04343L0D
        amt2 := ilf.pos.tran.amt^2;                                    !04343L0E
        call sub^convert^fixed^amt( amt2,                              !04343L0F
                             ilf.pos.tran.mult^crncy.setl^conv^rate ); !04343L0G
        end;                                                           !04343L0H
                                                                       !04343L0I
                                                                       !04344
    if  ilf.pos.typ = pstm^response^d or                               !04345
        ilf.pos.typ = pstm^force^post^d then                           !04346
        begin                                                          !04347
        if  pstm^pre^auth^d( ilf.pos ) then                            !04348
            ttls.num^auth := ttls.num^auth + 1d;                       !04349
                                                                       !04350
        if  pstm^pur^d( ilf.pos )              or                      !04351
            pstm^pre^auth^compl^d( ilf.pos )   or                      !04352
            pstm^mail^phone^d( ilf.pos )       or                      !04353
            pstm^cash^adv^d( ilf.pos )         or                      !04354
            pstm^cash^back^d( ilf.pos )        or                      !04355
            pstm^adj^mdse^ret^d( ilf.pos )     then                    !04356
            begin                                                      !04357
            ttls.num^db := ttls.num^db + 1d;                           !04358
                                                                       !04358L00
            if  amt1 > 0f then                                         !04358L01
                ttls.amt^db := ttls.amt^db + amt1                      !04358L02
            else                                                       !04358L03
                ttls.amt^db := ttls.amt^db + ilf.pos.tran.amt^1;       !04358L04
                                                                       !04358L05
                                                                       !04359L00
                                                                       !04359L01
            if  pstm^adj^mdse^ret^d( ilf.pos ) then                    !04360
                                                                       !04360L00
                                                                       !04360L01
                begin                                                  !04360L02
                if  amt2 > 0f then                                     !04360L03
                    ttls.amt^cr := ttls.amt^cr + amt2                  !04360L04
                else                                                   !04360L05
                    ttls.amt^cr := ttls.amt^cr + ilf.pos.tran.amt^2;   !04360L06
                end;                                                   !04360L07
                                                                       !04360L08
                                                                       !04361L00
                                                                       !04361L01
            end                                                        !04362
        else                                                           !04363
        if  pstm^mdse^ret^d( ilf.pos ) or                              !04364
            pstm^adj^pur^d( ilf.pos )     or                           !04365
                                                                       !04365M00
            pstm^adj^cash^back^d( ilf.pos ) or                         !04365M01
                                                                       !04365M02
            pstm^adj^cash^adv^d( ilf.pos )      then                   !04366
            begin                                                      !04367
            ttls.num^cr := ttls.num^cr + 1d;                           !04368
                                                                       !04368L00
            if  amt1 > 0f then                                         !04368L01
                ttls.amt^cr := ttls.amt^cr + amt1                      !04368L02
            else                                                       !04368L03
                ttls.amt^cr := ttls.amt^cr + ilf.pos.tran.amt^1;       !04368L04
                                                                       !04368L05
                                                                       !04369L00
                                                                       !04369L01
            if  pstm^adj^pur^d( ilf.pos ) or                           !04370
                                                                       !04370M00
                pstm^adj^cash^back^d( ilf.pos ) or                     !04370M01
                                                                       !04370M02
                pstm^adj^cash^adv^d( ilf.pos )    then                 !04371
                                                                       !04371L00
                begin                                                  !04371L01
                if  amt2 > 0f then                                     !04371L02
                    ttls.amt^db := ttls.amt^db + amt2                  !04371L03
                else                                                   !04371L04
                    ttls.amt^db := ttls.amt^db + ilf.pos.tran.amt^2;   !04371L05
                end;                                                   !04371L06
                                                                       !04371L07
                                                                       !04372L00
                                                                       !04372L01
            end                                                        !04373
        else                                                           !04374
        if  pstm^inquiry^d( ilf.pos ) then                             !04375
            ttls.num^inq := ttls.num^inq + 1d;                         !04376
        end                                                            !04377
    else                                                               !04378
    if  ilf.pos.typ = pstm^rvsl^advice^d or                            !04379
        ilf.pos.typ = pstm^rvsl^request^d then                         !04380
        begin                                                          !04381
        if  pstm^pur^d( ilf.pos )               or                     !04382
            pstm^pre^auth^compl^d( ilf.pos )    or                     !04383
            pstm^mail^phone^d( ilf.pos )        or                     !04384
            pstm^cash^adv^d( ilf.pos )          or                     !04385
            pstm^cash^back^d( ilf.pos )          or                    !04386
            pstm^adj^mdse^ret^d( ilf.pos )      then                   !04387
            begin                                                      !04388
            ttls.num^cr^rvsl := ttls.num^cr^rvsl + 1d;                 !04389
                                                                       !04389L00
            if  amt1 > 0f then                                         !04389L01
                ttls.amt^cr^rvsl := ttls.amt^cr^rvsl + amt1            !04389L02
            else                                                       !04389L03
                ttls.amt^cr^rvsl := ttls.amt^cr^rvsl +                 !04389L04
                                                  ilf.pos.tran.amt^1;  !04389L05
                                                                       !04389M00
            if  not pstm^cash^back^d( ilf.pos ) then                   !04389M01
                begin                                                  !04389M02
                if  amt2 > 0f then                                     !04389M03
                    ttls.amt^db := ttls.amt^db + amt2                  !04389M04
                else                                                   !04389M05
                    ttls.amt^db := ttls.amt^db + ilf.pos.tran.amt^2;   !04389M06
                end;                                                   !04389M07
                                                                       !04389M08
                                                                       !04389M09
                                                                       !04389M0A
                                                                       !04389M0B
                                                                       !04389L0A
                                                                       !04390L00
                                                                       !04390L01
                                                                       !04390L02
            end                                                        !04392
        else                                                           !04393
        if  pstm^mdse^ret^d( ilf.pos )          or                     !04394
            pstm^adj^pur^d( ilf.pos )           or                     !04395
                                                                       !04395M00
            pstm^adj^cash^back^d( ilf.pos )     or                     !04395M01
                                                                       !04395M02
            pstm^adj^cash^adv^d( ilf.pos )      then                   !04396
            begin                                                      !04397
            ttls.num^db^rvsl := ttls.num^db^rvsl + 1d;                 !04398
                                                                       !04398L00
            if  amt1 > 0f then                                         !04398L01
                ttls.amt^db^rvsl := ttls.amt^db^rvsl + amt1            !04398L02
            else                                                       !04398L03
                ttls.amt^db^rvsl := ttls.amt^db^rvsl +                 !04398L04
                                                  ilf.pos.tran.amt^1;  !04398L05
            if  amt2 > 0f then                                         !04398L06
                ttls.amt^cr := ttls.amt^cr + amt2                      !04398L07
            else                                                       !04398L08
                ttls.amt^cr := ttls.amt^cr + ilf.pos.tran.amt^2;       !04398L09
                                                                       !04398L0A
                                                                       !04399L00
                                                                       !04399L01
                                                                       !04399L02
            end;                                                       !04401
        end;                                                           !04402
                                                                       !04403
    ttls.amt^net^setl := ( ttls.amt^cr + ttls.amt^cr^rvsl ) -          !04404
         ( ttls.amt^db + ttls.amt^db^rvsl );                           !04405
                                                                       !04406
                                                                       !04407M00
                                                                       !04407M01
                                                                       !04407M02
                                                                       !04411
    end;                                                               !04412
                                                                       !04412K00
?section pos^util^xlate^mac^generate                                   !04412K01
?page "                              - pos^util^xlate^mac^generate"    !04412K02
!#####################################################################!!04412K03
!#                                                                   #!!04412K04
!#                    POS^UTIL^XLATE^MAC^GENERATE                    #!!04412K05
!#                                                                   #!!04412K06
!#    NARRATIVE : THIS PROCEDURE TRANSLATES THE PIN AND GENERATES    #!!04412K07
!#                A MAC VALUE WITH ONLY ONE CALL TO THE SECURITY     #!!04412K08
!#                DEVICE.                                            #!!04412K09
!#                                                                   #!!04412K0A
!#    INPUT PARAMETERS:                                              #!!04412K0B
!#       MAC^BUF      : BUFFER CONTAINING DATA TO BE MACED           #!!04412K0C
!#       MAC^LGTH     : LENGTH OF DATA TO BE MACED                   #!!04412K0D
!#       MAC^PIN^OFST : OFFSET OF PIN IN THE MAC BUFFER              #!!04412K0E
!#       PSTM         : POINTER TO THE INTERNAL MESSAGE              #!!04412K0F
!#                                                                   #!!04412K0G
!#    OUTPUT PARAMETERS:                                             #!!04412K0H
!#       MAC^VALUE    : MAC VALUE THAT WAS GENERATED                 #!!04412K0I
!#       PIN^VALUE    : PIN VALUE TRANSLATED AT THE DEVICE           #!!04412K0J
!#                                                                   #!!04412K0K
!#####################################################################!!04412K0L
int proc pos^util^xlate^mac^generate( mac^buf, mac^lgth, mac^value,    !04412K0M
                                      mac^pin^ofst, pin^value, pstm ); !04412K0N
string      .mac^buf;                                                  !04412K0O
int         .mac^lgth;                                                 !04412K0P
string      .mac^value;                                                !04412K0Q
int          mac^pin^ofst;                                             !04412K0R
string      .pin^value;                                                !04412K0S
int         .pstm( pstm^def );                                         !04412K0T
    begin                                                              !04412K0U
    wlform( trace, "T - pos^util^xlate^mac^generate" )                 !04412K0V
                                                                       !04412K0W
    struct       int^pan; begin string byte[ 0:15 ]; end;              !04412K0X
                                                                       !04412K0Y
    int                                                                !04412K0Z
                                                                       !04412p00
                mac^key^lgth := 16,                                    !04412p01

--@===================================================================
--@  Temp fix from Kirk            08/26/08  KPP                     =

                mac^typ := 7,

--@  Temp fix from Kirk            08/26/08  KPP                     =
--@===================================================================
                                                                       !04412400
                pin^key^lgth := 16,                                    !04412401
                                                                       !04412402
                pan^lgth  := max^pan^lgth^l,                           !04412K10
                reject,                                                !04412K11
                sanity^flag;                                           !04412K12
    string                                                             !04412K13
               .check[ 0:3 ],                                          !04412K14
               .in^chk^digits[ 0:3 ],                                  !04412K15
               .mac^chk^digits[ 0:3 ],                                 !04412K16
               .out^chk^digits[ 0:3 ],                                 !04412K17
               .pan[ 0:max^pan^lgth^l ];                               !04412K18
                                                                       !04412K19
    if trace^g.<pos^l> then                                            !04412K1A
        call logmessage^( 1157,, @trace, net.myname,                   !04412K1B
                         0, @pos^prod^g );                             !04412K1C
                                                                       !04412K1D
    call hiswutil^extract^track2^info( pstm.tran.track2,               !04412K1E
                  $len( pstm.tran.track2 ), pan, pan^lgth );           !04412K1F
                                                                       !04412K1G
    int^pan.byte ':=' zeroes for $len( int^pan );                      !04412K1H
                                                                       !04412K1I
    if pstm.ansi^ofst < 0 then                                         !04412K1J
        int^pan.byte[ $abs( pstm.ansi^ofst ) ] ':='                    !04412K1K
            pan[ 0 ] for ( 12 + pstm.ansi^ofst )                       !04412K1L
    else                                                               !04412K1M
        int^pan.byte[ 12 - $min( 12, pan^lgth ) ] ':='                 !04412K1N
            pan[ pstm.ansi^ofst ] for $min( 12, pan^lgth );            !04412K1O
                                                                       !04412K1P
    !!                                                                 !04412K1Q
    !increment threshold counter. if limit has been!                   !04412K1R
    !reached set global flag so keys will be exchanged.!               !04412K1S
    !!                                                                 !04412K1T
    if pct.mac.mac^key^tran^lmt > 0d then                              !04412K1U
        begin                                                          !04412K1V
        if pct.options.num^keys = "1" then                             !04412K1W
            begin                                                      !04412K1X
            incr^count( pct.mac.in^key^tran^cnt );                     !04412K1Y
            if pct.mac.in^key^tran^cnt > pct.mac.mac^key^tran^lmt then !04412K1Z
                begin                                                  !04412K20
                call setbit( exchange^keys^g, mac^both^keys^l );       !04412K21
                set( pct.mac.in^err^cnt,           0  );               !04412K22
                set( pct.mac.in^cons^err^cnt,      0  );               !04412K23
                set( pct.mac.in^kmac^sync^err^cnt, 0  );               !04412K24
                set( pct.mac.in^key^tran^cnt,      0d );               !04412K25
                call util^timer^find( time^key^exchange^l,             !04412K26
                                      sub^in^mac^l,,, true );          !04412K27
                end;                                                   !04412K28
            end                                                        !04412K29
        else                                                           !04412K2A
            begin                                                      !04412K2B
            incr^count( pct.mac.out^key^tran^cnt );                    !04412K2C
            if pct.mac.out^key^tran^cnt >                              !04412K2D
               pct.mac.mac^key^tran^lmt then                           !04412K2E
                begin                                                  !04412K2F
                call setbit( exchange^keys^g, mac^out^key^l );         !04412K2G
                set( pct.mac.out^err^cnt,           0  );              !04412K2H
                set( pct.mac.out^cons^err^cnt,      0  );              !04412K2I
                set( pct.mac.out^kmac^sync^err^cnt, 0  );              !04412K2J
                set( pct.mac.out^key^tran^cnt,      0d );              !04412K2K
                call util^timer^find( time^key^exchange^l,             !04412K2L
                                      sub^out^mac^l,,, true );         !04412K2M
                end;                                                   !04412K2N
            end;                                                       !04412K2O
        end;                                                           !04412K2P
                                                                       !04412K2Q
                                                                       !04412K2R
    if pct.pin.pin^key^tran^lmt > 0d then                              !04412K2S
        begin                                                          !04412K2T
        if pct.options.num^keys = "1" then                             !04412K2U
            begin                                                      !04412K2V
            incr^count( pct.pin.in^key^tran^cnt );                     !04412K2W
            if pct.pin.in^key^tran^cnt > pct.pin.pin^key^tran^lmt then !04412K2X
                begin                                                  !04412K2Y
                call setbit( exchange^keys^g, pin^both^keys^l );       !04412K2Z
                set( pct.mac.in^err^cnt,           0  );               !04412K30
                set( pct.mac.in^cons^err^cnt,      0  );               !04412K31
                set( pct.mac.in^kmac^sync^err^cnt, 0  );               !04412K32
                set( pct.mac.in^key^tran^cnt,      0d );               !04412K33
                call util^timer^find( time^key^exchange^l,             !04412K34
                                      sub^in^mac^l,,, true );          !04412K35
                end;                                                   !04412K36
            end                                                        !04412K37
        else                                                           !04412K38
            begin                                                      !04412K39
            incr^count( pct.pin.out^key^tran^cnt );                    !04412K3A
            if pct.pin.out^key^tran^cnt >                              !04412K3B
               pct.pin.pin^key^tran^lmt then                           !04412K3C
                begin                                                  !04412K3D
                call setbit( exchange^keys^g, pin^out^key^l );         !04412K3E
                set( pct.mac.out^err^cnt,           0  );              !04412K3F
                set( pct.mac.out^cons^err^cnt,      0  );              !04412K3G
                set( pct.mac.out^kmac^sync^err^cnt, 0  );              !04412K3H
                set( pct.mac.out^key^tran^cnt,      0d );              !04412K3I
                call util^timer^find( time^key^exchange^l,             !04412K3J
                                      sub^out^mac^l,,, true );         !04412K3K
                end;                                                   !04412K3L
            end;                                                       !04412K3M
        end;                                                           !04412K3N
                                                                       !04412p03
    mac^key^lgth :=  pct.options.mac^key^lgth;                         !04412p04
                                                                       !04412403
    pin^key^lgth :=  pct.options.key^lgth;                             !04412404
                                                                       !04412405
    if  pct.mac.mac^data^typ = "1" then                                !04412K3P
        call translate( mac^buf, mac^lgth, ascii^to^ebcdic^l );        !04412K3Q
                                                                       !04412K3R
    reject := hiswsec^pin^xlate^mac^generate( sdcb, pstm.pin^frmt,     !04412K3S
                  pct.pin.out^blk, pstm.pin^key,                       !04412K3T
                  pct.pin.out^key[ pct.pin.out^curr^index ].key^value, !04412K3U
                  pstm.pin, int^pan.byte, pstm.pinpad^char,            !04412K3V
                  pct.pin.out^pad, mac^pin^ofst,                       !04412K3W
                  pct.mac.mac^data^typ, mac^pin^ofst,                  !04412K3X
                  pct.mac.out^key[ pct.mac.out^curr^index ].key^value, !04412K3Y
                  mac^buf, mac^lgth, mac^resp^lgth^l, sanity^flag,     !04412K3Z
                  pin^value, mac^value, mac^chk^digits, in^chk^digits, !04412K40
                                                                       !04412p06
                                                                       !04412p07
                  out^chk^digits, pstm.user^key,  !pinkey idx!,        !04412p08
                                                                       !04412406
                                                                       !04412407
                  !mackey idx!, !mackey dir!, mac^key^lgth,            !04412408

--@===================================================================
--@  Temp fix from Kirk            08/26/08  KPP                     =

                                                                       !04412900
                  pin^key^lgth, pseudo^cbc^mac^typ^g );                !04412901
                                                                       !04412902
--  ****          pin^key^lgth, mac^typ );   ** Replaced 2011-07-19 **

--@  Temp fix from Kirk            08/26/08  KPP                     =
--@===================================================================
                                                                       !0441240A
    if reject      and                                                 !04412K43
       sanity^flag then                                                !04412K44
        set( reject, "S" );                                            !04412K45
                                                                       !04412K46
    return reject;                                                     !04412K47
                                                                       !04412K48
    end;                                                               !04412K49
                                                                       !04412K4A
?section pstm^0200^deny                                                !04413
?page "                                        - pstm^0200^deny"       !04414
!#####################################################################!!04415
!#                                                                   #!!04416
!#                          PSTM^0200^DENY                           #!!04417
!#                                                                   #!!04418
!#    NARRATIVE : THIS PROCEDURE FORMATS AND RETURNS A RESPONSE      #!!04419
!#       DENIAL TO THE LOCAL BASE24-pos AUTHORIZATION PROCESS.       #!!04420
!#                                                                   #!!04421
!#    INPUT PARAMETERS:                                              #!!04422
!#       PRIKEY        : TRANSACTION PRIMARY KEY                     #!!04423
!#       PSTM          : BASE24 INTERNAL POS MESSAGE                 #!!04424
!#       DEST          : SYMBOLIC DESTINATION                        #!!04425
!#       RESP^CDE      : RESPONSE CODE                               #!!04426
!#       SUB           : SUBSTATE                                    #!!04427
!#                                                                   #!!04428
!#    OUTPUT PARAMETERS:                                             #!!04429
!#                                                                   #!!04430
!#####################################################################!!04431
                                                                       !04431M00
proc pstm^0200^deny( prikey, pstm, dest, resp^cde, sub, sem ) variable;
                                                                       !04431M03
                                                                       !04432M00
                                                                       !04432M01
int    .prikey( prikey^def );                                          !04433
int    .pstm( pstm^def );                                              !04434
int    .dest;                                                          !04435
int     resp^cde;                                                      !04436
int     sub;                                                           !04437
                                                                       !04437M00
int    .sem( sem^def );                                                !04437M01
                                                                       !04437M02
    begin                                                              !04438
    wlform( trace, "T - pstm^0200^deny ( Response code ###)" )         !04439
                                                                       !04440
    if  trace^g.<pos^l> then                                           !04441
        call logmessage^( 1160,, @trace, net.myname,                   !04442
            0, @pos^prod^g, resp^cde );                                !04443
                                                                       !04444
    if  pstm.typ = pstm^request^d  then                                !04445
        pstm.typ ':=' pstm^response^d                                  !04446
    else                                                               !04447
    if  pstm.typ = pstm^rvsl^request^d then                            !04448
        pstm.typ ':=' pstm^rvsl^response^d;                            !04449
                                                                       !04450
    if  integer^ascii^( pstm.tran.resp^cde, resp^cde ) then            !04451
        call pos^util^send^pstm( pstm, dest );                         !04452
                                                                       !04453
    movd ( pstm.rte.auth^ind, "9" );                                   !04454
                                                                       !04455
    if  $param( sub ) then                                             !04456
        !                                                             !!04457
        ! Add a record to the ILF                                     !!04458
        !                                                             !!04459
                                                                       !04459M00
        if  $param( sem ) then                                         !04459M01
            call util^ilf^add( pct.setl.bic^dat, prikey,               !04459M02
                               $len( prikey^def ), pos^l, sub, dest,   !04459M03
                               pstm, sem )                             !04459M04
        else                                                           !04459M05
            call util^ilf^add( pct.setl.bic^dat, prikey,               !04459M06
                               $len( prikey^def ), pos^l, sub, dest,   !04459M07
                               pstm );                                 !04459M08
                                                                       !04459M09
                                                                       !04462M00
                                                                       !04462M01
    end;                                                               !04463
?section pstm^0200^request                                             !04464
?page "                                        - pstm^0200^request"    !04465
!#####################################################################!!04466
!#                                                                   #!!04467
!#                         PSTM^0200^REQUEST                         #!!04468
!#                                                                   #!!04469
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS A REQUEST MESSAGE #!!04470
!#       TO THE CO-NETWORK FROM BASE24-pos.                          #!!04471
!#                                                                   #!!04472
!#    INPUT PARAMETERS :                                             #!!04473
!#       MSG           : WORD POINTER TO MESSAGE                     #!!04474
!#       PSTM          : TEXT POINTER TO INTERNAL MESSAGE            #!!04475
!#       SEM           : TEXT POINTER TO EXTERNAL MESSAGE            #!!04476
!#                                                                   #!!04477
!#    OUTPUT PARAMETERS:                                             #!!04478
!#                                                                   #!!04479
!#####################################################################!!04480
proc pstm^0200^request( msg, pstm, sem );                              !04481
int  .msg;                                                             !04482
int  .pstm( pstm^def );                                                !04483
int  .sem(  sem^def  );                                                !04484
                                                                       !04484K00
    begin                                                              !04484K01
    wlform( ilf^err, "Transaction denied due to a previous error" ','  !04484K02
            " on the ILF - Correct the problem and warmboot " )        !04484K03
    wlform( saf^err, "Transaction denied due to a previous error" ','  !04484K04
            " on the SAF - Correct the problem and warmboot " )        !04484K05
                                                                       !04484K06
                                                                       !04484K07
                                                                       !04485K00
                                                                       !04485K01
    struct   .susp( susp^bici^def );                                   !04486
                                                                       !04487
                                                                       !04487K00
    int                                                                !04487K01
              error,                                                   !04487K02
              resp^cde,                                                !04487K03
              sta^x;                                                   !04487K04
                                                                       !04487S00
    int       fatal_flg := true;                                       !04487S01
    int       pstm_lgth;                                               !04487S02
    int       response;                                                !04487S03
    int       tkn_lgth := 0;                                           !04487S04
    int      .user_data := @pstm;                                      !04487S05
                                                                       !04487S06
                                                                       !04487K05
    string                                                             !04487K06
              err^flg;                                                 !04487K07
                                                                       !04487K08
                                                                       !04488K00
                                                                       !04488K01
                                                                       !04488K02
                                                                       !04491
    if  msg^poss^dup^( msg ) or pstm.orig^pro^name = net.myname for    !04492
        $len( pstm.orig^pro^name ) then                                !04493
        !                                                             !!04494
        ! drop request                                                !!04495
        !                                                             !!04496
        return;                                                        !04497
                                                                       !04498
    ! Initialize required response fields                             !!04499
                                                                       !04500
    movd ( pstm.responder,               switch^interface^origin^d );  !04501
    move ( pstm.tran.dest,               pct.swi^typ               );  !04502
    move ( pstm.tran.crd^ln,             pct.ln                    );  !04503
    move ( pstm.tran.crd^fiid,           pct.fiid                  );  !04504
    move ( pstm.tran.rfrl^phone,         pos^pct.phone^num         );  !04505
    move ( pstm.iss^ichg^setl^dat,       pct.setl.bic^dat          );  !04506
                                                                       !04506$00
                                                                       !04506$01
                                                                       !04506$02
                                                                       !04507
    ! Initialize required Suspense fields                             !!04508
                                                                       !04509
    init ( susp,       "  ", wlen( susp^bici^def ) );                  !04510
                                                                       !04511K00
                                                                       !04511K01
                                                                       !04511g00
    movl ( susp.msg,        pstm.typ,   msg^length );                  !04511g01
                                                                       !04511g02
    set  ( susp.msg^lgth,               msg^length );                  !04511K03
                                                                       !04511K04
                                                                       !04513
    if  ( pstm.ast^rtn^pro^name = blanks for                           !04514
        $len( pstm.ast^rtn^pro^name ) ) or                             !04515
        ( pstm.ast^rtn^pro^name = zeroes for                           !04516
        $len( pstm.ast^rtn^pro^name ) ) then                           !04517
        movl ( susp.orig^net^pro, pstm.orig^pro^name,                  !04518
            $len( pstm.orig^pro^name ) )                               !04519
    else                                                               !04520
        movl ( susp.orig^net^pro, pstm.ast^rtn^pro^name,               !04521
            $len( pstm.ast^rtn^pro^name ) );                           !04522
                                                                       !04523
    call pstm^frmt^b24^to^prikey( pstm, susp.prikey.tran^tim );        !04524
                                                                       !04525
                                                                       !04525S00
    if base24^rel^g >= 6 then                                          !04525S01
        begin                                                          !04525S02
        response := hiswpstm_txn_alwd_iss( pstm,                       !04525S03
                                           pos^pct.iss^txn^prfl,       !04525S04
                                           msg^sym^source,             !04525S05
                                           ipcfemt_seg_id_g,           !04525S06
                                           pstm.num^services,          !04525S07
                                           ipcf_emt_rec_g,             !04525S08
                                           fatal_flg,                  !04525S09
                                           ipcfemt_name_g,             !04525S0A
                                           tkn_lgth );                 !04525S0B
        if response = sys_frmt_err_l then                              !04525S0C
            begin                                                      !04525S0D
            !                                                        ! !04525S0E
            ! System error                                           ! !04525S0F
            !                                                        ! !04525S0G
            call pstm^0200^deny( susp.prikey,                          !04525S0H
                                 pstm,                                 !04525S0I
                                 msg^sym^source,                       !04525S0J
                                 pstm^resp^frmt^err^l,                 !04525S0K
                                 sub^frmt^err^l );                     !04525S0L
            return;                                                    !04525S0M
            end                                                        !04525S0N
        else                                                           !04525S0O
            begin                                                      !04525S0P
            if response = txn_cde_not_sppt_l then                      !04525S0Q
                begin                                                  !04525S0R
                !                                                    ! !04525S0S
                ! Trans not allowed to switch according to IPCFEMT   ! !04525S0T
                !                                                    ! !04525S0U
                call pstm^0200^deny( susp.prikey,                      !04525S0V
                                     pstm,                             !04525S0W
                                     msg^sym^source,                   !04525S0X
                                     pstm^resp^inv^tran^l,             !04525S0Y
                                     sub^fail^pre^auth^l );            !04525S0Z
                return;                                                !04525S10
                end;                                                   !04525S11
            end;                                                       !04525S12
                                                                       !04525S13
        pstm_lgth := $offset( pstm.srvcs ) +                           !04525S14
                     ( pstm.num^services * $len( pstm.srvcs ) );       !04525S15
                                                                       !04525S16
                                                                       !04525Y00
        if pstm.data^flag <> "0" then                                  !04525Y01
                                                                       !04525Y02
            begin                                                      !04525S18
            pstm_lgth := pstm_lgth + 2 +                               !04525S19
                         user_data[ wrds( pstm_lgth ) ];               !04525S1A
            end;                                                       !04525S1B
                                                                       !04525S1C
        susp.msg^lgth := pstm_lgth + tkn_lgth;                         !04525S1D
                                                                       !04525S1E
        end ! of base24^rel^g >= 6                                   ! !04525S1F
    else                                                               !04525S1G
                                                                       !04525S1H
                                                                       !04526G00
                                                                       !04526G01
                                                                       !04526G02
    if  not hiswutil^pos^trans^allowed( pstm.tran.tran^cde,            !04550
                pos^pct.trans^allowed ) then                           !04551
        begin                                                          !04552
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04553
                                                                       !04553O00
            pstm^resp^inv^tran^l, sub^fail^pre^auth^l,                 !04553O01
                                                                       !04553O02
                                                                       !04554O00
                                                                       !04554O01
            pstm^stat^line^down^l );                                   !04555
        return;                                                        !04556
        end;                                                           !04557
                                                                       !04558
    if  not hiswutil^pos^service^allowed( pstm.rte.srv,                !04559
           pos^pct.allowed^srv, pos^pct.num^srv ) then                 !04560
        begin                                                          !04561
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04562
            pstm^resp^inv^service^l, sub^fail^pre^auth^l,              !04563
            pstm^stat^line^down^l );                                   !04564
            return;                                                    !04565
        end;                                                           !04566
                                                                       !04567
                                                                       !04567K00
    if pct.ilf.ferror and pct.ilf.ferror <> feeof then                 !04567K01
        begin                                                          !04567K02
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04567K03
            pstm^resp^referral^l, sub^sys^err^l,                       !04567K04
            pstm^stat^line^down^l );                                   !04567K05
        call logmessage^( 1162,, @ilf^err, net.myname,                 !04567K06
                          2, @pos^prod^g );                            !04567K07
        return;                                                        !04567K08
        end;                                                           !04567K09
                                                                       !04567K0A
    if pct.saf.ferror and pct.saf.ferror <> feeof then                 !04567K0B
                                                                       !04567K0C
                                                                       !04568K00
                                                                       !04568K01
                                                                       !04568K02
        begin                                                          !04570
                                                                       !04570~00
        if pct.options.acq^stand^in and                                !04570~01
           pct.saf.ferror = 45 then                                    !04570~02
            begin                                                      !04570~03
            !                                                         !!04570~04
            ! for SAF error and acquirer stand-in, send a denial      !!04570~05
            ! to prevent a stand-in which can't be written to SAF     !!04570~06
            !                                                         !!04570~07
            call pstm^0200^deny( susp.prikey,                          !04570~08
                                 pstm,                                 !04570~09
                                 msg^sym^source,                       !04570~0A
                                 pstm^resp^unable^to^auth^l,           !04570~0B
                                 sub^sys^err^l );                      !04570~0C
            end                                                        !04570~0D
        else                                                           !04570~0E
            begin                                                      !04570~0F
            call pstm^0200^route( susp.prikey, pstm, msg^sym^source,   !04570~0G
                                  pstm^resp^referral^l, sub^sys^err^l, !04570~0H
                                  pstm^stat^line^down^l );             !04570~0I
            end;                                                       !04570~0J
                                                                       !04570~0K
                                                                       !04571~00
                                                                       !04571~01
                                                                       !04571~02
                                                                       !04573K00
        call logmessage^( 1163,, @saf^err, net.myname,                 !04573K01
                          2, @pos^prod^g );                            !04573K02
                                                                       !04573K03
        return;                                                        !04574
        end;                                                           !04575
                                                                       !04576
                                                                       !04576K00
    if not util^station^avail( sta^x ) or                              !04576K01
       not pct.status.ctvr^ack         then                            !04576K02
        begin                                                          !04576K03
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04576K04
            pstm^resp^referral^l, sub^down^at^rqst^l,                  !04576K05
            pstm^stat^line^down^l );                                   !04576K06
        return;                                                        !04576K07
        end;                                                           !04576K08
                                                                       !04576K09
    if not pct.options.acquirer    or                                  !04576K0A
       not pct.options.pos.present then                                !04576K0B
        begin                                                          !04576K0C
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04576K0D
                              pstm^resp^referral^l,                    !04576K0E
                              sub^fail^pre^auth^l,                     !04576K0F
                              pstm^stat^line^down^l );                 !04576K0G
        return;                                                        !04576K0H
        end;                                                           !04576K0I
                                                                       !04576K0J
                                                                       !04576K0K
                                                                       !04576K0L
    if  resp^cde := pstm^frmt^b24^to^pos^0200( pstm, sem ) then        !04577
                                                                       !04578K00
                                                                       !04578K01
                                                                       !04578K02
        begin                                                          !04585
                                                                       !04585K00
        call pstm^0200^deny( susp.prikey, pstm, msg^sym^source,        !04585K01
                             resp^cde, sub^frmt^err^l );               !04585K02
                                                                       !04585K03
                                                                       !04586K00
                                                                       !04586K01
                                                                       !04586K02
        return;                                                        !04589
        end;                                                           !04590
                                                                       !04591
                                                                       !04591K00
    if not util^suspend^tran^add( susp, $len( susp^bici^def ),         !04591K01
                                                                       !04591K02
                                                                       !04594K00
                                                                       !04594K01
                                                                       !04594K02
            pos^pct.timers.outbound, time^outbound^rqst^l,             !04605
            trace^num^g, sta^x, pos^l )   then                         !04606
        call pstm^0200^route( susp.prikey, pstm, msg^sym^source,       !04607
            pstm^resp^referral^l, sub^down^at^rqst^l,                  !04608
            pstm^stat^line^down^l )                                    !04609
    else                                                               !04610
                                                                       !04610K00
        if ( error := pos^util^send^sem( sem, pct.sta[ sta^x ].nam,    !04610K01
            $int( pos^pct.timers.outbound ),, pstm ) ) and             !04610K02
            error <> true then                                         !04610K03
            !!                                                         !04610K04
            !there was a mac generation failure!                       !04610K05
            !!                                                         !04610K06
            begin                                                      !04610K07
            call util^suspend^tran^delete( susp,                       !04610K08
                                           $len( susp^bici^def ),      !04610K09
                                           msg, time^outbound^rqst^l,  !04610K0A
                                           trace^num^g );              !04610K0B
                                                                       !04610K0C
            if error = "S" then                                        !04610K0D
                movd( err^flg, "S" )                                   !04610K0E
            else                                                       !04610K0F
                movd( err^flg, "M" );                                  !04610K0G
                                                                       !04610K0H
                                                                       !04610U00
            if base24^rel^g >= 5 then                                  !04610U01
                                                                       !04610U02
                call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,      !04610K0J
                                           pstm^lgth^d( pstm ),        !04610K0K
                                           false,, pstm.data^flag,     !04610K0L
                                           err^flg );                  !04610K0M
                                                                       !04610K0N
            call pstm^0200^deny( susp.prikey, pstm, msg^sym^source,    !04610K0O
                                 pstm^resp^unable^to^auth^l,           !04610K0P
                                 sub^fail^pre^auth^l );                !04610K0Q
            end;                                                       !04610K0R
                                                                       !04610K0S
                                                                       !04611K00
                                                                       !04611K01
                                                                       !04611K02
                                                                       !04613
    end;                                                               !04614
?section pstm^0200^route                                               !04615
?page "                                        - pstm^0200^route"      !04616
!#####################################################################!!04617
!#                                                                   #!!04618
!#                          PSTM^0200^ROUTE                          #!!04619
!#                                                                   #!!04620
!#    NARRATIVE : THIS PROCEDURE RETURNS A TRANSACTION TO THE        #!!04621
!#       ORIGINATOR SO THAT THE ORIGINATOR CAN AUTHORIZE THE         #!!04622
!#       TRANSACTION OFFLINE.                                        #!!04623
!#                                                                   #!!04624
!#    INPUT PARAMETERS :                                             #!!04625
!#       PRIKEY        : TRANSACTION PRIMARY KEY                     #!!04626
!#       PSTM          : TEXT POINTER TO MESSAGE                     #!!04627
!#       DEST          : SYMBOLIC DESTINATION                        #!!04628
!#       RESP^CDE      : RESPONSE CODE                               #!!04629
!#       SUB           : ILF SUBSTATE                                #!!04630
                                                                       !04630K00
!#       STAT          : ROUTING STATUS                              #!!04630K01
                                                                       !04630K02
!#                                                                   #!!04631
!#    OUTPUT PARAMETERS:                                             #!!04632
!#                                                                   #!!04633
!#####################################################################!!04634
                                                                       !04634M00
proc pstm^0200^route( prikey, pstm, dest, resp^cde, sub, stat, sem )   !04634M01
                      extensible;                                      !04634M02
                                                                       !04634M03
                                                                       !04635M00
                                                                       !04635M01
int    .prikey( prikey^def );                                          !04636
int    .pstm( pstm^def );                                              !04637
int    .dest;                                                          !04638
int     resp^cde;                                                      !04639
int     sub;                                                           !04640
int     stat;                                                          !04641
                                                                       !04641M00
int    .sem( sem^def );                                                !04641M01
                                                                       !04641M02
    begin                                                              !04642
    wlform( trace,                                                     !04643
    "T - pstm^0200^route ( Response code: #, Substate: #, Status: # ) ")
                                                                       !04646
    if  trace^g.<pos^l> then                                           !04647
        call logmessage^( 1165,, @trace, net.myname,                   !04648
            0, @pos^prod^g, resp^cde, sub, stat );                     !04649
                                                                       !04650
                                                                       !04651J00
                                                                       !04651J01
                                                                       !04651J02
    if  sub = sub^timeout^l then                                       !04660
        begin                                                          !04661
        if  pos^pct.timeout^flg = "0" then                             !04662
            begin                                                      !04663
                                                                       !04663M00
            if  $param( sem ) then                                     !04663M01
                call pstm^0200^deny( prikey, pstm, dest, resp^cde,     !04663M02
                                     sub, sem )                        !04663M03
            else                                                       !04663M04
                call pstm^0200^deny( prikey, pstm, dest, resp^cde,     !04663M05
                                     sub );                            !04663M06
                                                                       !04663M07
                                                                       !04664M00
                                                                       !04664M01
            return;                                                    !04665
            end;                                                       !04666
        end;                                                           !04667
                                                                       !04668
                                                                       !04668^00
                                                                       !04668600
                                                                       !04668601
                                                                       !04668602
                                                                       !04668^0G
    if  pstm.router2^name <> blanks for $len( pstm.router2^name ) and  !04669
        pstm.router2^name <> zeroes for $len( pstm.router2^name ) then !04670
        begin                                                          !04671
                                                                       !04671J00
        if  ( pstm.auth^ind2 = "P" or pstm.auth^ind2 = "p" ) and       !04671J01
            pct.options.acq^stand^in                         and       !04671J02
            pstm.rte.pri = "AUTHH"                           then      !04671J03
            begin                                                      !04671J04
            movd( pstm.compl^req, offline^compl^d );                   !04671J05
            if  not integer^ascii^( pstm.rte^stat, stat ) then         !04671J06
                movd( pstm.rte^stat, pstm^stat^line^down^d );          !04671J07
            end                                                        !04671J08
        else                                                           !04671J09
                                                                       !04671J0A
        if  ( pstm.auth^ind2 = "P" or pstm.auth^ind2 = "p" ) and       !04672
            pstm.rte.alt1 <> blanks for $len( pstm.rte.alt1 ) and      !04673
            pstm.rte.alt1 <> zeroes for $len( pstm.rte.alt1 ) then     !04674
            movd( pstm.auth^ind2, "1" )                                !04675
                                                                       !04675Z00
        else                                                           !04675Z01
        if  pstm.auth^ind2 = "F" and                                   !04675Z02
            pstm.rte.alt1 <> blanks for $len( pstm.rte.alt1 ) and      !04675Z03
            pstm.rte.alt1 <> zeroes for $len( pstm.rte.alt1 ) and      !04675Z04
            pstm.rte.alt1 <> "AUTH"                           and      !04675Z05
            pstm.rte.alt1 <> "NEG"                            then     !04675Z06
            begin                                                      !04675Z07
            !                                                         !!04675Z08
            ! The authorizers were determined using SPROUTE.  Set ind !!04675Z09
            ! to first alternate authorizer from SPROUTE.             !!04675Z0A
            !                                                         !!04675Z0B
            movd( pstm.auth^ind2, "f" );                               !04675Z0C
            mov^( dest, pstm.rte.alt1 );                               !04675Z0D
            end                                                        !04675Z0E
                                                                       !04675Z0F
        else                                                           !04676
                                                                       !04676J00
        if  ( pstm.auth^ind2 = "1" )   and                             !04676J01
            pct.options.acq^stand^in   and                             !04676J02
            pstm.rte.alt1 = "AUTHH"    then                            !04676J03
            begin                                                      !04676J04
            movd( pstm.compl^req, offline^compl^d );                   !04676J05
            if  not integer^ascii^( pstm.rte^stat, stat ) then         !04676J06
                movd( pstm.rte^stat, pstm^stat^line^down^d );          !04676J07
            end                                                        !04676J08
        else                                                           !04676J09
                                                                       !04676J0A
        if  ( pstm.auth^ind2 = "1"  ) and                              !04677
            pstm.rte.alt2 <> blanks for $len( pstm.rte.alt1 ) and      !04678
            pstm.rte.alt2 <> zeroes for $len( pstm.rte.alt1 ) then     !04679
            movd( pstm.auth^ind2, "2" )                                !04680
                                                                       !04680600
        else                                                           !04680601
        if ( pstm.auth^ind2 = "f" )  and                               !04680602
           ( pstm.rte.alt1 = net.myname for                            !04680603
                             $len( pstm.rte.alt1 ) ) then              !04680604
            begin                                                      !04680605
            !                                                         !!04680606
            ! If we are SPROUTE alternate 1 and we cannot authorize   !!04680607
            ! either, send message back to the original Router Auth   !!04680608
            ! process.                                                !!04680609
            !                                                         !!0468060A
            movd( pstm.auth^ind2, "9" );                               !0468060B
            if ( pstm.ast^rtn^pro^name = blanks for                    !0468060C
                 $len( pstm.ast^rtn^pro^name ) ) or                    !0468060D
               ( pstm.ast^rtn^pro^name = zeroes for                    !0468060E
                 $len( pstm.ast^rtn^pro^name ) ) then                  !0468060F
                begin                                                  !0468060G
                mov^( dest, pstm.orig^pro^name );                      !0468060H
                end                                                    !0468060I
            else                                                       !0468060J
                begin                                                  !0468060K
                mov^( dest, pstm.ast^rtn^pro^name );                   !0468060L
                end;                                                   !0468060M
            end                                                        !0468060N
                                                                       !0468060O
        else                                                           !04681
                                                                       !04681J00
            movd( pstm.auth^ind2, "9" );                               !04681J01
                                                                       !04681J02
                                                                       !04682J00
                                                                       !04682J01
        end                                                            !04683
    else                                                               !04684
        begin                                                          !04685
                                                                       !04685J00
        if  ( pstm.rte.auth^ind = "P" or pstm.rte.auth^ind = "p" ) and !04685J01
            pct.options.acq^stand^in                               and !04685J02
            pstm.rte.pri = "AUTHH"                                then !04685J03
            begin                                                      !04685J04
            movd( pstm.compl^req, offline^compl^d );                   !04685J05
            if  not integer^ascii^( pstm.rte^stat, stat ) then         !04685J06
                movd( pstm.rte^stat, pstm^stat^line^down^d );          !04685J07
            end                                                        !04685J08
        else                                                           !04685J09
                                                                       !04685J0A
        if  ( pstm.rte.auth^ind = "P" or pstm.rte.auth^ind = "p" ) and !04686
            pstm.rte.alt1 <> blanks for $len( pstm.rte.alt1 ) and      !04687
            pstm.rte.alt1 <> zeroes for $len( pstm.rte.alt1 ) then     !04688
            movd( pstm.rte.auth^ind, "1" )                             !04689
        else                                                           !04690
                                                                       !04690J00
        if  ( pstm.rte.auth^ind = "1" )   and                          !04690J01
            pct.options.acq^stand^in      and                          !04690J02
            pstm.rte.alt1 = "AUTHH"       then                         !04690J03
            begin                                                      !04690J04
            movd( pstm.compl^req, offline^compl^d );                   !04690J05
            if  not integer^ascii^( pstm.rte^stat, stat ) then         !04690J06
                movd( pstm.rte^stat, pstm^stat^line^down^d );          !04690J07
            end                                                        !04690J08
        else                                                           !04690J09
                                                                       !04690J0A
        if  ( pstm.rte.auth^ind = "1" ) and                            !04691
            pstm.rte.alt2 <> blanks for $len( pstm.rte.alt2 ) and      !04692
            pstm.rte.alt2 <> zeroes for $len( pstm.rte.alt2 ) then     !04693
            movd( pstm.rte.auth^ind, "2" )                             !04694
                                                                       !04694Z00
        else                                                           !04694Z01
                                                                       !04694o00
        if  pstm.rte.auth^ind = "F" and                                !04694o01
                                                                       !04694o02
                                                                       !04694o03
                                                                       !04694o04
            pstm.rte.alt1 <> blanks for $len( pstm.rte.alt1 ) and      !04694Z03
            pstm.rte.alt1 <> zeroes for $len( pstm.rte.alt1 ) and      !04694Z04
            pstm.rte.alt1 <> "AUTH"                           and      !04694Z05
            pstm.rte.alt1 <> "NEG"                            then     !04694Z06
            begin                                                      !04694Z07
            !                                                         !!04694Z08
            ! The authorizers were determined using SPROUTE.  Set ind !!04694Z09
            ! to first alternate authorizer from SPROUTE.             !!04694Z0A
            !                                                         !!04694Z0B
                                                                       !04694o05
            movd( pstm.rte.auth^ind, "f" );                            !04694o06
                                                                       !04694o07
                                                                       !04694o08
                                                                       !04694o09
            mov^( dest, pstm.rte.alt1 );                               !04694Z0D
            end                                                        !04694Z0E
                                                                       !04694600
        else                                                           !04694601
        if ( pstm.rte.auth^ind = "f" )  and                            !04694602
           ( pstm.rte.alt1 = net.myname for                            !04694603
                             $len( pstm.rte.alt1 ) ) then              !04694604
            begin                                                      !04694605
            !                                                         !!04694606
            ! If we are SPROUTE alternate 1 and we cannot authorize   !!04694607
            ! either, send message back to the original Router Auth   !!04694608
            ! process.                                                !!04694609
            !                                                         !!0469460A
            movd( pstm.rte.auth^ind, "9" );                            !0469460B
            if ( pstm.ast^rtn^pro^name = blanks for                    !0469460C
                 $len( pstm.ast^rtn^pro^name ) ) or                    !0469460D
               ( pstm.ast^rtn^pro^name = zeroes for                    !0469460E
                 $len( pstm.ast^rtn^pro^name ) ) then                  !0469460F
                begin                                                  !0469460G
                mov^( dest, pstm.orig^pro^name );                      !0469460H
                end                                                    !0469460I
            else                                                       !0469460J
                begin                                                  !0469460K
                mov^( dest, pstm.ast^rtn^pro^name );                   !0469460L
                end;                                                   !0469460M
            end                                                        !0469460N
                                                                       !0469460O
                                                                       !0469460P
                                                                       !0469460Q
        else                                                           !04695
                                                                       !04695J00
            movd( pstm.rte.auth^ind, "9" );                            !04695J01
                                                                       !04695J02
                                                                       !04696J00
                                                                       !04696J01
        end;                                                           !04697

!@***************************************************************@!
!@ BEGIN RPQ #220 Special Response Code for Time Out or Line Down
!@---------------------------------------------------------------@!
    if stat = 11 or
       stat = 12 and
       ( pstm.rte^stat <> "11" and
         pstm.rte^stat <> "12"  ) then
       Begin

        if stat = 11 then
           begin
            pstm.rpq^rte^stat ':=' "1";
           end
        else
        if stat = 12 then
           begin
            pstm.rpq^rte^stat ':=' "2";
           end;

       End;

    if resp^cde = 55 then
       begin
        call integer^ascii^( pstm.tran.resp^cde,
                             resp^cde );
       end;

!@---------------------------------------------------------------@!
!@ END   RPQ #220 Special Response Code for Time Out of Line Down
!@***************************************************************@!
                                                                       !04697J00
    call pos^util^send^pstm( pstm, dest );                             !04697J01
                                                                       !04697J02
                                                                       !04698
    end;                                                               !04699
?section pstm^0210^deny                                                !04700
?page "                                        - pstm^0210^deny"       !04701
!#####################################################################!!04702
!#                                                                   #!!04703
!#                       PSTM^0210^DENY                              #!!04704
!#                                                                   #!!04705
!#    NARRATIVE : THIS PROCEDURE FORMATS AND RETURNS A POS REVERSAL  #!!04706
!#       MESSAGE TO THE LOCAL BASE24-pos AUTH.                       #!!04707
!#                                                                   #!!04708
!#    INPUT PARAMETERS:                                              #!!04709
!#       PRIKEY        : TRANSACTION PRIMARY KEY                     #!!04710
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!04711
!#       DEST          : SYMBOLIC DESTINATION                        #!!04712
!#       RVSL^CDE      : REVERSAL CODE                               #!!04713
!#       SUB           : ILF SUBSTATE                                #!!04714
!#                                                                   #!!04715
!#    OUTPUT PARAMETERS:                                             #!!04716
!#                                                                   #!!04717
!#####################################################################!!04718
proc pstm^0210^deny( prikey, pstm, dest, rvsl^cde, sub ) variable;     !04719
int     .prikey( prikey^def );                                         !04720
int     .pstm( pstm^def );                                             !04721
int     .dest;                                                         !04722
int      rvsl^cde;                                                     !04723
int      sub;                                                          !04724
    begin                                                              !04725
    wlform( trace, "T - pstm^0210^deny ( Reversal Code: ## )" )        !04726
                                                                       !04727
    if  not $param( pstm ) or not $param( dest ) or                    !04728
        not $param( rvsl^cde ) then                                    !04729
        call programmatic^dump( 756 );                                 !04730
                                                                       !04731
    if trace^g.<pos^l> then                                            !04732
        call logmessage^( 1170,, @trace, net.myname,                   !04733
            0, @pos^prod^g, rvsl^cde );                                !04734
                                                                       !04735
                                                                       !04735L00
    if  ( pstm^approved^d( pstm ) and                                  !04735L01
          ( reverse^bal^inq^g and pstm^inquiry^d( pstm ) ) ) then      !04735L02
    else                                                               !04735L03
                                                                       !04735L04
    if  pstm^inquiry^d( pstm ) or not pstm^approved^d( pstm )  then    !04736
        !                                                             !!04737
        ! Don't reverse inquiries or denied transactions              !!04738
        !                                                             !!04739
        return;                                                        !04740
                                                                       !04741
    movd ( pstm.typ, pstm^rvsl^advice^d );                             !04742
                                                                       !04743
    if  integer^ascii^( pstm.rvsl^cde, rvsl^cde ) then                 !04744
        call pos^util^send^pstm( pstm, dest );                         !04745
                                                                       !04746
    if  $param( prikey ) and $param( sub ) then                        !04747
        call util^ilf^add( pct.setl.bic^dat, prikey,                   !04748
            $len( prikey^def ), pos^l, sub, dest, pstm );              !04749
                                                                       !04750
    end;                                                               !04751
?section pstm^0210^response                                            !04752
?page "                                        - pstm^0210^response"   !04753
!#####################################################################!!04754
!#                                                                   #!!04755
!#                    PSTM^0210^RESPONSE                             #!!04756
!#                                                                   #!!04757
!#    NARRATIVE : THIS PROCEDURE FORMATS AND RETURNS A RESPONSE      #!!04758
!#       MESSAGE TO THE CO-NETWORK IF THE TIMER EXISTS.  IF THE      #!!04759
!#       TIMER HAS EXPIRED, FORMAT AND SEND A REVERSAL BACK TO       #!!04760
!#       BASE24-pos IF IT WAS APPROVED.                              #!!04761
!#                                                                   #!!04762
!#    INPUT PARAMETERS:                                              #!!04763
!#       MSG           : WORD POINTER TO MESSAGE                     #!!04764
!#       PSTM          : POINTER TO INTERNAL MESSAGE.                #!!04765
!#       SEM           : POINTER TO EXTERNAL MESSAGE.                #!!04766
!#                                                                   #!!04767
!#    OUTPUT PARAMETERS:                                             #!!04768
!#                                                                   #!!04769
!#####################################################################!!04770
proc pstm^0210^response( msg, pstm, sem );                             !04771
int  .msg;                                                             !04772
int  .pstm( pstm^def );                                                !04773
int  .sem( sem^def );                                                  !04774
    begin                                                              !04775
    struct      .susp( susp^bici^def );                                !04776
                                                                       !04777
                                                                       !04777K00
    int                                                                !04777K01
                 error,                                                !04777K02
                 sta^x,                                                !04777K03
                 rvsl^cde;                                             !04777K04
                                                                       !04777K05
    init( susp,                "  ", wlen( susp^bici^def ) );          !04777K06
    call pstm^frmt^b24^to^prikey( pstm, susp.prikey.tran^tim );        !04777K07
                                                                       !04777K08
    if  not util^suspend^tran^delete( susp, $len( susp^bici^def ), msg,
           time^inbound^rqst^l ) then                                  !04777K0B
                                                                       !04777K0C
                                                                       !04778K00
                                                                       !04778K01
                                                                       !04778K02
        call pstm^0210^deny( susp.prikey, pstm, msg^sym^source,        !04786
            pstm^rvsl^timeout^l )                                      !04787
    else                                                               !04788
    if  pos^util^sem^expand( sem, susp.msg, susp.msg^lgth )  then      !04789
        begin                                                          !04790
        if  not pstm^frmt^b24^to^pos^0210( pstm, sem )  then           !04791
            call pstm^0210^deny( susp.prikey, pstm,                    !04792
                msg^sym^source, pstm^rvsl^cmd^reject^l, sub^frmt^err^l )
        else                                                           !04795
                                                                       !04795K00
        if error := pos^util^send^sem( sem, susp.orig^net^pro )  then  !04795K01
            begin                                                      !04795K02
            if error = mac^device^err^l       or                       !04795K03
               error = mac^operation^failed^l then                     !04795K04
                set( rvsl^cde, pstm^rvsl^mac^failure^l )               !04795K05
            else                                                       !04795K06
                set( rvsl^cde, pstm^rvsl^auth^not^avail^l );           !04795K07
                                                                       !04795K08
            call pstm^0210^deny( susp.prikey, pstm, msg^sym^source,    !04795K09
                                 rvsl^cde, sub^down^at^resp^l );       !04795K0A
                                                                       !04795K0B
            return;                                                    !04795K0C
            end                                                        !04795K0D
                                                                       !04795K0E
                                                                       !04796K00
                                                                       !04796K01
                                                                       !04796K02
        else                                                           !04800
            call util^ilf^add( pstm.acq^ichg^setl^dat, susp.prikey,    !04801
                $len( susp.prikey ), pos^l,, msg^sym^source, pstm, sem );
        end;                                                           !04804
                                                                       !04804S00
                                                                       !04804S01
    if base24^rel^g >= 6 then                                          !04804S02
        begin                                                          !04804S03
        call pstm_0210_ptlf_write( pstm );                             !04804S04
        end                                                            !04804S05
                                                                       !04804S06
    end;                                                               !04805
                                                                       !04805S00
?section pstm_0210_ptlf_write                                          !04805S01
?page   "pstm_0210_ptlf_write"                                         !04805S02
!#####################################################################!!04805S03
!#                                                                   #!!04805S04
!#                      pstm_0210_ptlf_write                         #!!04805S05
!#                                                                   #!!04805S06
!#  This procedure sends a response to a BASE24-pos authorization    #!!04805S07
!#  process to be logged to the PTLF.                                #!!04805S08
!#                                                                   #!!04805S09
!#  INPUT PARAMETERS:                                                #!!04805S0A
!#      pstm           - A pointer to the BASE24 internal message.   #!!04805S0B
!#                                                                   #!!04805S0C
!#  OUTPUT PARAMETERS:                                               #!!04805S0D
!#                                                                   #!!04805S0E
!#  RETURN:                                                          #!!04805S0F
!#                                                                   #!!04805S0G
!#####################################################################!!04805S0H
proc pstm_0210_ptlf_write( pstm );                                     !04805S0I
int            .pstm( pstm^def );                                      !04805S0J
                                                                       !04805S0K
    begin                                                              !04805S0L
                                                                       !04805S0M
    wlform( auth_pro_name_err,                                         !04805S0N
            "Authorization destination not specified in File \F. "     !04805S0O
    ','     "Transaction not logged to the BASE24-pos PTLF."           !04805S0P
    ','     " Message follows: " )                                     !04805S0Q
                                                                       !04805S0R
    int             tkn_buf_lgth;                                      !04805S0S
    int            .tkn_buf_ptr( acq_rte_tkn_def );                    !04805S0T
    int             tkn_result;                                        !04805S0U
                                                                       !04805S0V
    string         .tkn_id[ 0:1 ];                                     !04805S0W
                                                                       !04805S0X
    !                                                                ! !04805S0Y
    ! Get the APCFEMT auth destination and log authorization         ! !04805S0Z
    ! destination response field from the original request.          ! !04805S10
    !                                                                ! !04805S11
    movd( tkn_id, acq^rte^tkn^id^d );                                  !04805S12
                                                                       !04805S13
    if hiswtkn^get^tkn( pstm, tkn_id, @tkn_buf_ptr,                    !04805S14
                        tkn_buf_lgth ) then                            !04805S15
        begin                                                          !04805S16
        !                                                            ! !04805S17
        ! Acquirer Routing Token found                               ! !04805S18
        !                                                            ! !04805S19
        if ( tkn_buf_ptr.auth_dest <>                                  !04805S1A
                 [ $len( tkn_buf_ptr.auth_dest ) * [ " " ] ] ) and     !04805S1B
           ( tkn_buf_ptr.log_auth_dest_resp = "Y" ) then               !04805S1C
            begin                                                      !04805S1D
            !                                                        ! !04805S1E
            ! Response must be sent to ICFE auth process             ! !04805S1F
            !                                                        ! !04805S1G
                                                                       !04805S1H
            if pos^pct.dest <>                                         !04805S1I
                   [ $len( pos^pct.dest ) * [ " " ] ] then             !04805S1J
                begin                                                  !04805S1K
                call pos^util^send^pstm( pstm, pos^pct.dest);          !04805S1L
                end                                                    !04805S1M
            else                                                       !04805S1N
                begin                                                  !04805S1O
                call logmessage^( 1830, !routing code!,                !04805S1P
                                  @auth_pro_name_err, net.myname,      !04805S1Q
                                  evt_msg_severity_err_l,              !04805S1R
                                  @pos^prod^g, @icfe_name_g );         !04805S1S
                call log^message( 1831, !routing code!, pstm,          !04805S1T
                                  $min( $len( pstm ),                  !04805S1U
                                         max^logger^l ),               !04805S1V
                                  net.myname,                          !04805S1W
                                  evt_msg_severity_err_l );            !04805S1X
                end;                                                   !04805S1Y
                                                                       !04805S1Z
            end; ! of response must be sent to ICFE auth-pro         ! !04805S20
                                                                       !04805S21
        end; ! hiswtkn^get^tkn                                       ! !04805S22
                                                                       !04805S23
    end; ! of proc pstm_0210_ptlf_write                              ! !04805S24
                                                                       !04805S25
?section pstm^0220^advice                                              !04806
?page "                                        - pstm^0220^advice"     !04807
!#####################################################################!!04808
!#                                                                   #!!04809
!#                      PSTM^0220^ADVICE                             #!!04810
!#                                                                   #!!04811
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS A FORCE POST      #!!04812
!#       MESSAGE TO THE CO-NETWORK FROM BASE24-pos.                  #!!04813
!#                                                                   #!!04814
!#    INPUT PARAMETERS:                                              #!!04815
!#       MSG          : WORD POINTER TO MESSAGE                      #!!04816
!#       PSTM         : TEXT POINTER TO MESSAGE                      #!!04817
!#       SEM          : TEXT POINTER TO EXTERNAL MESSAGE             #!!04818
!#                                                                   #!!04819
!#    OUTPUT PARAMETERS:                                             #!!04820
!#                                                                   #!!04821
!#####################################################################!!04822
proc pstm^0220^advice( msg, pstm, sem );                               !04823
int  .msg;                                                             !04824
int  .pstm( pstm^def );                                                !04825
int  .sem(  sem^def );                                                 !04826
    begin                                                              !04827
                                                                       !04827H00
                                                                       !04827H01
                                                                       !04827H02
                                                                       !04828H00
                                                                       !04828H01
                                                                       !04829
    struct  .isem( sem^def ),                                          !04830
            .prikey( prikey^def );                                     !04831
                                                                       !04832
                                                                       !04832K00
    int      csem^lgth,                                                !04832K01
             error;                                                    !04832K02
                                                                       !04832S00
    int      fatal_flg := true;                                        !04832S01
    int      resp^cde;                                                 !04832S02
                                                                       !04832S03
                                                                       !04832K03
                                                                       !04833K00
                                                                       !04833K01
                                                                       !04834
    string  .csem := byteaddr( @isem );                                !04835
                                                                       !04836
    if  not pstm^approved^d( pstm ) or pstm^inquiry^d( pstm ) then     !04837
        return;                                                        !04838
                                                                       !04839
    move ( pstm.tran.crd^ln,       pct.ln           );                 !04840
    move ( pstm.tran.crd^fiid,     pct.fiid         );                 !04841
    move ( pstm.iss^ichg^setl^dat, pct.setl.bic^dat );                 !04842
                                                                       !04843
    call pstm^frmt^b24^to^prikey( pstm, prikey );                      !04844
                                                                       !04845
                                                                       !04845H00
                                                                       !04845H01
                                                                       !04845H02
                                                                       !04845H03
                                                                       !04845H04
                                                                       !04845H05
                                                                       !04845H06
                                                                       !04845H07
                                                                       !04845H08
                                                                       !04845H09
                                                                       !04846H00
                                                                       !04846H01
                                                                       !04846H02
                                                                       !04854
                                                                       !04854S00
    if base24^rel^g >= 6 and ( resp^cde := hiswpstm_txn_alwd_iss(      !04854S01
                                               pstm,                   !04854S02
                                               pos^pct.iss^txn^prfl,   !04854S03
                                               msg^sym^source,         !04854S04
                                               ipcfemt_seg_id_g,       !04854S05
                                               pos^pct.num^srv,        !04854S06
                                               ipcf_emt_rec_g,         !04854S07
                                               fatal_flg,              !04854S08
                                               ipcfemt_name_g ) ) then !04854S09
        begin                                                          !04854S0A
        if resp^cde then                                               !04854S0B
            begin                                                      !04854S0C
            if resp^cde = sys_frmt_err_l then                          !04854S0D
                begin                                                  !04854S0E
                !                                                    ! !04854S0F
                ! System error                                       ! !04854S0G
                !                                                    ! !04854S0H
                call util^ilf^add( pct.setl.bic^dat,                   !04854S0I
                                   prikey,                             !04854S0J
                                   $len( prikey^def ),                 !04854S0K
                                   pos^l,                              !04854S0L
                                   sub^frmt^err^l,                     !04854S0M
                                   msg^sym^source,                     !04854S0N
                                   pstm,                               !04854S0O
                                   sem );                              !04854S0P
                end                                                    !04854S0Q
            else                                                       !04854S0R
                begin                                                  !04854S0S
                if resp^cde = txn_cde_not_sppt_l then                  !04854S0T
                    begin                                              !04854S0U
                    !                                                ! !04854S0V
                    ! Transaction not allowed to switch according to ! !04854S0W
                    ! ipcfemt                                        ! !04854S0X
                    !                                                ! !04854S0Y
                    call util^ilf^add( pct.setl.bic^dat,               !04854S0Z
                                       prikey,                         !04854S10
                                       $len( prikey^def ),             !04854S11
                                       pos^l,                          !04854S12
                                       sub^sys^err^l,                  !04854S13
                                       msg^sym^source,                 !04854S14
                                       pstm,                           !04854S15
                                       sem );                          !04854S16
                    end;                                               !04854S17
                end;                                                   !04854S18
            return;                                                    !04854S19
            end;                                                       !04854S1A
        end ! of base24^rel^g >= 6                                   ! !04854S1B
    else                                                               !04854S1C
    if base24^rel^g < 6 and not hiswutil^pos^trans^allowed(            !04854S1D
                                          pstm.tran.tran^cde,          !04854S1E
                                          pos^pct.trans^allowed ) then !04854S1F
        begin                                                          !04854S1G
        call util^ilf^add( pct.setl.bic^dat,                           !04854S1H
                           prikey,                                     !04854S1I
                           $len( prikey^def ),                         !04854S1J
                           pos^l,                                      !04854S1K
                           sub^fail^pre^auth^l,                        !04854S1L
                           msg^sym^source,                             !04854S1M
                           pstm,                                       !04854S1N
                           sem );                                      !04854S1O
                                                                       !04854S1P
        end ! of base24^rel^g < 6 and not hiswutil^pos^trans^allowed ! !04854S1Q
                                                                       !04854S1R
    else                                                               !04854S1S
    if not pct.options.acquirer or                                     !04854S1T
       not hiswutil^pos^service^allowed( pstm.rte.srv,                 !04854S1U
                                         pos^pct.allowed^srv,          !04854S1V
                                         pos^pct.num^srv ) then        !04854S1W
        begin                                                          !04854S1X
        call util^ilf^add( pct.setl.bic^dat,                           !04854S1Y
                           prikey,                                     !04854S1Z
                           $len( prikey^def ),                         !04854S20
                           pos^l,                                      !04854S21
                           sub^fail^pre^auth^l,                        !04854S22
                           msg^sym^source,                             !04854S23
                           pstm,                                       !04854S24
                           sem );                                      !04854S25
        end                                                            !04854S26
                                                                       !04854S27
                                                                       !04855S00
                                                                       !04855S01
                                                                       !04855S02
    else                                                               !04863
    if  not pstm^frmt^b24^to^pos^0220( pstm, sem ) then                !04864
        begin                                                          !04865
        call util^ilf^add( pct.setl.bic^dat, prikey, $len( prikey^def ),
            pos^l, sub^frmt^err^l, msg^sym^source, pstm, sem );        !04868
                                                                       !04868K00
        call log^message( 1176, pos^id^cde^g, pstm,                    !04868K01
                          max^logger^l,, 2, @pos^prod^g );             !04868K02
                                                                       !04868K03
                                                                       !04869K00
                                                                       !04869K01
        end                                                            !04870
    else                                                               !04871
                                                                       !04871K00
    if not ( error := pos^util^sem^collapse( sem, csem,                !04871K01
                                                                       !L0487100
                                                                       !L0487101
                                             csem^lgth,                !L0487102
                                             ! mac !,                  !L0487103
                                             pstm ) ) then             !L0487104
                                                                       !L0487105
                                                                       !04872K01
        begin                                                          !04873
        call util^saf^add( csem, csem^lgth );                          !04874
        call util^ilf^add( pct.setl.bic^dat, prikey, $len( prikey^def ),
            pos^l, sub^ok^l, msg^sym^source, pstm, sem );              !04877
        end;                                                           !04878
    end;                                                               !04879
?section pstm^0402^request                                             !04880
?page "                                        - pstm^0402^request"    !04881
!#####################################################################!!04882
!#                                                                   #!!04883
!#                         PSTM^0402^REQUEST                         #!!04884
!#                                                                   #!!04885
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS A REVERSAL        #!!04886
!#       REQUEST MESSAGE TO THE CO-NETWORK FROM BASE24-pos.          #!!04887
!#                                                                   #!!04888
!#    INPUT PARAMETERS:                                              #!!04889
!#       MSG           : WORD POINTER TO MESSAGE                     #!!04890
!#       PSTM          : TEXT POINTER TO MESSAGE                     #!!04891
!#       SEM           : TEXT POINTER TO EXTERNAL MESSAGE            #!!04892
!#                                                                   #!!04893
!#    OUTPUT PARAMETERS:                                             #!!04894
!#                                                                   #!!04895
!#####################################################################!!04896
proc pstm^0402^request( msg, pstm, sem );                              !04897
int  .msg;                                                             !04898
int  .pstm( pstm^def );                                                !04899
int  .sem(  sem^def  );                                                !04900
    begin                                                              !04901
                                                                       !04901K00
    wlform( ilf^err, "Transaction denied due to a previous error" ','  !04901K01
            " on the ILF - Correct the problem and warmboot " )        !04901K02
    wlform( saf^err, "Transaction denied due to a previous error" ','  !04901K03
            " on the SAF - Correct the problem and warmboot " )        !04901K04
                                                                       !04901K05
                                                                       !04901K06
    struct .isem( sem^def ),                                           !04902
           .prikey( prikey^def );                                      !04903
                                                                       !04904
    int     csem^lgth,                                                 !04905
                                                                       !04905K00
            error,                                                     !04905K01
                                                                       !04905K02
            resp^cde;                                                  !04906
                                                                       !04906S00
    int     fatal_flg := true;                                         !04906S01
                                                                       !04906S02
                                                                       !04907
    string .csem := byteaddr( @isem );                                 !04908
                                                                       !04909
    if  msg^poss^dup^( msg )  then                                     !04910
        return;                                                        !04911
                                                                       !04912
    movd ( pstm.responder,               switch^interface^origin^d );  !04913
    move ( pstm.tran.dest,               pct.swi^typ               );  !04914
    move ( pstm.tran.crd^ln,             pct.ln                    );  !04915
    move ( pstm.tran.crd^fiid,           pct.fiid                  );  !04916
    move ( pstm.tran.rfrl^phone,         pos^pct.phone^num         );  !04917
    move ( pstm.iss^ichg^setl^dat,       pct.setl.bic^dat          );  !04918
                                                                       !04919
    call pstm^frmt^b24^to^prikey( pstm, prikey );                      !04920
                                                                       !04921
                                                                       !04921S00
    if base24^rel^g >= 6 then                                          !04921S01
        begin                                                          !04921S02
        if pos^pct.chrgbck^flg = "0" then                              !04921S03
            !                                                        ! !04921S04
            ! Chargebacks are not allowed                            ! !04921S05
            !                                                        ! !04921S06
            begin                                                      !04921S07
            call pstm^0200^deny( prikey,                               !04921S08
                                 pstm,                                 !04921S09
                                 msg^sym^source,                       !04921S0A
                                 pstm^resp^inv^tran^l,                 !04921S0B
                                 sub^fail^pre^auth^l );                !04921S0C
            return;                                                    !04921S0D
            end;                                                       !04921S0E
                                                                       !04921S0F
        resp^cde := hiswpstm_txn_alwd_iss( pstm,                       !04921S0G
                                           pos^pct.iss^txn^prfl,       !04921S0H
                                           msg^sym^source,             !04921S0I
                                           ipcfemt_seg_id_g,           !04921S0J
                                           pos^pct.num^srv,            !04921S0K
                                           ipcf_emt_rec_g,             !04921S0L
                                           fatal_flg,                  !04921S0M
                                           ipcfemt_name_g );           !04921S0N
        if resp^cde = sys_frmt_err_l then                              !04921S0O
            begin                                                      !04921S0P
            !                                                        ! !04921S0Q
            ! System error                                           ! !04921S0R
            !                                                        ! !04921S0S
            call pstm^0200^deny( prikey,                               !04921S0T
                                 pstm,                                 !04921S0U
                                 msg^sym^source,                       !04921S0V
                                 pstm^resp^frmt^err^l,                 !04921S0W
                                 sub^frmt^err^l );                     !04921S0X
            return;                                                    !04921S0Y
            end                                                        !04921S0Z
        else                                                           !04921S10
            begin                                                      !04921S11
            if resp^cde = txn_cde_not_sppt_l then                      !04921S12
                begin                                                  !04921S13
                !                                                    ! !04921S14
                ! Trans not allowed to switch according to IPCFEMT   ! !04921S15
                !                                                    ! !04921S16
                call pstm^0200^deny( prikey,                           !04921S17
                                     pstm,                             !04921S18
                                     msg^sym^source,                   !04921S19
                                     pstm^resp^inv^tran^l,             !04921S1A
                                     sub^fail^pre^auth^l );            !04921S1B
                return;                                                !04921S1C
                end;                                                   !04921S1D
            end;                                                       !04921S1E
        end ! of base24^rel^g >= 6                                   ! !04921S1F
    else                                                               !04921S1G
                                                                       !04921S1H
    if  pos^pct.trans^allowed.chargeback = "0" then                    !04922
        !                                                             !!04923
        ! Chargebacks are not allowed                                 !!04924
        !                                                             !!04925
        begin                                                          !04926
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04927
            pstm^resp^inv^tran^l, sub^fail^pre^auth^l );               !04928
        return;                                                        !04929
        end;                                                           !04930
                                                                       !04931
                                                                       !04931S00
    if base24^rel^g < 6 and                                            !04931S01
       not hiswutil^pos^trans^allowed( pstm.tran.tran^cde,             !04931S02
                                       pos^pct.trans^allowed ) then    !04931S03
                                                                       !04931S04
                                                                       !04932S00
                                                                       !04932S01
                                                                       !04932S02
        begin                                                          !04934
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04935
            pstm^resp^inv^tran^l, sub^fail^pre^auth^l );               !04936
        return;                                                        !04937
        end;                                                           !04938
                                                                       !04939
    if  not hiswutil^pos^service^allowed( pstm.rte.srv,                !04940
           pos^pct.allowed^srv, pos^pct.num^srv ) then                 !04941
        begin                                                          !04942
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04943
            pstm^resp^inv^tran^l, sub^fail^pre^auth^l );               !04944
        return;                                                        !04945
        end;                                                           !04946
                                                                       !04947
                                                                       !04947K00
    if pct.ilf.ferror and pct.ilf.ferror <> feeof then                 !04947K01
        begin                                                          !04947K02
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04947K03
            pstm^resp^referral^l, sub^sys^err^l );                     !04947K04
        call logmessage^( 1200,, @ilf^err, net.myname,                 !04947K05
                          2, @pos^prod^g );                            !04947K06
        return;                                                        !04947K07
        end;                                                           !04947K08
                                                                       !04947K09
    if pct.saf.ferror and pct.saf.ferror <> feeof then                 !04947K0A
                                                                       !04947K0B
                                                                       !04948K00
                                                                       !04948K01
                                                                       !04948K02
        begin                                                          !04950
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04951
            pstm^resp^referral^l, sub^sys^err^l );                     !04952
                                                                       !04952K00
        call logmessage^( 1205,, @saf^err, net.myname,                 !04952K01
                          2, @pos^prod^g );                            !04952K02
                                                                       !04952K03
        return;                                                        !04953
        end;                                                           !04954
                                                                       !04955
    if  not pct.options.pos.present then                               !04956
        begin                                                          !04957
        call pstm^0200^deny( prikey, pstm, msg^sym^source,             !04958
            pstm^resp^referral^l, sub^sys^err^l );                     !04959
        return;                                                        !04960
        end;                                                           !04961
                                                                       !04962
    if  resp^cde := pstm^frmt^b24^to^pos^0402( pstm, sem ) then        !04963
        begin                                                          !04964
        call pstm^0200^deny( prikey, pstm, msg^sym^source, resp^cde,   !04965
            sub^frmt^err^l );                                          !04966
        return;                                                        !04967
        end;                                                           !04968
                                                                       !04969
    movd ( pstm.typ,           pstm^rvsl^response^d );                 !04970
    mov^ ( pstm.tran.resp^cde, zeroes               );                 !04971
    call pos^util^send^pstm( pstm, msg^sym^source );                   !04972
                                                                       !04973
                                                                       !04973K00
    if not ( error := pos^util^sem^collapse( sem, csem,                !04973K01
                                                                       !L0497300
                                                                       !L0497301
                                             csem^lgth,                !L0497302
                                             ! mac !,                  !L0497303
                                             pstm ) ) then             !L0497304
                                                                       !L0497305
                                                                       !04974K01
        call util^saf^add( csem, csem^lgth );                          !04975
                                                                       !04976
    call util^ilf^add( pct.ilf.cur.dat, prikey, $len( prikey^def ),    !04977
        pos^l, sub^ok^l, msg^sym^source, pstm, sem );                  !04978
    end;                                                               !04979
?section pstm^0412^response                                            !04980
?page "                                        - pstm^0412^response"   !04981
!#####################################################################!!04982
!#                                                                   #!!04983
!#                    PSTM^0412^RESPONSE                             #!!04984
!#                                                                   #!!04985
!#    NARRATIVE : THIS PROCEDURE PROCESSES THE BASE24 CHARGEBACK     #!!04986
!#       RESPONSE.                                                   #!!04987
!#                                                                   #!!04988
!#    INPUT PARAMETERS :                                             #!!04989
!#       MSG           : WORD POINTER TO MESSAGE                     #!!04990
!#       PSTM          : POINTER TO INTERNAL MESSAGE.                #!!04991
!#       SEM           : POINTER TO THE EXTERNAL MESSAGE.            #!!04992
!#                                                                   #!!04993
!#    OUTPUT PARAMETERS:                                             #!!04994
!#                                                                   #!!04995
!#####################################################################!!04996
proc pstm^0412^response( msg, pstm, sem );                             !04997
int  .msg;                                                             !04998
int  .pstm( pstm^def );                                                !04999
int  .sem( sem^def );                                                  !05000
    begin                                                              !05001
    struct .ilf( ilf^def ),                                            !05002
           .prikey( prikey^def );                                      !05003
                                                                       !05004
    int     fnum,                                                      !05005
            ilf^lgth;                                                  !05006
                                                                       !05007
    call pstm^frmt^b24^to^prikey( pstm, prikey );                      !05008
                                                                       !05009
    if  not  ( fnum := util^ilf^get( prikey,                           !05010
           $len( prikey^def ), ilf, ilf^lgth ) ) then                  !05011
        begin                                                          !05012
        call util^ilf^add( pct.setl.bic^dat, prikey, $len( prikey^def ),
            pos^l, sub^rvsl^not^found^l, msg^sym^source, pstm );       !05015
                                                                       !05015800
        return;                                                        !05015801
                                                                       !05015802
        end;                                                           !05016
                                                                       !05017
    movd ( ilf.pos.typ,       rvsl^response^d    );                    !05018
    move ( ilf.pos.tran.resp, pstm.tran.resp^cde );                    !05019
                                                                       !05020K00
    call util^ilf^updt( fnum, ilf, ilf^lgth, pos^l, sub^ok^l,          !05020K01
                                                                       !05020K02
        msg^sym^source, pstm );                                        !05021
                                                                       !05022800
                                                                       !05022801
    end;                                                               !05023
?section pstm^0420^reversal                                            !05024
?page "                                        - pstm^0420^reversal"   !05025
                                                                       !05026
!#####################################################################!!05027
!#                                                                   #!!05028
!#                        PSTM^0420^REVERSAL                         #!!05029
!#                                                                   #!!05030
!#    NARRATIVE : THIS PROCEDURE FORMATS AND SENDS A REVERSAL        #!!05031
!#       MESSAGE TO THE CO-NETWORK.  THE ILF RECORD IS UPDATED IN    #!!05032
!#       PLACE.                                                      #!!05033
!#                                                                   #!!05034
!#    INPUT PARAMETERS:                                              #!!05035
!#       MSG          : WORD POINTER TO MESSAGE                      #!!05036
!#       PSTM         : TEXT POINTER TO INTERNAL MESSAGE             #!!05037
!#       SEM          : TEXT POINTER TO EXTERNAL MESSAGE             #!!05038
!#                                                                   #!!05039
!#    OUTPUT PARAMETERS:                                             #!!05040
!#                                                                   #!!05041
!#####################################################################!!05042
proc pstm^0420^reversal( msg, pstm, sem );                             !05043
int  .msg;                                                             !05044
int  .pstm( pstm^def );                                                !05045
int  .sem(  sem^def  );                                                !05046
    begin                                                              !05047
    struct  .isem( sem^def ),                                          !05048
            .ilf( ilf^def ),                                           !05049
            .prikey( prikey^def );                                     !05050
                                                                       !05050]00
                                                                       !05050]01
    int     .b24^msg[ 0 : wlen( msg^def ) - 1 ];                       !05050]02
    int     .orig^pstm( pstm^def ) = b24^msg;                          !05050]03
                                                                       !05050]04
                                                                       !05050@02
                                                                       !05051
    int      csem^lgth,                                                !05052
                                                                       !05052K00
             error,                                                    !05052K01
                                                                       !05052K02
             fnum,                                                     !05053
             ilf^lgth;                                                 !05054
                                                                       !05055
    string  .csem := byteaddr( @isem );                                !05056
                                                                       !05057
    if  msg^poss^dup^( msg ) then                                      !05058
                                                                       !05059
        ! Process Duplicates from the nucleus                         !!05060
                                                                       !05061
        begin                                                          !05062
        if  pos^util^check^dup^rvsl( ,pstm ) then                      !05063
            return;                                                    !05064
        end;                                                           !05065
                                                                       !05066
                                                                       !05066L00
    if  ( pstm^approved^d( pstm ) and                                  !05066L01
          ( reverse^bal^inq^g and pstm^inquiry^d( pstm ) ) ) then      !05066L02
    else                                                               !05066L03
                                                                       !05066L04
    if  not pstm^approved^d( pstm ) or pstm^inquiry^d( pstm ) then     !05067
        return;                                                        !05068
                                                                       !05069]00
    init( b24^msg, "  ", wlen( msg^def ) );                            !05069]01
                                                                       !05069]02
    call pstm^frmt^b24^to^prikey( pstm, prikey );                      !05070
                                                                       !05071
    if  not ( fnum := util^ilf^get( prikey, $len( prikey^def ),        !05072
                                                                       !05072@00
                          ilf, ilf^lgth, orig^pstm  ) ) then           !05072@01
                                                                       !05072@02
                                                                       !05073@00
                                                                       !05073@01
        begin                                                          !05074
        call util^ilf^add( pct.setl.bic^dat, prikey, $len( prikey^def ),
            pos^l, sub^rvsl^not^found^l, msg^sym^source, pstm, sem );  !05077
        return;                                                        !05078
        end;                                                           !05079
                                                                       !05080
    if  ilf.pos.typ = pstm^rvsl^advice^d then                          !05081
        !                                                             !!05082
        ! Drop Duplicate reversals                                    !!05083
        !                                                             !!05084
        return;                                                        !05085
                                                                       !05086
                                                                       !05086@00
    if  not pstm^frmt^b24^to^pos^0420( pstm, orig^pstm, sem  ) then    !05086@01
                                                                       !05086@02
                                                                       !05087@00
                                                                       !05087@01
        begin                                                          !05088
        call util^ilf^add( pct.setl.bic^dat, prikey, $len( prikey^def ),
            pos^l, sub^frmt^err^l, msg^sym^source, pstm, sem );        !05091
        return;                                                        !05092
        end;                                                           !05093
                                                                       !05094
                                                                       !05094K00
    if not ( error := pos^util^sem^collapse( sem, csem,                !05094K01
                                                                       !L0509400
                                                                       !L0509401
                                             csem^lgth,                !L0509402
                                             ! mac !,                  !L0509403
                                             pstm ) ) then             !L0509404
                                                                       !L0509405
                                                                       !05095K01
        begin                                                          !05096
        call util^saf^add( csem, csem^lgth );                          !05097
                                                                       !05098K00
        call util^ilf^updt( fnum, ilf, ilf^lgth, pos^l, sub^ok^l,      !05098K01
                                                                       !05098K02
            msg^sym^source, pstm, sem );                               !05099
        end;                                                           !05100
                                                                       !05101
    end;                                                               !05102
?section pstm^frmt^b24^to^pos^0200                                     !05103
?page "                               - pstm^frmt^b24^to^pos^0200"     !05103K00
!#####################################################################!!05106
!#                                                                   #!!05107
!#                     PSTM^FRMT^B24^TO^POS^0200                     #!!05108
!#                                                                   #!!05109
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0200 PSTM TO AN EXTERNAL  #!!05110
!#       0200 REQUEST MESSAGE OR 0100 REQUEST PRE AUTHORIZATION      #!!05111
!#       REQUEST.                                                    #!!05112
!#                                                                   #!!05113
!#    INPUT PARAMETERS:                                              #!!05114
!#       PSTM          : POINTER TO A BASE24 INTERNAL POS MESSAGE    #!!05115
!#                                                                   #!!05116
!#    OUTPUT PARAMETERS:                                             #!!05117
!#       SEM           : POINTER TO A BIC ISO EXTERNAL MESSAGE       #!!05118
!#                                                                   #!!05119
!#####################################################################!!05120
int proc pstm^frmt^b24^to^pos^0200( pstm, sem );                       !05121
struct  .pstm( pstm^def );                                             !05122
struct  .sem(  sem^def  );                                             !05123
    begin                                                              !05124
                                                                       !05124K00
    wlform( del^err,                                                   !05124K01
        "Error while attempting to delete token \\ from the PSTM " )   !05124K02
    wlform( add^err, "Error while attempting to add token \\ " )       !05124K03
    wlform( no^room, "Unable to add token \\, no room available " )    !05124K04
                                                                       !05124K05
                                                                       !05124K06
    define   pstm^adj^code^d( x )  =  adjustment^tbl[ (x) * 4 + 0]#,   !05125
             sem^adj^code^d(  x )  =  adjustment^tbl[ (x) * 4 + 2]#;   !05126
                                                                       !05127
    string   adjustment^tbl = 'P' :=  [                                !05128
        !                                                             !!05129
        !  PSTM ADJ.        SEM ADJ.                                  !!05130
        !  CODES            CODES                                     !!05131
        !    |                |                                       !!05132
        !    v                v                                       !!05133
           "12",            "64", ! original amount incorrect         !!05134
           "14",            "S1", ! private - suspcious rvsl overide  !!05135
           "15",            "S2", ! private - misdispense overide     !!05136
                                                                       !05137100
           "16",            "T9", ! duplicate transmission            !!05137101
                                                                       !05137102
           "17",            "95", ! reconcile error                   !!05138
           "18",            "S3", ! private - PLUS add cash wdl or adv!!05139
           "19",            "96", ! system malfunction                !!05140
            0 ];                                                       !05141
                                                                       !05142
                                                                       !05142K00
    struct                                                             !05142K01
           .addr^ver^tkn( addr^ver^tkn^def ),                          !05142K02
                                                                       !O0514200
           .pos^data1^tkn( pos^data1^tkn^def ),                        !O0514201
                                                                       !O0514202
           .tkn^mem^rec( tkn^mem^rec^def );                            !05142K03
                                                                       !05142K04
    int                                                                !05142K05
            bit^map[ 0:7 ] := [ 8 * [ 0 ] ],                           !05142K06
            epin^lgth := -1,                                           !05142K07
            error,                                                     !05142K08
            ipin^lgth := -1,                                           !05142K09
            pan^lgth  := max^pan^lgth^l,                               !05142K0A
                                                                       !O0514203
           .pos^data1^tkn^ptr( pos^data1^tkn^def ),                    !O0514204
            pos^data1^lgth := 0,                                       !O0514205
!**********************************************************************
! BEGIN RPQ #BE002 - Bolsillo Electronico Eliminacion RPQ
!**********************************************************************
!**********************************************************************
! BEGIN RPQ #BE001 - Bolsillo Electronico
!**********************************************************************
!          .ps51^get^tkn( ps51^tkn^def ),
!                      ps51^get^lgth := 0,
!**********************************************************************
! END   RPQ #BE001 - Bolsillo Electronico
!**********************************************************************
!**********************************************************************
! END   RPQ #BE002 - Bolsillo Electronico Eliminacion RPQ
!**********************************************************************
                                                                       !O0514206
            sec^dev^resp := 0,                                         !05142K0B
            tkn^frmt^err := 0,                                         !05142K0C
            userdata;                                                  !05142K0D
                                                                       !05142K0E
!********************************************************************!
!* BEGIN RPQ #RECU -                                                *!
!********************************************************************!
int       hay^tkn^ch;
int       tkn^ofst;
int       tkn^lgth;
int       tkn^result;
int      .ps51^tkn^ptr( ps51^tkn^def );
!********************************************************************!
!* END   RPQ #RECU -                                                *!
!********************************************************************!

    string                                                             !05142K0F
            err^flg,                                                   !05142K0G
           .pan[ 0:max^pan^lgth^l ],                                   !05142K0H
           .tkn^grp[ 0:3 ],                                            !05142K0I
           .tkn^id[ 0:1 ];                                             !05142K0J
                                                                       !05142K0K
!#####################################################################!!05142K0L
!#                                                                   #!!05142K0M
!#                  INT^PAN^EQL^EXT^PAN                              #!!05142K0N
!#                                                                   #!!05142K0O
!#   This subproc determines if the internal and external pan        #!!05142K0P
!#   blocks are the same.                                            #!!05142K0Q
!#                                                                   #!!05142K0R
!#####################################################################!!05142K0S
int subproc int^pan^eql^ext^pan;                                       !05142K0T
                                                                       !05142K0U
    begin                                                              !05142K0V
                                                                       !05142K0W
    struct  int^pan; begin string byte [0:11]; end;                    !05142K0X
    struct  ext^pan; begin string byte [0:11]; end;                    !05142K0Y
                                                                       !05142K0Z
    ! Determine the external pan digits!                               !05142K10
                                                                       !05142K11
    ext^pan.byte ':=' zeroes for $len(ext^pan);                        !05142K12
    if  pan^lgth < 13 and pct.pin.out^pan = "0" then                   !05142K13
        ext^pan.byte[ 13 - pan^lgth ] ':=' pan[ 0 ] for                !05142K14
        $max( 0, pan^lgth - 1 )                                        !05142K15
    else                                                               !05142K16
    if  pan^lgth < 13 and pct.pin.out^pan = "1" then                   !05142K17
        ext^pan.byte[ 12 - pan^lgth ] ':=' pan[ 0 ] for                !05142K18
        $max( 0, pan^lgth )                                            !05142K19
    else                                                               !05142K1A
        case ( pct.pin.out^pan '-' "0" ) of                            !05142K1B
            begin                                                      !05142K1C
        !0!  ext^pan.byte ':=' pan[ pan^lgth - 13 ] for 12;            !05142K1D
        !1!  ext^pan.byte ':=' pan[ pan^lgth - 12 ] for 12;            !05142K1E
        !?!  otherwise                                                 !05142K1F
                 ext^pan.byte ':=' pan[ 0 ] for 12;                    !05142K1G
            end;                                                       !05142K1H
                                                                       !05142K1I
    ! Determine the internal pan digits!                               !05142K1J
                                                                       !05142K1K
    int^pan.byte ':=' zeroes for $len( int^pan );                      !05142K1L
                                                                       !05142K1M
    if pstm.ansi^ofst < 0 then                                         !05142K1N
        int^pan.byte[ $abs( pstm.ansi^ofst ) ] ':='                    !05142K1O
                pan[ 0 ] for ( 12 + pstm.ansi^ofst )                   !05142K1P
    else                                                               !05142K1Q
        int^pan.byte[ 12 - $min( 12, pan^lgth ) ] ':='                 !05142K1R
            pan[ pstm.ansi^ofst ] for $min( 12, pan^lgth );            !05142K1S
                                                                       !05142K1T
    if int^pan.byte = ext^pan.byte for $len( int^pan ) then            !05142K1U
        return true                                                    !05142K1V
    else                                                               !05142K1W
        return false;                                                  !05142K1X
                                                                       !05142K1Y
    end;                                                               !05142K1Z
                                                                       !05142K20
!#####################################################################!!05142K21
!#   This is the main body of proc pstm^frmt^b24^to^pos^0200         #!!05142K22
!#####################################################################!!05142K23
                                                                       !05142K24
                                                                       !05143K00
                                                                       !05143K01
                                                                       !05143K02
                                                                       !05150
    if  pstm^pre^auth^d( pstm ) then                                   !05151
        begin                                                          !05152
        movd ( psem.typ,                    auth^request^d       );    !05153
        mov^ ( psem.pri^bit^map,            pos.p0100.pbit^map   );    !05154
        mov^ ( psem.secndry^bit^map,        pos.p0100.sbit^map   );    !05155
                                                                       !05155K00
        movl ( tkn^grp, pos.p0100.tkn^grp, $occurs( tkn^grp )    );    !05155K01
                                                                       !05155K02
        end                                                            !05156
    else                                                               !05157
        begin                                                          !05158
        movd ( psem.typ,                    tran^request^d       );    !05159
        mov^ ( psem.pri^bit^map,            pos.p0200.pbit^map   );    !05160
        mov^ ( psem.secndry^bit^map,        pos.p0200.sbit^map   );    !05161
                                                                       !05161K00
        movl ( tkn^grp, pos.p0200.tkn^grp,  $occurs( tkn^grp )   );    !05161K01
                                                                       !05161K02
        end;                                                           !05162
                                                                       !05163
    call integer^ascii^( psem.trace^num, trace^num^g );                !05164
                                                                       !05165
    if  not pstm^frmt^b24^to^pos^tran( pstm, sem ) then                !05166
        return pstm^resp^frmt^err^l;                                   !05167
                                                                       !05168
    if  not pstm^frmt^b24^to^pos^acct( pstm, sem ) then                !05169
        return pstm^resp^frmt^err^l;                                   !05170
                                                                       !05171
                                                                       !05171i00
                                                                       !05171q00
    if pct.options.mult^crncy = "N" and                                !05171q01
       base24^rel^g >= 6            then                               !05171q02
                                                                       !05171q03
        begin                                                          !05171i02
        if pstm.orig^crncy^cde <> local^crncy^cde^g for                !05171i03
               $len( pstm.orig^crncy^cde ) then                        !05171i04
            begin                                                      !05171i05
            return pstm^resp^frmt^err^l;                               !05171i06
            end;                                                       !05171i07
        end;                                                           !05171i08
                                                                       !05171i09
                                                                       !05171L00
    if  not pstm^frmt^b24^to^pos^amt( pstm, sem ) then                 !05171L01
        return pstm^resp^frmt^err^l;                                   !05171L02
                                                                       !05171L03
                                                                       !05172L00
                                                                       !05172L01
                                                                       !05172L02
                                                                       !K0517400
    set( comb^xlate^mac^generate^g, false );                           !K0517401
                                                                       !K0517402
!@==================================================================!
!@ BEGIN  * RPQ   Kirk emergency fix #1   ***  2011-03-24 KW Patch. !
!@------------------------------------------------------------------!
--                                                                     ! RPQ
    set( comb^xlate^mac^generate^g, false );                           ! RPQ
--                                                                     ! RPQ
!@------------------------------------------------------------------!
!@ END    * RPQ   Kirk emergency fix #1   ***  2011-03-24 KW Patch. !
!@==================================================================!
                                                                       !05174K00
    call hiswutil^extract^track2^info( pstm.tran.track2,               !05174K01
                                       $len( pstm.tran.track2 ),       !05174K02
                                       pan, pan^lgth );                !05174K03
                                                                       !05174K04
                                                                       !05174K05
                                                                       !05174-00
    if ( pstm.pin^size = "00" ) and ( pstm.pin^tries = "Z" ) then      !05174-01
        begin                                                          !05174-02
                                                                       !D0517400
        psem.pin.byte[0] ':=' prevrfy^pin^pad^char^g for 1 &           !D0517401
                              psem.pin.byte[0] for                     !D0517402
                              $len( psem.pin ) - 1;                    !D0517403
                                                                       !D0517404
                                                                       !D0517405
                                                                       !D0517406
        end                                                            !05174-04
    else                                                               !05174-05
                                                                       !05174-06
    if  ( pstm.pin^size <> "00" ) and ( pstm.pin^tries <> "Z" ) then   !05175
                                                                       !05176
        ! The pin must be passed to the co-network                    !!05177
                                                                       !05178
        begin                                                          !05179
                                                                       !05179K00
        set( comb^xlate^mac^generate^g, false );                       !05179K01
        if pct.mac.mac^typ =     "1" and                               !05179K02
           pct.pin.out^blk =     "1" and                               !05179K03
                                                                       !05179a00
           ( pstm.originator <=    "2" or                              !05179a01
             pstm.originator = "9" ) and                               !05179a02
                                                                       !05179a03
                                                                       !05179a04
                                                                       !05179a05
           int^pan^eql^ext^pan       and                               !05179K05
           ( pstm.pin^frmt = "1"     or                                !05179K06
             pstm.pin^frmt = "3" )   then                              !05179K07
            begin                                                      !05179K08
            call hexchar^binaryx( psem.pri^bit^map, 16,                !05179K09
                                  bit^map[ 0 ] );                      !05179K0A
            call hexchar^binaryx( psem.secndry^bit^map, 16,            !05179K0B
                                  bit^map[ 4 ] );                      !05179K0C
            if ( testbit( bit^map, 0 )     and                         !05179K0D
                 testbit( bit^map, 127 ) ) or                          !05179K0E
               ( not testbit( bit^map, 0 ) and                         !05179K0F
                 testbit( bit^map, 63 ) )  then                        !05179K0G
                set( comb^xlate^mac^generate^g, true );                !05179K0H
            end;                                                       !05179K0I
                                                                       !05179K0J
        if not comb^xlate^mac^generate^g then                          !05179K0K
            begin                                                      !05179K0L
            call ascii^integer^( pstm.pin^size, ipin^lgth );           !05179K0M
                                                                       !05179K0N
            if not util^frmt^int^pin^to^ext^pin( psem.pin, epin^lgth,  !05179K0O
                   pan, pan^lgth, pstm.pin, ipin^lgth, pstm.pin^key,   !05179K0P
                   pstm.pin^frmt, pstm.ansi^ofst, pstm.pinpad^char,    !05179K0Q
                   pstm.originator, pstm.user^key, sec^dev^resp ) then !05179K0R
                begin                                                  !05179K0S
                if sec^dev^resp = sanity^chk^err^l and                 !05179K0T
                                                                       !05179U00
                   base24^rel^g >= 5 then                              !05179U01
                                                                       !05179U02
                    begin                                              !05179K0V
                    movd( err^flg, "S" );                              !05179K0W
                    call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,  !05179K0X
                                               pstm^lgth^d( pstm ),    !05179K0Y
                                               false,, pstm.data^flag, !05179K0Z
                                               err^flg );              !05179K10
                    end;                                               !05179K11
                return pstm^resp^unable^to^auth^l;                     !05179K12
                end;                                                   !05179K13
            end;                                                       !05179K14
                                                                       !05179K15
                                                                       !05180K00
                                                                       !05180K01
                                                                       !05180K02
        end;                                                           !05189
                                                                       !05190
                                                                       !05191L00
                                                                       !05191L01
                                                                       !05191L02
                                                                       !05194
    if  pstm^adjustments^d( pstm )  then                               !05195
        begin                                                          !05196
                                                                       !05197L00
                                                                       !05197L01
                                                                       !05197L02
                                                                       !05199
                                                                       !05200L00
                                                                       !05200L01
                                                                       !05200L02
                                                                       !05202
        use i; i := -1;                                                !05203
        while pstm^adj^code^d( i := i + 1 ) and pstm.rvsl^cde <>       !05204
            pstm^adj^code^d( i ) for $len( pstm.rvsl^cde ) do;         !05205
                                                                       !05206
        if  not pstm^adj^code^d ( i )  then                            !05207
            movd ( psem.resp^cde, "00" )                               !05208
        else                                                           !05209
            movl( psem.resp^cde, sem^adj^code^d( i ),                  !05210
                $len( psem.resp^cde ) );                               !05211
        drop i;                                                        !05212
        end;                                                           !05213
                                                                       !05214
                                                                       !05214K00
    if tkn^name^g <> invalid^name^d and                                !05214K01
                                                                       !05214U00
       base24^rel^g >= 5 then                                          !05214U01
                                                                       !05214U02
        begin                                                          !05214K03
        if pstm.data^flag = "0" then                                   !05214K04
            movd( userdata, false )                                    !05214K05
        else                                                           !05214K06
            movd( userdata, true );                                    !05214K07
                                                                       !05214K08
        if pstm.addr^typ = av^addr^typ^d then                          !05214K09
            begin                                                      !05214K0A
            !!                                                         !05214K0B
            !Add address verification token to PSTM.!                  !05214K0C
            !!                                                         !05214K0D
            init( addr^ver^tkn, "  ",  wlen( addr^ver^tkn ) );         !05214K0E
            mov^( addr^ver^tkn.addr,    pstm.addr^flds.addr );         !05214K0F
            mov^( addr^ver^tkn.zip^cde, pstm.zip^cde        );         !05214K0G
            movd( tkn^id,    addr^ver^tkn^id^d );                      !05214K0H
                                                                       !05214K0I
            if ( error := tkn^add^info( pstm, pstm^lgth^d( pstm ),     !05214K0J
                                  intrn^msg^lmt^l, tkn^id,             !05214K0K
                                  addr^ver^tkn,                        !05214K0L
                                  $len( addr^ver^tkn ),,,,,            !05214K0M
                                  userdata ) ) <> compl^no^err^l then  !05214K0N
                begin                                                  !05214K0O
                if error = over^max^limit^l then                       !05214K0P
                    call logmessage^( 1210,, @no^room, net.myname,     !05214K0Q
                                      2, @pos^prod^g, @tkn^id )        !05214K0R
                else                                                   !05214K0S
                    begin                                              !05214K0T
                    call logmessage^( 1215,, @add^err, net.myname,     !05214K0U
                                      3, @pos^prod^g, @tkn^id );       !05214K0V
                    call abend^( 2200 );                               !05214K0W
                    end                                                !05214K0X
                end;                                                   !05214K0Y
            end;                                                       !05214K0Z

!**********************************************************************
! BEGIN RPQ #BE002 - Bolsillo Electronico Eliminacion RPQ
!**********************************************************************
!**********************************************************************
! BEGIN RPQ #BE001 - Bolsillo Electronico
!**********************************************************************
!   if pstm.pt^srv^entry^mde.byte[0] = "011" and     !! P-22 Billetera Elec.
!      pstm.pt^srv^cond^cde.byte[0]  = "00"    then  !! P-25
!      Begin
!       psem.entry^mde.byte[0] ':=' "017";
!       tkn^id ':=' ps51^tkn^id^d;
!       if hiswtkn^get^tkn( pstm, tkn^id, @ps51^get^tkn,
!                           ps51^get^lgth ) then
!          begin
!           ps51^get^tkn.cvd^fld.byte[0] ':=' "XXX ";
!           ps51^get^tkn.e^com^flg       ':=' "7";
!           psem.pt^tran^spcl^cde.byte[0] ':=' "59";  !! P-25
!          end
!       else
!        Begin
!         psem.pt^tran^spcl^cde.byte[0] ':=' "59";    !! P-25
!         init( ps51^get^tkn, "  ",   wlen( ps51^get^tkn ) );
!               ps51^get^tkn.cvd^fld.byte[0] ':=' "XXX ";
!               ps51^get^tkn.e^com^flg       ':=' "7";
!               ps51^get^tkn.cmrcl^crd^typ   ':=' "0";
!               ps51^get^tkn.cvd^fld^present ':=' "0";
!
!               error := 0;
!               if ( error := tkn^add^info( pstm,  pstm^lgth^d( pstm ),
!                                           intrn^msg^lmt^l, tkn^id,
!                                           ps51^get^tkn,
!                                           $len( ps51^get^tkn ),,,,,
!                                                     userdata ) )   then
!                  begin
!                   if error = over^max^limit^l then
!                      begin
!                       call logmessage^( 1216,, @no^room,
!                                         net.myname,
!                                         evt^msg^severity^err^l,
!                                         @pos^prod^g, @tkn^id );
!                       end  !!of over limit error
!                   else
!                    begin
!                     call logmessage^( 1217, , @add^err, net.myname,
!                                       evt^msg^severity^crit^l,
!                                       @pos^prod^g, @tkn^id );
!                    end;!! of other token error
!                  end;!! if error
!              End;!! else if tkn get
!            End; !! if caso bolsillo
!**********************************************************************
! END   RPQ #BE001 - Bolsillo Electronico
!**********************************************************************
!**********************************************************************
! END   RPQ #BE002 - Bolsillo Electronico Elinacion RPQ
!**********************************************************************
!********************************************************************!
!* BEGIN RPQ #RECU -                                                *!
!********************************************************************!
    tkn^id ':=' ps51^tkn^id^d;
    if hiswtkn^get^tkn( pstm, tkn^id, @ps51^tkn^ptr,
                        tkn^lgth ) then
       begin
!*******************************************************************
! BEGIN #REC1
!*******************************************************************
        if pstm.pt^srv^entry^mde.byte[0] = "01" and
           pstm.pt^srv^cond^cde          = "08" and
           ps51^tkn^ptr.e^com^flg        = "1"   then
           begin
             movd( psem.entry^mde, "016" );
           end;
!********************************************************************
! END   #REC1
!********************************************************************
        if pstm.pt^srv^entry^mde.byte[0] = "01" and
           pstm.pt^srv^cond^cde          = "08" and
           ps51^tkn^ptr.e^com^flg        = "2"   then
           begin
            hay^tkn^ch := false;
            tkn^id ':=' pos^data1^tkn^id^d;
            if hiswtkn^get^tkn( pstm, tkn^id, @pos^data1^tkn^ptr,
                                tkn^lgth ) then
               begin
                hay^tkn^ch := true;
                pos^data1^tkn^ptr.recur^pmnt^ind ':=' "R";
               end;
            if not hay^tkn^ch then
               begin
!               tkn^ofst := $offset( pstm.srvcs[0] ) +
!                   $min( ( $len( pstm.srvcs[0] ) * pstm.num^services ),
!                   ( $len( pstm.srvcs[0] ) * $occurs( pstm.srvcs )));
!
!               if  pstm.data^flag <> "0" then
!                    userdata := true
!               else
!                 userdata := false;
!               pos^data1^tkn ':=' (( $len( pos^data1^tkn  )) / 2 )
!                                           * ["  "];
!               pos^data1^tkn.recur^pmnt^ind ':=' "R";
!               tkn^result := tkn^add^info( pstm, tkn^ofst,
!                                   intrn^msg^lmt^l, tkn^id,
!                                   pos^data1^tkn,
!                                   $len( pos^data1^tkn ),,
!                                   tkn^lgth,,,
!                                   userdata);
!               if tkn^result <> compl^no^err^l  then
!                  begin
!                   return true;
!                  end;
               end; ! Si hay tkn CH
           end;
        end;
!********************************************************************!
!* END   RPQ #RECU -                                                *!
!********************************************************************!
!*********************************************************************!
!* BEGIN RPQ #VT - Verificacion de Tarjetas                    -     *!
!*********************************************************************!
   if  pstm.tran.tran^cde.tc = "16" then
       begin
         movd( psem.entry^mde, "017" );
       end;
!*********************************************************************!
!* END   RPQ #VT - Verificacion de Tarjetas                    -     *!
!*********************************************************************!
                                                                       !O0521400
        if ( pstm.pre^auth^opt = "P" or                                !O0521401
             pstm.pre^auth^opt = "p" or                                !O0521402
             pstm.pre^auth^opt = "G" or                                !O0521403
             pstm.pre^auth^opt = "g" ) and                             !O0521404
           psem.setl^crncy =                                           !O0521405
                 [ $len( psem.setl^crncy ) * [ " " ] ] then            !O0521406
            begin                                                      !O0521407
            tkn^id ':=' pos^data1^tkn^id^d;                            !O0521408
            if hiswtkn^get^tkn( pstm,                                  !O0521409
                                tkn^id,                                !O052140A
                                @pos^data1^tkn^ptr,                    !O052140B
                                pos^data1^lgth ) then                  !O052140C
                begin                                                  !O052140D
                move( pos^data1^tkn^ptr.partial^auth^opt,              !O052140E
                      pstm.pre^auth^opt  );                            !O052140F
                end                                                    !O052140G
            else                                                       !O052140H
                begin                                                  !O052140I
                init( pos^data1^tkn, "  ",   wlen( pos^data1^tkn ) );  !O052140J
                pos^data1^tkn.online^lmt := 0f;                        !O052140K
                move( pos^data1^tkn.partial^auth^opt,                  !O052140L
                      pstm.pre^auth^opt  );                            !O052140M
                error := 0;                                            !O052140N
                if ( error := tkn^add^info( pstm,                      !O052140O
                                            pstm^lgth^d( pstm ),       !O052140P
                                            intrn^msg^lmt^l,           !O052140Q
                                            tkn^id,                    !O052140R
                                            pos^data1^tkn,             !O052140S
                                            $len( pos^data1^tkn ),     !O052140T
                                            ! tkn^buf^size^l !,        !O052140U
                                            ! tkn^lgth !,              !O052140V
                                            ! dspy^flg !,              !O052140W
                                            ! ebcdic^flg !,            !O052140X
                                            userdata ) )               !O052140Y
                                                                then   !O052140Z
                    begin                                              !O052140a
                    if error = over^max^limit^l then                   !O052140b
                        begin                                          !O052140c
                        movd( err^flg, "T" );                          !O052140d
                        call hiswtkn^set^ps50^tkn( pstm,               !O052140e
                                                   intrn^msg^lmt^l,    !O052140f
                                                   pstm^lgth^d( pstm ),
                                                   false,              !O052140i
                                                   ! tkn_lgth !,       !O052140j
                                                   pstm.data^flag,     !O052140k
                                                   err^flg );          !O052140l
                        call logmessage^( 1216,                        !O052140m
                                          ! pos^id^cde^g !,            !O052140n
                                          @no^room,                    !O052140o
                                          net.myname,                  !O052140p
                                          evt^msg^severity^err^l,      !O052140q
                                          @pos^prod^g,                 !O052140r
                                          @tkn^id );                   !O052140s
                        end  ! of over limit error                    !!O052140t
                    else                                               !O052140u
                        begin                                          !O052140v
                        call logmessage^( 1217,                        !O052140w
                                          ! pos^id^cde^g !,            !O052140x
                                          @add^err,                    !O052140y
                                          net.myname,                  !O052140z
                                          evt^msg^severity^crit^l,     !O0521410
                                          @pos^prod^g,                 !O0521411
                                          @tkn^id );                   !O0521412
                        call abend^ ( 2201 );                          !O0521413
                        end; ! of other token error                   !!O0521414
                    end; ! of token error                             !!O0521415
                end; ! of add pos data1 token                         !!O0521416
            end; ! of pre auth opt = "P"                              !!O0521417
                                                                       !O0521418
                                                                       !O0521419
        if not pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp ) then     !05214K11
            begin                                                      !05214K12
            movd( err^flg, tkn^err^flg^d );                            !05214K13
            call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,          !05214K14
                                       pstm^lgth^d( pstm ), false,,    !05214K15
                                       pstm.data^flag, err^flg );      !05214K16
            set( tkn^frmt^err, pstm^resp^frmt^err^l );                 !05214K17
            end;                                                       !05214K18
        !!                                                             !05214K19
        !delete the address verification token from the PSTM.!         !05214K1A
        !!                                                             !05214K1B
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !05214K1C
                               intrn^msg^lmt^l,                        !05214K1D
                               tkn^id,,, userdata );                   !05214K1E
                                                                       !05214K1F
        if error <> compl^no^err^l       and                           !05214K1G
           error <> tkn^does^not^exist^l then                          !05214K1H
            begin                                                      !05214K1I
            call logmessage^( 1220,, @del^err, net.myname,             !05214K1J
                              3, @pos^prod^g, @tkn^id );               !05214K1K
            call abend^( 2300 );                                       !05214K1L
            end;                                                       !05214K1M
        end;                                                           !05214K1N
                                                                       !05214K1O
    if tkn^frmt^err then                                               !05214K1P
        return tkn^frmt^err                                            !05214K1Q
    else                                                               !05214K1R
        return pstm^resp^no^err^l;                                     !05214K1S
                                                                       !05214K1T
                                                                       !05215K00
                                                                       !05215K01
    end;                                                               !05216
?section pstm^frmt^b24^to^pos^0210                                     !05217
?page "                               - pstm^frmt^b24^to^pos^0210"     !05217K00
                                                                       !05220
!#####################################################################!!05221
!#                                                                   #!!05222
!#                     PSTM^FRMT^B24^TO^POS^0210                     #!!05223
!#                                                                   #!!05224
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0210 PSTM TO AN EXTERNAL  #!!05225
!#       0210 RESPONSE MESSAGE.                                      #!!05226
!#                                                                   #!!05227
!#    INPUT PARAMETERS:                                              #!!05228
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!05229
!#                                                                   #!!05230
!#    OUTPUT PARAMETERS:                                             #!!05231
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05232
!#                                                                   #!!05233
!#####################################################################!!05234
int proc pstm^frmt^b24^to^pos^0210( pstm, sem );                       !05235
struct  .pstm( pstm^def );                                             !05236
struct  .sem(  sem^def  );                                             !05237
    begin                                                              !05238
    wlform( invalid,                                                   !05239
        "INVALID Response Code \\\ Received from BASE24-pos" )         !05240
                                                                       !05240K00
    wlform( get^err, "Error while attempting to get token \\ -" ','    !05240K01
            " Tran \\\\\\\\\\\\, Card \\\\\\\\\\\\\\\\\\\ " )          !05240K02
    wlform( del^err,                                                   !05240K03
        "Error while attempting to delete token \\ from the PSTM " )   !05240K04
    wlform( add^err, "Error while attempting to add token \\ " )       !05240K05
    wlform( no^room, "Unable to add token \\, no room available " )    !05240K06
                                                                       !05240K07
!*==================================================================*!
!   BEGIN RPQ #25 - Bill Payment                       MCD / 2269    !
!--------------------------------------------------------------------!
    wlform( conv^err, "Error while converting fixed to ascii ")
    wlform( tkn^get^err,  "Error while attemptimg to get token \\ ")
!--------------------------------------------------------------------!
!   END   RPQ #25 - Bill Payment                       MCD / 2269    !
!*==================================================================*!
                                                                       !05241
    define  pstm^code^d( i )  =  resp^tbl[ ( i ) * 5 + 0 ] #,          !05242
            sem^code^d( i )  =  resp^tbl[ ( i ) * 5 + 3 ] #;           !05243
                                                                       !05244
    string  resp^tbl  = 'P' :=  [                                      !05245
        !                                                             !!05246
        ! PSTM      BIC ISO                                           !!05247
        ! Codes     Codes                                             !!05248
        !  .         .                                                !!05249
        !  .         .                                                !!05250
        !  v         v                                                !!05251
         "000",     "00",  ! approved - balance avail                 !!05252
         "001",     "00",  ! approved - balance unavail               !!05253
         "002",     "76",  ! approved - private cntry club            !!05254
         "003",     "08",  ! approved - honour with identification    !!05255
         "004",     "77",  ! approved - pending identification        !!05256
         "005",     "78",  ! approved - blind                         !!05257
         "006",     "11",  ! approved - vip                           !!05258
         "007",     "79",  ! approved - admin tran                    !!05259
         "008",     "80",  ! approved - National Neg hit okay         !!05260
         "009",     "81",  ! approved - commericial                   !!05261
         "050",     "05",   ! unauthorized usage                      !!05262
         "051",     "54",   ! expired card                            !!05263
         "052",     "75",   ! pin tries exceeded                      !!05264
         "053",     "31",   ! no sharing                              !!05265
         "054",     "82",   ! private, no security box                !!05266
         "055",     "12",   ! invalid transaction                     !!05267
         "056",     "57",   ! tran not permitted                      !!05268
         "057",     "41",   ! lost card                               !!05269
         "058",     "14",   ! invalid card number                     !!05270
         "059",     "62",   ! restricted card                         !!05271
         "060",     "83",   ! private (no accounts)                   !!05272
         "061",     "84",   ! no pbf                                  !!05273
         "062",     "85",   ! pbf update error                        !!05274
         "063",     "86",   ! invalid auth type                       !!05275
         "064",     "87",   ! bad track2                              !!05276
         "065",     "12",   ! invalid tranx                           !!05277
         "066",     "T1",   ! invalid amount                          !!05278
         "067",     "T2",   ! format error                            !!05279
         "068",     "88",   ! private ptlf error                      !!05280
         "069",     "30",   ! format error                            !!05281
         "070",     "15",   ! no idf                                  !!05282
                                                                       !J0528300
                                                                       !J0528301
         "072",     "R8",   ! private card on NATION NEG FILE         !!05284
         "073",     "89",   ! invalid route service                   !!05285
         "074",     "N0",   ! unable to authorize                     !!05286
         "075",     "N1",   ! invalid pan length                      !!05287
         "076",     "51",   ! not sufficient fund                     !!05288
         "077",     "N2",   ! pre auth full                           !!05289
         "078",     "94",   ! duplicate transaction                   !!05290
         "079",     "N3",   ! private max online refund reached       !!05291
         "080",     "N4",   ! private max offline refund reached      !!05292
         "081",     "N5",   ! private max credit per refund           !!05293
         "082",     "65",   ! exceeds withdrawal frequency limit      !!05294
         "083",     "N6",   ! max refund credit reached               !!05295
         "084",     "N7",   ! customer selected neg reason            !!05296
         "085",     "57",   ! transaction not permitted to cardholder !!05297
         "086",     "N8",   ! overfloor limit                         !!05298
         "087",     "N9",   ! max number of refund credit             !!05299
         "088",     "01",   ! refer to card issuer                    !!05300
         "089",     "T5",   ! caf status inactive or closed ( 0-9 )   !!05301
                                                                       !J0530200
         "090",     "O0",   ! referral file full                      !!J0530201
                                                                       !J0530202
         "091",     "O1",   ! neg file problem                        !!05303
         "092",     "O2",   ! advance less than min                   !!05304
         "093",     "O3",   ! delinquent                              !!05305
         "094",     "O4",   ! over limit table                        !!05306
         "095",     "61",   ! exceeds withdrawal amt. limit           !!05307
         "096",     "O5",   ! private pin required                    !!05308
         "097",     "O6",   ! mod 10 check                            !!05309
         "098",     "O7",   ! force post                              !!05310
         "099",     "O8",   ! bad pbf                                 !!05311
         "100",     "06",   ! unable to process tranx.                !!05312
                                                                       !05313&00
         "101",     "01",   ! Refer to card issuer                    !!05313&01
                                                                       !05313&02
         "102",     "02",   ! refer to card issuer special condition  !!05314
         "103",     "O9",   ! neg file problem                        !!05315
         "104",     "P0",   ! caf file problem                        !!05316
         "105",     "T3",   ! no card record                          !!05317
         "106",     "T4",   ! invalid amount                          !!05318
         "107",     "P1",   ! over daily limit                        !!05319
         "108",     "P2",   ! capf no found                           !!05320
         "109",     "P3",   ! advance less than min                   !!05321
         "110",     "P4",   ! num of times used exceeded              !!05322
         "111",     "P5",   ! delinquent                              !!05323
         "112",     "P6",   ! over limit table                        !!05324
         "113",     "68",   ! response recieved to late               !!05325
         "115",     "S4",   ! ptlf is full                            !!05326
         "120",     "T6",   ! bad uaf                                 !!05327
         "121",     "S8",   ! Admin file error                        !!05328
         "122",     "S9",   ! security device error                   !!05329
                                                                       !05329T00
         "130",     "01",   ! ARQC Failure                           ! !05329T01
         "131",     "01",   ! CVR Referral                           ! !05329T02
         "132",     "01",   ! TVR Referral                           ! !05329T03
         "133",     "01",   ! Reason on-Line Referral                ! !05329T04
         "134",     "01",   ! Fallback Referral                      ! !05329T05
                                                                       !05329T06
!********************************************************************!
!     BEGIN RPQ #25A- Bill Payment                                   !
!--------------------------------------------------------------------!
         "135",     "B6",   ! TLCD expired subscription
         "136",     "B7",   ! TLCD invalid document number
         "137",     "B8",   ! TLCD file failure
         "138",     "B9",   ! VEND record missing
!--------------------------------------------------------------------!
!     END   RPQ #25A- Bill Payment                                   !
!********************************************************************!

         "150",     "03",   ! invalid merchant                        !!05330
         "200",     "T8",   ! error, account problem                  !!05331
         "201",     "55",   ! incorrect pin                           !!05332
         "202",     "P7",   ! advance less amount                     !!05333
         "203",     "P8",   ! admin card needed                       !!05334
         "204",     "P9",   ! enter lesser amount                     !!05335
         "205",     "13",   ! invalid amount                          !!05336
         "206",     "56",   ! caf not found                           !!05337
         "207",     "Q0",   ! invalid tran date                       !!05338
         "208",     "Q1",   ! invalid expiration date                 !!05339
         "209",     "Q2",   ! invalid trancode                        !!05340
                                                                       !05340M00
         "251",     "T7",   ! reserved for private use!                !05340M01

!====================================================================!
! BEGIN RPQ #ID001 - Manejo Especial Campo P42                       !
!--------------------------------------------------------------------!
         "254",     "M2",   ! INVALID DOCUMENT NUMBER
         "255",     "87",   ! CVV2 Invalid
!--------------------------------------------------------------------!
! END   RPQ #ID001 - Manejo Especial Campo P42                       !
!====================================================================!
                                                                       !05340T00
         "400",     "05",   ! ARQC Failure                           ! !05340T01
         "401",     "05",   ! HSM Parameter Error                    ! !05340T02
         "402",     "05",   ! HSM Failure                            ! !05340T03
         "403",     "05",   ! KEYI Record Not Found                  ! !05340T04
         "404",     "05",   ! ATC Check Failure                      ! !05340T05
         "405",     "05",   ! CVR Decline                            ! !05340T06
         "406",     "05",   ! TVR Decline                            ! !05340T07
         "407",     "05",   ! Reason On-Line Decline                 ! !05340T08
         "408",     "05",   ! Fallback Decline                       ! !05340T09
                                                                       !05340T0A
                                                                       !05340M02
         "900",     "38",   ! allowable PIN tries exceeded            !!05341
         "901",     "33",   ! expired card                            !!05342
         "902",     "36",   ! restricted card                         !!05343
         "903",     "43",   ! stolen card                             !!05344
         "904",     "Q3",   ! advance less than min                   !!05345
         "905",     "Q4",   ! number of times used exceeded           !!05346
         "906",     "Q5",   ! delinquent                              !!05347
         "907",     "Q6",   ! over limit table                        !!05348
         "908",     "Q7",   ! amount over max                         !!05349
                                                                       !05349K00
         "909",     "04",   ! capture!                                 !05349K01
                                                                       !05349T00
         "910",     "04",   ! ARQC Failure                           ! !05349T01
         "911",     "04",   ! CVR Capture                            ! !05349T02
         "912",     "04",   ! TVR Capture                            ! !05349T03
                                                                       !05349T04
                                                                       !05349K02
                                                                       !05350K00
                                                                       !05350K01
         "950",     "Q8",   ! admin card not found                    !!05351
         "951",     "Q9",   ! admin card not allowed                  !!05352
         "952",     "R0",   ! approved admin request in window        !!05353
         "953",     "R1",   ! approved admin request out window       !!05354
         "954",     "R2",   ! approved admin request anytime          !!05355
         "955",     "R3",   ! chargeback customer file updated        !!05356
         "956",     "R4",   ! chargeback cust.file updated acqr.not fo!!05357
         "957",     "R5",   ! chargeback incorrect prefix number      !!05358
         "958",     "R6",   ! chargeback incorrect rsp code or cpf con!!05359
         "959",     "R7",   ! admin transactions not supported        !!05360
         "960",     "S5",   ! approved, customer files not updated    !!05361
         "961",     "S6",   ! approved, files not updated Acq. not fou!!05362
         "962",     "S7",   ! accepted, incorrect destination         !!05363

!*===================================================================!
!@ BEGIN RPQ #220 Special Response Code for Time Out/Line Down
!--------------------------------------------------------------------!
         "963",     "90",   ! line down
!@ END   RPQ #220 Special Response Code for Time Out/Line Down
!*==================================================================*!
!@ BEGIN RPQ #240 Special Response Code for Invalid MAC
         "964",     "93",   ! invalid mac error
!--------------------------------------------------------------------!
!@ END   RPQ #240 Special Response Code for Invalid MAC
!*==================================================================*!

            0 ];   !end of resp^tbl                                   !!05364
                                                                       !05365
                                                                       !05365K00
    struct                                                             !05365K01
            .addr^ver^tkn( addr^ver^tkn^def ),                         !05365K02
            .tkn^data( ps50^tkn^def ),                                 !05365K03

!*===================================================================*!
!   BEGIN RPQ #25 - Bill Payment                  MCD / 2269          !
!---------------------------------------------------------------------!
           .rpq^bill^pymt^buf( rpq^bill^pymt^tkn^def ),
!---------------------------------------------------------------------!
!   END   RPQ #25 - Bill Payment                  MCD / 2269          !
!*====================================================================!

            .tkn^mem^rec( tkn^mem^rec^def );                           !05365K04
                                                                       !05365K05
    int                                                                !05365K06
             error,                                                    !05365K07

!*===================================================================*!
!   BEGIN RPQ #25 - Bill Payment                  MCD / 2269          !
!---------------------------------------------------------------------!
            pstm^flag,
            tkn^util^val,
            txt^lgth,
            rpq^bill^pymt^tkn^lgth,
            stat,
!---------------------------------------------------------------------!
!   END   RPQ #25 - Bill Payment                  MCD / 2269          !
!*===================================================================*!

             tkn^lgth,                                                 !05365K08
             userdata;                                                 !05365K09
                                                                       !05365K0A
    string                                                             !05365K0B

!*===================================================================*!
!   BEGIN RPQ #25 - Bill Payment                  MCD / 2269          !
!---------------------------------------------------------------------!
            .tkn^id^d[0:1],
            .blnk^string[0:99] := [100* [" "] ],
!---------------------------------------------------------------------!
!   END   RPQ #25 - Bill Payment                  MCD / 2269          !
!*===================================================================*!

             err^flg,                                                  !05365K0C
            .tkn^id[ 0:1 ],                                            !05365K0D
            .tkn^grp[ 0:3 ];                                           !05365K0E
                                                                       !O0536500
    fixed    psem^fixed^tran^amt := 0f;                                !O0536501
                                                                       !O0536502
                                                                       !05365K0G
    if  psem.typ = auth^request^d then                                 !05366
        begin                                                          !05367
        movd( psem.typ,                   auth^response^d        );    !05368
        mov^( psem.pri^bit^map,           pos.p0110.pbit^map     );    !05369
        mov^( psem.secndry^bit^map,       pos.p0110.sbit^map     );    !05370
                                                                       !05370K00
        movl( tkn^grp, pos.p0110.tkn^grp, $occurs( tkn^grp )     );    !05370K01
                                                                       !05370K02
        end                                                            !05371
    else                                                               !05372
        begin                                                          !05373
        movd ( psem.typ,                   tran^response^d       );    !05374
        mov^ ( psem.pri^bit^map,           pos.p0210.pbit^map    );    !05375
        mov^ ( psem.secndry^bit^map,       pos.p0210.sbit^map    );    !05376
                                                                       !05376K00
        movl( tkn^grp, pos.p0210.tkn^grp,  $occurs( tkn^grp )    );    !05376K01
                                                                       !05376K02
        end;                                                           !05377
                                                                       !05378
    if  not pstm^frmt^b24^to^pos^acct( pstm, sem ) then                !05379
        return false;                                                  !05380
                                                                       !05381
    mov^ ( psem.xmit^dat^tim,                 zeroes             );    !05382
    move ( psem.responder,                    pstm.responder     );    !05383
    movd ( psem.pri^rsrvd2^prvt.len,          "019"              );    !05384
    move ( psem.pri^rsrvd2^prvt.pos.crd^ln,   pstm.tran.crd^ln   );    !05385
    move ( psem.pri^rsrvd2^prvt.pos.crd^fiid, pstm.tran.crd^fiid );    !05386
    move ( psem.pri^rsrvd2^prvt.pos.category, pstm.tran.tran^cde.c  ); !05387
    move ( psem.pri^rsrvd2^prvt.pos.save^acct^typ,                     !05388
        pstm.tran.save^acct^typ );                                     !05389
    move ( psem.pri^rsrvd2^prvt.pos.ichg^resp, pstm.tran.ichg^resp );  !05390
    mov^ ( ssem.secndry^rsrvd3^prvt.len,      zeroes             );    !05391
    mov^ ( psem.setl^dat,                     pstm.post^dat.mm   );    !05392
                                                                       !05393
                                                                       !05393)00
    if pstm.tran.mbr^num <> zeroes for $len( pstm.tran.mbr^num ) and   !05393)01
       pstm.tran.mbr^num <> blanks for $len( pstm.tran.mbr^num ) then  !05393)02
        begin                                                          !05393)03
        psem.mbr^num ':=' pstm.tran.mbr^num for                        !05393)04
                              $len( pstm.tran.mbr^num );               !05393)05
        end;                                                           !05393)06
                                                                       !05393)07
    call util^frmt^inst^id( pstm.crd^iss^id^num,                       !05394
        ssem.secndry^rsrvd3^prvt.len.byte[1],                          !05395
        ssem.secndry^rsrvd3^prvt.b24.crd^iss^id^num, 0 );              !05396
                                                                       !05397
    call util^frmt^inst^id( pstm.rcv^inst^id^num,                      !05398
        ssem.rcv^inst.len, ssem.rcv^inst.id^num, 0 );                  !05399
                                                                       !05399j00
    if ovrrd^rcv^inst^id^d then                                        !05399j01
        begin                                                          !05399j02
        !                                                             !!05399j03
        ! Move pct.swi^id (right justified, zero filled) into         !!05399j04
        ! ssem.rcv^inst^id^num, (left justified, blank filled)        !!05399j05
        !                                                             !!05399j06
        call util^frmt^inst^id( pct.swi^id,                            !05399j07
                                ssem.rcv^inst.len,                     !05399j08
                                ssem.rcv^inst.id^num,                  !05399j09
                                int^to^ext^l );                        !05399j0A
        end;                                                           !05399j0B
                                                                       !05399j0C
                                                                       !05400
!**********************************************************************
! BEGIN RPQ #AJGA - Ajuste GANO
!**********************************************************************
    if pstm.tran.apprv^cde = " GANO" then
       begin
        psem.auth^id^resp^len  := 6;
        psem.auth^id^resp     ':=' "*GANO*";
        pstm.tran.apprv^cde   ':=' "*GANO*";
       end
    else
    begin
    move ( psem.auth^id^resp^len,   pstm.tran.apprv^cde^lgth );        !05401
    move ( psem.auth^id^resp,       pstm.tran.apprv^cde      );        !05402
    end;
!**********************************************************************
! END   RPQ #AJGA - Ajuste GANO
!**********************************************************************
                                                                       !05403
                                                                       !05403M00
    if psem.proc^cde = "000000" then                                   !05403M01
       call pstm^frmt^b24^to^pos^tran( pstm, sem );                    !05403M02
                                                                       !05403M03
                                                                       !05403L00
    if  not pstm^frmt^b24^to^pos^amt( pstm, sem ) then                 !05403L01
        return false;                                                  !05403L02
                                                                       !05403L03
                                                                       !05404L00
                                                                       !05404L01
                                                                       !05404L02
    !                                                                 !!05410
    ! Convert the response codes                                      !!05411
    !                                                                 !!05412
    use i; i := -1;                                                    !05413
    while pstm^code^d( i:=i+1 ) and pstm.tran.resp^cde  <>             !05414
          pstm^code^d( i ) for 3 do;                                   !05415
                                                                       !05416
    if  not pstm^code^d( i ) then                                      !05417
        begin                                                          !05418
        call logmessage^( 1180,, @invalid, net.myname, 2,              !05419
            @pos^prod^g, @pstm.tran.resp^cde );                        !05420
        return false;                                                  !05421
        end;                                                           !05422
                                                                       !05423
    psem.resp^cde ':=' sem^code^d( i ) for $len( psem.resp^cde );      !05424
                                                                       !05425
    drop i;                                                            !05426
                                                                       !05426j00
    call pos^util^frmt^enhanced^rc( sem, pstm, int^to^ext^l );         !05426j01
                                                                       !05426j02
                                                                       !05427
                                                                       !O0542700
                                                                       !O0542701
    call ascii^fixed^( psem.tran^amt, psem^fixed^tran^amt );           !O0542702
                                                                       !O0542703
    if ( not pstm^inquiry^d( pstm ) ) and                              !O0542704
       psem^fixed^tran^amt <> pstm.tran.amt^1 and                      !O0542705
       ( pstm.pre^auth^opt <> "P" and                                  !O0542706
         pstm.pre^auth^opt <> "p" and                                  !O0542707
         pstm.pre^auth^opt <> "G" and                                  !O0542708
         pstm.pre^auth^opt <> "g"  ) and                               !O0542709
       pstm^approved^d( pstm ) then                                    !O054270A
        begin                                                          !O054270B
        return false;                                                  !O054270C
        end;                                                           !O054270D
                                                                       !O054270E
    if ( not pstm^inquiry^d( pstm ) )  and                             !O054270F
       psem^fixed^tran^amt <> pstm.tran.amt^1 and                      !O054270G
       ( pstm.pre^auth^opt = "P" or                                    !O054270H
         pstm.pre^auth^opt = "p" or                                    !O054270I
         pstm.pre^auth^opt = "G" or                                    !O054270J
         pstm.pre^auth^opt = "g" ) and                                 !O054270K
       pstm^approved^d( pstm ) then                                    !O054270L
        begin                                                          !O054270M
        call fixed^ascii^( psem.tran^amt, $abs( pstm.tran.amt^1 ) );   !O054270N
        if  pstm^cash^back^d( pstm ) or                                !O054270O
            pre^auth^cash^back^d( pstm ) then                          !O054270P
            begin                                                      !O054270Q
            call fixed^ascii^( psem.add^amts.b24^def.amt,              !O054270R
                               $abs( pstm.tran.amt^2 ) );              !O054270S
            end;                                                       !O054270T
        psem.resp^cde ':=' "10";                                       !O054270U
        end;                                                           !O054270V
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind,  pstm.rte.auth^ind );
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind2, pstm.auth^ind2    );
                                                                       !O054270a
                                                                       !05427D00
                                                                       !05427D01
                                                                       !05427K00
    if pstm.data^flag = "0" then                                       !05427K01
        movd( userdata, false )                                        !05427K02
    else                                                               !05427K03
        movd( userdata, true );                                        !05427K04
                                                                       !05427K05
                                                                       !05427K06
    !!                                                                 !05427D02
    ! Transfer address verification status!                            !05427D03
    !!                                                                 !05427D04
    if pstm.addr^typ = av^addr^typ^d then                              !05427D05
        begin                                                          !05427D06
        move( psem.resp^data.pos.addr^vrfy^stat,                       !05427D07
              pstm.addr^flds.addr^vrfy^stat );                         !05427D08
        movd( psem.resp^data.len, "02" );                              !05427D09
                                                                       !05427K07
                                                                       !05427K08
        !!                                                             !05427K09
        !Add address verification token to PSTM.!                      !05427K0A
        !!                                                             !05427K0B
        init( addr^ver^tkn, "  ",  wlen( addr^ver^tkn ) );             !05427K0C
        mov^( addr^ver^tkn.addr,    pstm.addr^flds.addr );             !05427K0D
        mov^( addr^ver^tkn.zip^cde, pstm.zip^cde        );             !05427K0E
        movd( tkn^id,    addr^ver^tkn^id^d );                          !05427K0F
                                                                       !05427K0G
        if ( error := tkn^add^info( pstm, pstm^lgth^d( pstm ),         !05427K0H
                                    intrn^msg^lmt^l, tkn^id,           !05427K0I
                                    addr^ver^tkn,                      !05427K0J
                                    $len( addr^ver^tkn ),,,,,          !05427K0K
                                    userdata )) <> compl^no^err^l then !05427K0L
            begin                                                      !05427K0M
            if error = over^max^limit^l then                           !05427K0N
                call logmessage^( 1222,, @no^room, net.myname,         !05427K0O
                                  2, @pos^prod^g, @tkn^id )            !05427K0P
            else                                                       !05427K0Q
                begin                                                  !05427K0R
                call logmessage^( 1223,, @add^err, net.myname,         !05427K0S
                                  3, @pos^prod^g, @tkn^id );           !05427K0T
                call abend^( 2350 );                                   !05427K0U
                end;                                                   !05427K0V
            end;                                                       !05427K0W
        end;                                                           !05427K0X
                                                                       !05427K0Y
                                                                       !05427K0Z
!*********************************************************************!
!    BEGIN RPQ #25 - Bill Payment                     MCD / 2269      !
!---------------------------------------------------------------------!
        if pstm.data^flag = "1" then
           pstm^flag := true
        else
           pstm^flag := false;
        tkn^id^d ':=' rpq^bill^pymt^tkn^id^d;
        error := tkn^get^info( pstm, pstm^lgth^d( pstm ),
                               intrn^msg^lmt^l,
                               tkn^id^d,
                               @rpq^bill^pymt^buf,
                               rpq^bill^pymt^tkn^lgth,,
                               pstm^flag);
        if ( pstm^inquiry^d( pstm ) or
             pstm^^purchase^d ) and
             error = compl^no^err^l then
           begin
           psem.pt^tran^spcl^cde ':=' "15";
           psem.crd^accpt^id^cde.byte[4] ':='
                                   rpq^bill^pymt^buf.merchant^id
                                   for 11;
           psem.pri^rsrvd1^natl.bill^pay^info.city^cde ':='
                  rpq^bill^pymt^buf.city^cde for
                  $len( rpq^bill^pymt^buf.city^cde);
           psem.pri^rsrvd1^natl.bill^pay^info.vendor^type ':='
                  rpq^bill^pymt^buf.vendor^type for
                  $len( rpq^bill^pymt^buf.vendor^type);
           psem.pri^rsrvd1^natl.bill^pay^info.merchant^id ':='
                  rpq^bill^pymt^buf.merchant^id for
                  $len( rpq^bill^pymt^buf.merchant^id);
           txt^lgth :=
               $len(psem.pri^rsrvd1^natl.bill^pay^info.amount);
           stat := fixed^ascii
                   (psem.pri^rsrvd1^natl.bill^pay^info.amount,
                    txt^lgth, rpq^bill^pymt^buf.amount);
           if not stat then
              begin
              call logmessage^(5004,,@conv^err,,3, @pos^prod^g);
              return false;
              end;

           psem.pri^rsrvd1^natl.bill^pay^info.invoice^num ':='
                  rpq^bill^pymt^buf.invoice^num for
                  $len( rpq^bill^pymt^buf.invoice^num);
           psem.pri^rsrvd1^natl.bill^pay^info.vendor^id ':='
                  rpq^bill^pymt^buf.vendor^id for
                  $len( rpq^bill^pymt^buf.vendor^id);
           psem.pri^rsrvd1^natl.bill^pay^info.due^date ':='
                  rpq^bill^pymt^buf.due^date for
                  $len( rpq^bill^pymt^buf.due^date);
           psem.pri^rsrvd1^natl.bill^pay^info.fax^num ':='
                  rpq^bill^pymt^buf.fax^num for
                  $len( rpq^bill^pymt^buf.fax^num);
           psem.pri^rsrvd1^natl.bill^pay^info.paid^flg :=
                  rpq^bill^pymt^buf.paid^flg;
           psem.add^data^prvt.pos.retl^id ':=' blnk^string for
                  $len( psem.add^data^prvt.pos.retl^id);
           psem.add^data^prvt.pos.retl^id ':='
                  rpq^bill^pymt^buf.merchant^id for
                  $len( rpq^bill^pymt^buf.merchant^id);
!*********************************************************************!
!* BEGIN RPQ #25A-Bill Payment                                       *!
!---------------------------------------------------------------------!
           psem.pri^rsrvd1^natl.bill^pay^info.telecode^number ':='
                  rpq^bill^pymt^buf.telecode^number for
                  $len( rpq^bill^pymt^buf.telecode^number );
           psem.pri^rsrvd1^natl.bill^pay^info.cvv2            ':='
                  rpq^bill^pymt^buf.cvv2 for
                  $len( rpq^bill^pymt^buf.cvv2 );

           psem.pri^rsrvd2^natl.bill^pay^info.cardholder^id   ':='
                  rpq^bill^pymt^buf.cardholder^id for
                  $len( rpq^bill^pymt^buf.cardholder^id );
!---------------------------------------------------------------------!
!* END   RPQ #25A-Bill Payment                                       *!
!*********************************************************************!
           end;

        if ( pstm^inquiry^d( pstm ) or
             pstm^^purchase^d) and
           ( error <> compl^no^err^l and
             error <> tkn^does^not^exist^l) then
           begin
           call logmessage^( 5005,,@tkn^get^err, net.myname,
                             3, @pos^prod^g, @tkn^id^d,
                             @psem.retrvl^ref^num, @psem.pan.data );
           call abend^( 2400 );
           end;
!---------------------------------------------------------------------!
!    END RPQ #25 - Bill Payment                          MCD / 2269   !
!*********************************************************************!

    movd( tkn^id, ps50^tkn^id^d );                                     !05427K10
    error := tkn^get^info( pstm, pstm^lgth^d( pstm ),                  !05427K11
                           intrn^msg^lmt^l, tkn^id, @tkn^data,         !05427K12
                           tkn^lgth,, userdata );                      !05427K13
    if error = compl^no^err^l and                                      !05427K14
       tkn^data.err^flg = "S" then                                     !05427K15
        begin                                                          !05427K16
        if pct.pin.pin^err^lmt > 0 then                                !05427K17
            begin                                                      !05427K18
            increment( pct.pin.in^err^cnt );                           !05427K19
            if pct.pin.in^err^cnt >                                    !05427K1A
               pct.pin.pin^err^lmt then                                !05427K1B
                begin                                                  !05427K1C
                if pct.options.num^keys = "1" then                     !05427K1D
                    call setbit( exchange^keys^g, pin^both^keys^l )    !05427K1E
                else                                                   !05427K1F
                    call setbit( exchange^keys^g, pin^in^key^l );      !05427K1G
                set( pct.pin.in^err^cnt,      0  );                    !05427K1H
                set( pct.pin.in^cons^err^cnt, 0  );                    !05427K1I
                set( pct.pin.in^key^tran^cnt, 0d );                    !05427K1J
                call util^timer^find( time^key^exchange^l,             !05427K1K
                                      sub^in^pin^l,,, true );          !05427K1L
                end;                                                   !05427K1M
            end;                                                       !05427K1N
                                                                       !05427K1O
        if pct.pin.cons^pin^err^lmt > 0 then                           !05427K1P
            begin                                                      !05427K1Q
            increment( pct.pin.in^cons^err^cnt );                      !05427K1R
            if pct.pin.in^cons^err^cnt >                               !05427K1S
               pct.pin.cons^pin^err^lmt then                           !05427K1T
                begin                                                  !05427K1U
                if pct.options.num^keys = "1" then                     !05427K1V
                    call setbit( exchange^keys^g, pin^both^keys^l )    !05427K1W
                else                                                   !05427K1X
                    call setbit( exchange^keys^g, pin^in^key^l );      !05427K1Y
                set( pct.pin.in^err^cnt,      0  );                    !05427K1Z
                set( pct.pin.in^cons^err^cnt, 0  );                    !05427K20
                set( pct.pin.in^key^tran^cnt, 0d );                    !05427K21
                call util^timer^find( time^key^exchange^l,             !05427K22
                                      sub^in^pin^l,,, true );          !05427K23
                end;                                                   !05427K24
            end;                                                       !05427K25
        end                                                            !05427K26
    else                                                               !05427K27
    if error = tkn^addr^o^b^l  or                                      !05427K28
       error = invalid^param^l then                                    !05427K29
        begin                                                          !05427K2A
        call logmessage^( 1225,, @get^err, net.myname, 3,              !05427K2B
                          @pos^prod^g, @tkn^id,                        !05427K2C
                          @psem.retrvl^ref^num, @psem.pan.data );      !05427K2D
        call abend^( 2400 );                                           !05427K2E
        end;                                                           !05427K2F
                                                                       !05427K2G
    if not pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp ) then         !05427K2H
        begin                                                          !05427K2I
        movd( err^flg, tkn^err^flg^d );                                !05427K2J
        call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,              !05427K2K
                                   pstm^lgth^d( pstm ), false,,        !05427K2L
                                   pstm.data^flag, err^flg );          !05427K2M
        return pstm^resp^frmt^err^l;                                   !05427K2N
        end;                                                           !05427K2O
                                                                       !05427K2P
    !!                                                                 !05427K2Q
    !delete the address verification token from the PSTM.!             !05427K2R
    !!                                                                 !05427K2S
    movd( tkn^id,    addr^ver^tkn^id^d );                              !05427K2T
    error := tkn^del^info( pstm, pstm^lgth^d( pstm ),                  !05427K2U
                           intrn^msg^lmt^l, tkn^id,,, userdata );      !05427K2V
    if error <> compl^no^err^l       and                               !05427K2W
       error <> tkn^does^not^exist^l then                              !05427K2X
        begin                                                          !05427K2Y
        call logmessage^( 1227,, @del^err, net.myname,                 !05427K2Z
                          3, @pos^prod^g, @tkn^id );                   !05427K30
        call abend^( 2450 );                                           !05427K31
        end;                                                           !05427K32
                                                                       !05427K33
                                                                       !05427K34
                                                                       !05427K35
                                                                       !05427K36
                                                                       !05427K37
    return true;                                                       !05433
    end;                                                               !05434
?section pstm^frmt^b24^to^pos^0220                                     !05435
?page "                               - pstm^frmt^b24^to^pos^0220"     !05435K00
!#####################################################################!!05438
!#                                                                   #!!05439
!#                    PSTM^FRMT^B24^TO^POS^0220                      #!!05440
!#                                                                   #!!05441
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0220 PSTM TO AN EXTERNAL  #!!05442
!#       0220 ADVICE MESSAGE.                                        #!!05443
!#                                                                   #!!05444
!#    INPUT PARAMETERS:                                              #!!05445
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!05446
!#                                                                   #!!05447
!#    OUTPUT PARAMETERS:                                             #!!05448
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05449
!#                                                                   #!!05450
!#####################################################################!!05451
int proc pstm^frmt^b24^to^pos^0220( pstm, sem );                       !05452
struct  .pstm( pstm^def );                                             !05453
struct  .sem(  sem^def  );                                             !05454
    begin                                                              !05455
                                                                       !05455K00
    wlform( del^err,                                                   !05455K01
        "Error while attempting to delete token \\ from the PSTM " )   !05455K02
    wlform( add^err, "Error while attempting to add token \\ " )       !05455K03
    wlform( no^room, "Unable to add token \\, no room available " )    !05455K04
                                                                       !05455K05
                                                                       !05455K06
    define   pstm^adj^code^d( x )  =  adjustment^tbl[ (x) * 4 + 0]#,   !05456
             sem^adj^code^d(  x )  =  adjustment^tbl[ (x) * 4 + 2]#;   !05457
                                                                       !05458
    string   adjustment^tbl = 'P' :=  [                                !05459
        !                                                             !!05460
        !  PSTM ADJ.        SEM ADJ.                                  !!05461
        !  CODES            CODES                                     !!05462
        !    |                |                                       !!05463
        !    v                v                                       !!05464
           "12",            "64", ! original amount incorrect         !!05465
           "14",            "S1", ! private - suspcious rvsl overide  !!05466
           "15",            "S2", ! private - misdispense overide     !!05467
                                                                       !05468100
           "16",            "T9", ! duplicate transmission            !!05468101
                                                                       !05468102
           "17",            "95", ! reconcile error                   !!05469
           "18",            "S3", ! private - PLUS add cash wdl or adv!!05470
           "19",            "96", ! system malfunction                !!05471
            0 ];                                                       !05472
                                                                       !05472K00
                                                                       !05472K01
    struct                                                             !05472K02
            .addr^ver^tkn( addr^ver^tkn^def ),                         !05472K03
            .tkn^mem^rec( tkn^mem^rec^def );                           !05472K04
                                                                       !05472K05
    int                                                                !05472K06
             error,                                                    !05472K07
                                                                       !05472:00
             i := -1,                                                  !05472:01
                                                                       !05472:02
             userdata;                                                 !05472K08
                                                                       !05472K09
    string                                                             !05472K0A
             err^flg,                                                  !05472K0B
            .tkn^grp[ 0:3 ],                                           !05472K0C
            .tkn^id[ 0:1 ];                                            !05472K0D
                                                                       !05472K0E
                                                                       !05473
    if  pstm^pre^auth^d( pstm ) then                                   !05474
        begin                                                          !05475
        movd ( psem.typ,                    auth^advice^d        );    !05476
        mov^ ( psem.pri^bit^map,            pos.p0120.pbit^map   );    !05477
        mov^ ( psem.secndry^bit^map,        pos.p0120.sbit^map   );    !05478
                                                                       !05478K00
        movl ( tkn^grp, pos.p0120.tkn^grp, $occurs( tkn^grp )    );    !05478K01
                                                                       !05478K02
        end                                                            !05479
    else                                                               !05480
        begin                                                          !05481
        movd ( psem.typ,                    tran^advice^d        );    !05482
        mov^ ( psem.pri^bit^map,            pos.p0220.pbit^map   );    !05483
        mov^ ( psem.secndry^bit^map,        pos.p0220.sbit^map   );    !05484
                                                                       !05484K00
        movl ( tkn^grp, pos.p0220.tkn^grp,  $occurs( tkn^grp )   );    !05484K01
                                                                       !05484K02
        end;                                                           !05485
                                                                       !05486
    call integer^ascii^( psem.trace^num, trace^num^g );                !05487
                                                                       !05488
    if  not pstm^frmt^b24^to^pos^acct( pstm, sem ) then                !05489
        return false;                                                  !05490
                                                                       !05491
    if  not pstm^frmt^b24^to^pos^tran( pstm, sem ) then                !05492
        return false;                                                  !05493
                                                                       !05494
                                                                       !05494L00
    if  not pstm^frmt^b24^to^pos^amt( pstm, sem ) then                 !05494L01
        return false;                                                  !05494L02
                                                                       !05494L03
                                                                       !05495L00
                                                                       !05495L01
                                                                       !05495L02
                                                                       !05499
    if  pstm^adjustments^d( pstm )  then                               !05500
        begin                                                          !05501
                                                                       !05502L00
                                                                       !05502L01
                                                                       !05502L02
                                                                       !05508:00
        i := -1;                                                       !05508:01
                                                                       !05508:02
        while pstm^adj^code^d( i := i + 1 ) and pstm.rvsl^cde <>       !05509
            pstm^adj^code^d( i ) for $len( pstm.rvsl^cde ) do;         !05510
                                                                       !05511
        if  not pstm^adj^code^d ( i )  then                            !05512
            movd ( psem.resp^cde, "00" )                               !05513
        else                                                           !05514
            movl ( psem.resp^cde , sem^adj^code^d( i ),                !05515
                $len( psem.resp^cde ) );                               !05516
        end                                                            !05517
    else                                                               !05518
        mov^ ( psem.resp^cde, zeroes );                                !05519
                                                                       !05520
                                                                       !05521L00
                                                                       !05521L01
                                                                       !05521L02
                                                                       !05523
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind,  pstm.rte.auth^ind );
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind2, pstm.auth^ind2    );
                                                                       !05528
                                                                       !05528K00
    if tkn^name^g <> invalid^name^d and                                !05528K01
                                                                       !05528U00
       base24^rel^g >= 5 then                                          !05528U01
                                                                       !05528U02
        begin                                                          !05528K03
        if pstm.data^flag = "0" then                                   !05528K04
            movd( userdata, false )                                    !05528K05
        else                                                           !05528K06
            movd( userdata, true );                                    !05528K07
                                                                       !05528L00
                                                                       !05528L01
        if pstm.addr^typ = av^addr^typ^d then                          !05528L02
            begin                                                      !05528L03
            !!                                                         !05528L04
            !Add address verification token to PSTM.!                  !05528L05
            !!                                                         !05528L06
            init( addr^ver^tkn, "  ",  wlen( addr^ver^tkn ) );         !05528L07
            mov^( addr^ver^tkn.addr,    pstm.addr^flds.addr );         !05528L08
            mov^( addr^ver^tkn.zip^cde, pstm.zip^cde        );         !05528L09
            movd( tkn^id,    addr^ver^tkn^id^d );                      !05528L0A
                                                                       !05528L0B
            if ( error := tkn^add^info( pstm, pstm^lgth^d( pstm ),     !05528L0C
                                  intrn^msg^lmt^l,                     !05528L0D
                                  tkn^id, addr^ver^tkn,                !05528L0E
                                  $len( addr^ver^tkn ),,,,,            !05528L0F
                                  userdata ) ) <> compl^no^err^l then  !05528L0G
                begin                                                  !05528L0H
                if error = over^max^limit^l then                       !05528L0I
                    call logmessage^( 1230,, @no^room, net.myname,     !05528L0J
                                      2, @pos^prod^g, @tkn^id )        !05528L0K
                else                                                   !05528L0L
                    begin                                              !05528L0M
                    call logmessage^( 1235,, @add^err, net.myname,     !05528L0N
                                      3, @pos^prod^g, @tkn^id );       !05528L0O
                    call abend^( 2500 );                               !05528L0P
                    end                                                !05528L0Q
                end;                                                   !05528L0R
            end;                                                       !05528L0S
                                                                       !05528L0T
                                                                       !05528L0U
                                                                       !05528L0V
                                                                       !05528L0W
                                                                       !05528K0W
        if not pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp ) then     !05528K0X
            begin                                                      !05528K0Y
            movd( err^flg, tkn^err^flg^d );                            !05528K0Z
            call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,          !05528K10
                                       pstm^lgth^d( pstm ), false,,    !05528K11
                                       pstm.data^flag, err^flg );      !05528K12
            return pstm^resp^frmt^err^l;                               !05528K13
            end;                                                       !05528K14
                                                                       !05528K15
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !05528K16
                               intrn^msg^lmt^l,                        !05528K17
                               tkn^id,,, userdata );                   !05528K18
                                                                       !05528K19
        if error <> compl^no^err^l       and                           !05528K1A
           error <> tkn^does^not^exist^l then                          !05528K1B
            begin                                                      !05528K1C
            call logmessage^( 1240,, @del^err, net.myname,             !05528K1D
                              3, @pos^prod^g, @tkn^id );               !05528K1E
            call abend^( 2600 );                                       !05528K1F
            end;                                                       !05528K1G
        end;                                                           !05528K1H
                                                                       !05528K1I
                                                                       !05528K1J
    return true;                                                       !05529
    end;                                                               !05530
?section pstm^frmt^b24^to^pos^0402                                     !05531
?page "                               - pstm^frmt^b24^to^pos^0402"     !05531K00
                                                                       !05534
!#####################################################################!!05535
!#                                                                   #!!05536
!#                   PSTM^FRMT^B24^TO^POS^0402                       #!!05537
!#                                                                   #!!05538
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0402 PSTM ISSUER REVERSAL #!!05539
!#       ( CHARGEBACK ) TO A BIC ISO EXTERNAL REVERSAL.              #!!05540
!#                                                                   #!!05541
!#    INPUT PARAMETERS:                                              #!!05542
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!05543
!#                                                                   #!!05544
!#    OUTPUT PARAMETERS:                                             #!!05545
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05546
!#                                                                   #!!05547
!#####################################################################!!05548
int proc pstm^frmt^b24^to^pos^0402( pstm, sem );                       !05549
struct  .pstm( pstm^def );                                             !05550
struct  .sem(  sem^def  );                                             !05551
    begin                                                              !05552
                                                                       !05552K00
    wlform( del^err,                                                   !05552K01
        "Error while attempting to delete token \\ from the PSTM " )   !05552K02
    wlform( add^err, "Error while attempting to add token \\ " )       !05552K03
    wlform( no^room, "Unable to add token \\, no room available " )    !05552K04
                                                                       !05552K05
                                                                       !05552K06
    define  pstm^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 0 ] #,          !05553
            sem^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 2 ] #;           !05554
                                                                       !05555
    string  rvsl^tbl  = 'P' :=  [                                      !05556
        !                                                             !!05557
        ! PSTM        SEM                                             !!05558
        ! Codes      Codes                                            !!05559
        !  .          .                                               !!05560
        !  .          .                                               !!05561
        !  v          v                                               !!05562
        !                                                             !!05563
         "00",      "00",   ! reason unknown                          !!05564
         "01",      "68",   ! timeout                                 !!05565
         "02",      "40",   ! requested function not supported        !!05566
         "03",      "R9",   ! dest not available                      !!05567
         "08",      "17",   ! customer cancelled                      !!05568
         "10",      "22",   ! suspected malfunction                   !!05569
         "19",      "96",   ! system malfunction                      !!05570
         "20",      "S0",   ! suspect reversal                        !!05571
               0 ];                                                    !05572
                                                                       !05573
                                                                       !05573K00
    struct                                                             !05573K01
            .addr^ver^tkn( addr^ver^tkn^def ),                         !05573K02
            .tkn^mem^rec( tkn^mem^rec^def );                           !05573K03
                                                                       !05573K04
    int                                                                !05573K05
             error,                                                    !05573K06
             userdata;                                                 !05573K07
                                                                       !05573K08
    string                                                             !05573K09
             err^flg,                                                  !05573K0A
            .tkn^grp[ 0:3 ],                                           !05573K0B
            .tkn^id[ 0:1 ];                                            !05573K0C
                                                                       !05573K0D
                                                                       !05573K0E
    movd ( psem.typ,                   rvsl^request^d            );    !05574
    move ( psem.originator,            pstm.originator           );    !05575
    move ( psem.responder,             pstm.responder            );    !05576
    mov^ ( psem.pri^bit^map,           pos.p0402.pbit^map        );    !05577
    mov^ ( psem.secndry^bit^map,       pos.p0402.sbit^map        );    !05578
    mov^ ( psem.setl^dat,              pstm.iss^ichg^setl^dat.mm );    !05579
    mov^ ( psem.cap^dat,               pstm.post^dat.mm          );    !05580
                                                                       !05581
    if  not pstm^frmt^b24^to^pos^tran( pstm, sem )  then               !05582
        return pstm^resp^inv^tran^l;                                   !05583
                                                                       !05584
    if  not pstm^frmt^b24^to^pos^acct( pstm, sem )  then               !05585
        return pstm^resp^frmt^err^l;                                   !05586
                                                                       !05587
    call integer^ascii^( psem.trace^num, trace^num^g );                !05588
                                                                       !05589
                                                                       !05589L00
    if  not pstm^frmt^b24^to^pos^amt( pstm, sem ) then                 !05589L01
        return pstm^resp^frmt^err^l;                                   !05589L02
                                                                       !05589L03
                                                                       !05590L00
                                                                       !05590L01
                                                                       !05590L02
                                                                       !05610
    use i; i := -1;                                                    !05611
    while pstm^code^d( i:=i+1 )  and pstm.rvsl^cde <>                  !05612
          pstm^code^d( i ) for $len( pstm.rvsl^cde ) do;               !05613
                                                                       !05614
    if  not pstm^code^d( i ) then                                      !05615
        movd ( psem.resp^cde, "00" )                                   !05616
    else                                                               !05617
        movl ( psem.resp^cde, sem^code^d( i ), $len( psem.resp^cde ) );
    drop i;                                                            !05620
                                                                       !05621
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind,  pstm.rte.auth^ind );
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind2, pstm.auth^ind2    );
                                                                       !05621K00
                                                                       !05621K01
    if tkn^name^g <> invalid^name^d and                                !05621K02
                                                                       !05621U00
       base24^rel^g >= 5 then                                          !05621U01
                                                                       !05621U02
        begin                                                          !05621K04
        if pstm.data^flag = "0" then                                   !05621K05
            movd( userdata, false )                                    !05621K06
        else                                                           !05621K07
            movd( userdata, true );                                    !05621K08
                                                                       !05621K09
                                                                       !05621L00
        if pstm.addr^typ = av^addr^typ^d then                          !05621L01
            begin                                                      !05621L02
            !!                                                         !05621L03
            !Add address verification token to PSTM.!                  !05621L04
            !!                                                         !05621L05
            init( addr^ver^tkn, "  ",  wlen( addr^ver^tkn ) );         !05621L06
            mov^( addr^ver^tkn.addr,    pstm.addr^flds.addr );         !05621L07
            mov^( addr^ver^tkn.zip^cde, pstm.zip^cde        );         !05621L08
            movd( tkn^id,    addr^ver^tkn^id^d );                      !05621L09
                                                                       !05621L0A
            if ( error := tkn^add^info( pstm, pstm^lgth^d( pstm ),     !05621L0B
                                  intrn^msg^lmt^l,                     !05621L0C
                                  tkn^id, addr^ver^tkn,                !05621L0D
                                  $len( addr^ver^tkn ),,,,,            !05621L0E
                                  userdata ) ) <> compl^no^err^l then  !05621L0F
                begin                                                  !05621L0G
                if error = over^max^limit^l then                       !05621L0H
                    call logmessage^( 1245,, @no^room, net.myname,     !05621L0I
                                      2, @pos^prod^g, @tkn^id )        !05621L0J
                else                                                   !05621L0K
                    begin                                              !05621L0L
                    call logmessage^( 1250,, @add^err, net.myname,     !05621L0M
                                      3, @pos^prod^g, @tkn^id );       !05621L0N
                    call abend^( 2700 );                               !05621L0O
                    end                                                !05621L0P
                end;                                                   !05621L0Q
            end;                                                       !05621L0R
                                                                       !05621L0S
                                                                       !05621L0T
                                                                       !05621L0U
                                                                       !05621L0V
                                                                       !05621K0Y
        movl( tkn^grp, pos.p0402.tkn^grp, $occurs( tkn^grp ) );        !05621K0Z
        if not pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp ) then     !05621K10
            begin                                                      !05621K11
            movd( err^flg, tkn^err^flg^d );                            !05621K12
            call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,          !05621K13
                                       pstm^lgth^d( pstm ), false,,    !05621K14
                                       pstm.data^flag, err^flg );      !05621K15
            return pstm^resp^frmt^err^l;                               !05621K16
            end;                                                       !05621K17
                                                                       !05621K18
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !05621K19
                               intrn^msg^lmt^l,                        !05621K1A
                               tkn^id,,, userdata );                   !05621K1B
                                                                       !05621K1C
        if error <> compl^no^err^l       and                           !05621K1D
           error <> tkn^does^not^exist^l then                          !05621K1E
            begin                                                      !05621K1F
            call logmessage^( 1255,, @del^err, net.myname,             !05621K1G
                              3, @pos^prod^g, @tkn^id );               !05621K1H
            call abend^( 2800 );                                       !05621K1I
            end;                                                       !05621K1J
        end;                                                           !05621K1K
                                                                       !05621K1L
                                                                       !05621K1M
                                                                       !05626K00
                                                                       !05626K01
    return pstm^resp^no^err^l;                                         !05627
    end;                                                               !05628
?section pstm^frmt^b24^to^pos^0420                                     !05629
?page "                               - pstm^frmt^b24^to^pos^0420"     !05629K00
                                                                       !05632
!#####################################################################!!05633
!#                                                                   #!!05634
!#                   PSTM^FRMT^B24^TO^POS^0420                       #!!05635
!#                                                                   #!!05636
!#    NARRATIVE : THIS PROCEDURE FORMATS A 0420 PSTM TO AN EXTERNAL  #!!05637
!#       0420 REVERSAL MESSAGE.                                      #!!05638
!#                                                                   #!!05639
!#    INPUT PARAMETERS:                                              #!!05640
                                                                       !05640@00
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE FOR  #!!05640@01
!#                       THE REVERSAL                                #!!05640@02
!#       ORIG^PSTM     : POINTER TO BASE24 INTERNAL POS MESSAGE FOR  #!!05640@03
!#                       THE ORIGINAL RESPONSE RETRIEVED FROM THE ILF#!!05640@04
                                                                       !05640@05
                                                                       !05641@00
                                                                       !05641@01
!#                                                                   #!!05642
!#    OUTPUT PARAMETERS:                                             #!!05643
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05644
!#                                                                   #!!05645
!#####################################################################!!05646
                                                                       !05646@00
int proc pstm^frmt^b24^to^pos^0420( pstm, orig^pstm, sem );            !05646@01
                                                                       !05646@02
                                                                       !05647@00
                                                                       !05647@01
struct  .pstm( pstm^def );                                             !05648
                                                                       !05648@00
struct  .orig^pstm( pstm^def );                                        !05648@01
                                                                       !05648@02
struct  .sem(  sem^def  );                                             !05649
    begin                                                              !05650
                                                                       !05650K00
    wlform( del^err,                                                   !05650K01
        "Error while attempting to delete token \\ from the PSTM " )   !05650K02
    wlform( add^err, "Error while attempting to add token \\ " )       !05650K03
    wlform( no^room, "Unable to add token \\, no room available " )    !05650K04
                                                                       !05650K05
                                                                       !05650K06
    define  pstm^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 0 ] #,          !05651
            sem^code^d( i )  =  rvsl^tbl[ ( i ) * 4 + 2 ] #;           !05652
                                                                       !05653
    string  rvsl^tbl  = 'P' :=  [                                      !05654
        !                                                             !!05655
        ! PSTM        SEM                                             !!05656
        ! Codes      Codes                                            !!05657
        !  .          .                                               !!05658
        !  .          .                                               !!05659
        !  v          v                                               !!05660
        !                                                             !!05661
         "00",      "00",   ! reason unknown                          !!05662
         "01",      "68",   ! timeout                                 !!05663
         "02",      "40",   ! requested function not supported        !!05664
         "03",      "R9",   ! dest not available                      !!05665
         "08",      "17",   ! customer cancelled                      !!05666
         "10",      "22",   ! suspected malfunction                   !!05667
         "19",      "96",   ! system malfunction                      !!05668
         "20",      "S0",   ! suspect reversal                        !!05669
                                                                       !05669K00
         "21",      "U1",   ! private MAC failure!                     !05669K01
         "22",      "U2",   ! private KMAC sync error!                 !05669K02
         "23",      "U3",   ! private message replay error!            !05669K03
         "24",      "U4",   ! private invalid MAC!                     !05669K04
                                                                       !05669z00
         "40",      "U6",   ! Split Routing Enabled; Secondary        !!05669z01
                            ! Service Not Approved                    !!05669z02
                                                                       !05669z03
                                                                       !05669K05
               0 ];                                                    !05670
                                                                       !05671
                                                                       !05671K00
    struct                                                             !05671K01
            .addr^ver^tkn( addr^ver^tkn^def ),                         !05671K02
            .tkn^mem^rec( tkn^mem^rec^def );                           !05671K03
                                                                       !05671K04
    int                                                                !05671K05
             error,                                                    !05671K06
             userdata;                                                 !05671K07
                                                                       !05671K08
    string                                                             !05671K09
             err^flg,                                                  !05671K0A
            .tkn^grp[ 0:3 ],                                           !05671K0B
            .tkn^id[ 0:1 ];                                            !05671K0C
                                                                       !05671K0D
    movd ( psem.typ,                       rvsl^advice^d             );
    move ( psem.originator,                pstm.originator           );
    move ( psem.responder,                 pstm.responder            );
    mov^ ( psem.pri^bit^map,               pos.p0420.pbit^map        );
    mov^ ( psem.secndry^bit^map,           pos.p0420.sbit^map        );
    mov^ ( psem.setl^dat,                  pstm.iss^ichg^setl^dat.mm );
    mov^ ( psem.cap^dat,                   pstm.post^dat.mm          );
                                                                       !05671K0S
                                                                       !05672K00
                                                                       !05672K01
                                                                       !05672K02
                                                                       !05687
    if  not pstm^frmt^b24^to^pos^acct( pstm, sem ) then                !05688
        return false;                                                  !05689
                                                                       !05690
    if  not pstm^frmt^b24^to^pos^tran( pstm, sem ) then                !05691
        return false;                                                  !05692
                                                                       !05693
    call integer^ascii^( psem.trace^num, trace^num^g );                !05694
                                                                       !05695
                                                                       !05695L00
    if  not pstm^frmt^b24^to^pos^amt( pstm, sem ) then                 !05695L01
        return false;                                                  !05695L02
                                                                       !05695@00
    move( ssem.b24^orig.orig^typ,                                      !05695@01
          orig^pstm.orig^data.msg^typ );                               !05695@02
    move( ssem.b24^orig.orig^tran^dat,                                 !05695@03
          orig^pstm.orig^data.trn^dat );                               !05695@04
    move( ssem.b24^orig.orig^tran^tim,                                 !05695@05
          orig^pstm.orig^data.trn^tim );                               !05695@06
    move( ssem.b24^orig.orig^b24^post^dat,                             !05695@07
          orig^pstm.orig^data.b24^post^dat );                          !05695@08
    move( ssem.b24^orig.orig^seq^num,                                  !05695@09
          orig^pstm.orig^data.tran^seq^num );                          !05695@0A
                                                                       !05695@0B
                                                                       !05695L03
                                                                       !05696L00
                                                                       !05696L01
                                                                       !05696L02
                                                                       !05714
    use i; i := -1;                                                    !05715
    while pstm^code^d( i:=i+1 )  and pstm.rvsl^cde <>                  !05716
          pstm^code^d( i ) for $len( pstm.rvsl^cde ) do;               !05717
                                                                       !05718
    if  not pstm^code^d( i ) then                                      !05719
        movd ( psem.resp^cde, "00" )                                   !05720
    else                                                               !05721
        psem.resp^cde ':=' sem^code^d( i ) for $len( psem.resp^cde );  !05722
    drop i;                                                            !05723
                                                                       !05724
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind,  pstm.rte.auth^ind );
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind2, pstm.auth^ind2    );
                                                                       !05724K00
                                                                       !05724K01
    if tkn^name^g <> invalid^name^d and                                !05724K02
                                                                       !05724U00
       base24^rel^g >= 5 then                                          !05724U01
                                                                       !05724U02
        begin                                                          !05724K04
        if pstm.data^flag = "0" then                                   !05724K05
            movd( userdata, false )                                    !05724K06
        else                                                           !05724K07
            movd( userdata, true );                                    !05724K08
                                                                       !05724K09
                                                                       !05724L00
        if pstm.addr^typ = av^addr^typ^d then                          !05724L01
            begin                                                      !05724L02
            !!                                                         !05724L03
            !Add address verification token to PSTM.!                  !05724L04
            !!                                                         !05724L05
            init( addr^ver^tkn, "  ",  wlen( addr^ver^tkn ) );         !05724L06
            mov^( addr^ver^tkn.addr,    pstm.addr^flds.addr );         !05724L07
            mov^( addr^ver^tkn.zip^cde, pstm.zip^cde        );         !05724L08
            movd( tkn^id,    addr^ver^tkn^id^d );                      !05724L09
                                                                       !05724L0A
            if ( error := tkn^add^info( pstm, pstm^lgth^d( pstm ),     !05724L0B
                                  intrn^msg^lmt^l, tkn^id,             !05724L0C
                                  addr^ver^tkn,                        !05724L0D
                                  $len( addr^ver^tkn ),,,,,            !05724L0E
                                  userdata ) ) <> compl^no^err^l then  !05724L0F
                begin                                                  !05724L0G
                if error = over^max^limit^l then                       !05724L0H
                    call logmessage^( 1260,, @no^room, net.myname,     !05724L0I
                                      2, @pos^prod^g, @tkn^id )        !05724L0J
                else                                                   !05724L0K
                    begin                                              !05724L0L
                    call logmessage^( 1265,, @add^err, net.myname,     !05724L0M
                                      3, @pos^prod^g, @tkn^id );       !05724L0N
                    call abend^( 2900 );                               !05724L0O
                    end                                                !05724L0P
                end;                                                   !05724L0Q
            end;                                                       !05724L0R
                                                                       !05724L0S
                                                                       !05724L0T
                                                                       !05724L0U
                                                                       !05724L0V
                                                                       !05724K0Y
        movl( tkn^grp, pos.p0420.tkn^grp, $occurs( tkn^grp ) );        !05724K0Z
        if not pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp ) then     !05724K10
            begin                                                      !05724K11
            movd( err^flg, tkn^err^flg^d );                            !05724K12
            call hiswtkn^set^ps50^tkn( pstm, intrn^msg^lmt^l,          !05724K13
                                       pstm^lgth^d( pstm ), false,,    !05724K14
                                       pstm.data^flag, err^flg );      !05724K15
            return pstm^resp^frmt^err^l;                               !05724K16
            end;                                                       !05724K17
                                                                       !05724K18
        error := tkn^del^info( pstm, pstm^lgth^d( pstm ),              !05724K19
                               intrn^msg^lmt^l,                        !05724K1A
                               tkn^id,,, userdata );                   !05724K1B
                                                                       !05724K1C
        if error <> compl^no^err^l       and                           !05724K1D
           error <> tkn^does^not^exist^l then                          !05724K1E
            begin                                                      !05724K1F
            call logmessage^( 1270,, @del^err, net.myname,             !05724K1G
                              3, @pos^prod^g, @tkn^id );               !05724K1H
            call abend^( 3000 );                                       !05724K1I
            end;                                                       !05724K1J
        end;                                                           !05724K1K
                                                                       !05724K1L
                                                                       !05724K1M
                                                                       !05729K00
                                                                       !05729K01
    return true;                                                       !05730
    end;                                                               !05731
?section pstm^frmt^b24^to^pos^acct                                     !05732
?page "                               - pstm^frmt^b24^to^pos^acct"     !05732K00
!#####################################################################!!05735
!#                                                                   #!!05736
!#                    PSTM^FRMT^B24^T0^POS^ACCT                      #!!05737
!#                                                                   #!!05738
!#    NARRATIVE : THIS PROCEDURE FORMATS THE PSTM ACCOUNT NUMBERS    #!!05739
!#       INTO SEM FORMAT ACCOUNT NUMBERS.                            #!!05740
!#                                                                   #!!05741
!#    INPUT PARAMETERS:                                              #!!05742
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!05743
!#                                                                   #!!05744
!#    OUTPUT PARAMETERS:                                             #!!05745
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05746
!#                                                                   #!!05747
!#####################################################################!!05748
int proc pstm^frmt^b24^to^pos^acct( pstm, sem );                       !05749
struct  .pstm( pstm^def );                                             !05750
struct  .sem( sem^def );                                               !05751
    begin                                                              !05752
                                                                       !05753
                                                                       !05753M00
    int      length,                                                   !05753M01
             response,                                                 !05753M02
             track1^get^lgth,                                          !05753M03
            .track1^get^tkn( track1^tkn^def );                         !05753M04

!*===================================================================**
! BEGIN RPQ #A1010 - Inoperabilidad                    2013-10-17
!*-------------------------------------------------------------------**
    int      ps51^get^lgth,
            .ps51^get^tkn( ps51^tkn^def );
!*-------------------------------------------------------------------**
! END   RPQ #A1010 - Inoperabilidad                    2013-10-17
!*===================================================================**

    string  .sptr,                                                     !05753M05
            .eptr,                                                     !05753M06
             tkn^id[0:1];                                              !05753M07
                                                                       !05753M08
                                                                       !05753M09
                                                                       !05753M0A
                                                                       !05753M0B
    tkn^id ':=' track1^tkn^id^d;                                       !05753M0C
    if  hiswtkn^get^tkn( pstm, tkn^id, @track1^get^tkn,                !05753M0D
                         track1^get^lgth ) then                        !05753M0E
        begin                                                          !05753M0F
        if  response := extract^track1^info( track1^get^tkn,           !05753M0G
                                             track1^get^lgth ) then    !05753M0H

!*******************************************************************!
! BEGIN FIX #002 Parametro de Control de negacion por Track-1       !
!* Taken from HISO as per Claudia                 KPP 08/14/08      !
!*------------------------------------------------------------------!
            BEGIN
             IF VALIDA^TRACK1^G = "Y" THEN
                BEGIN
            return false;                                              !05753M0I
                END
            END;
!*------------------------------------------------------------------!
! END   FIX #002 Parametro de Control de negacion por Track-1       !
!*******************************************************************!

        scan track1^get^tkn until track1^start^sent^d -> @sptr;        !05753M0J
        @sptr := @sptr[ +1 ];                                          !05753M0K
        scan track1^get^tkn until end^sent^d -> @eptr;                 !05753M0L
        length := $max( 0, ( @eptr '-' @sptr ) );                      !05753M0M
        if  length > 76 then                                           !05753M0N
            begin                                                      !05753M0O
            movl( psem.track1.data, sptr,                              !05753M0P
                  $len( psem.track1.data ) );                          !05753M0Q
            call integer^ascii^( psem.track1.len,                      !05753M0R
                                 $len( psem.track1.data ) );           !05753M0S
            movd( psem.entry^mde, "02" );                              !05753M0T
            end                                                        !05753M0U
        else                                                           !05753M0V
            begin                                                      !05753M0W
            movl( psem.track1.data, sptr, length );                    !05753M0X
            call integer^ascii^( psem.track1.len, length );            !05753M0Y
            end;                                                       !05753M0Z
        end;                                                           !05753M10
                                                                       !05753M11
                                                                       !05754M00
                                                                       !05754M01
                                                                       !05754M02
    if  pstm.tran.track2 <> zeroes for $len( pstm.tran.track2 ) and    !05758
        pstm.tran.track2 <> blanks for $len( pstm.tran.track2 ) then   !05759
        begin                                                          !05760
        length := $len( pstm.tran.track2 ) + 1;                        !05761
        while ( length := length - 1 ) > 2 and                         !05762
              ( pstm.tran.track2.byte[ length - 1 ] = " "   or         !05763
                pstm.tran.track2.byte[ length - 1 ] = "0" ) do;        !05764
        !                                                             !!05765
        ! Format track2 excluding start and end sentinels             !!05766
        !                                                             !!05767
        if  length := $min( length-2, $len( psem.track2.data ) ) then  !05768
            begin                                                      !05769
            call integer^ascii^( psem.track2.len, length );            !05770
            psem.track2.data ':=' pstm.tran.track2.byte[1] for length; !05771
            end;                                                       !05772
                                                                       !05772M00
        move( psem.entry^mde, pstm.pt^srv^entry^mde );                 !05772M01
                                                                       !05772M02
                                                                       !05773M00
                                                                       !05773M01
                                                                       !05773M02
        ! Format the external pan from the Track2 data!                !05778K02
                                                                       !05778K03
        use len; len := -1;                                            !05778K04
        call ascii^integer^( psem.track2.len , length );               !05778K05
        while ( len := len + 1 ) <= length and $numeric(               !05778K06
        psem.track2.data.byte[len] )  do;                              !05778K07
                                                                       !05778K08
        call integer^ascii^( psem.pan.len,                             !05778K09
            $min( ( len ) , $len( psem.pan.data ) ) );                 !05778K0A
                                                                       !05778K0B
        psem.pan.data ':=' psem.track2.data for                        !05778K0C
            $min( ( len ), $len( psem.pan.data ) );                    !05778K0D
        end;                                                           !05778K0E
                                                                       !05778K0F
                                                                       !05778K0G
                                                                       !05779K00
                                                                       !05779K01
                                                                       !05779K02
    if  pstm.tran.acct <> zeroes for $len( pstm.tran.acct ) and        !05781
        pstm.tran.acct <> blanks for $len( pstm.tran.acct ) then       !05782
        begin                                                          !05783
        scan pstm.tran.acct until blanks -> @sptr;                     !05784
        length := $min( @sptr '-' @pstm.tran.acct, $min(               !05785
            $len( pstm.tran.acct ), $len( ssem.acct1.num ) ) );        !05786
                                                                       !05787
        call integer^ascii^( ssem.acct1.len, length );                 !05788
        ssem.acct1.num ':=' pstm.tran.acct for length &                !05789
            blanks for $len( ssem.acct1.num ) - length;                !05790
        end;                                                           !05791
                                                                       !05792
!**********************************************************************
! BEGIN RPQ #A1010 - Inoperabilidad
!*-------------------------------------------------------------------**
    if pstm.pt^srv^entry^mde.byte[0] = "100" then
       begin
       end
    else
    if pstm.pt^srv^cond^cde.byte[0] = "08" or
       pstm.pt^srv^cond^cde.byte[0] = "59"  then
       Begin
        tkn^id ':=' ps51^tkn^id^d;
        if  hiswtkn^get^tkn( pstm, tkn^id, @ps51^get^tkn,
                             ps51^get^lgth ) then
            begin
             if pstm.pt^srv^cond^cde.byte[0] = "08" and
                ps51^get^tkn.e^com^flg = "1"          then
                begin
                 pstm.pt^srv^entry^mde.byte[0] ':=' "010";
                end
             else
             if pstm.pt^srv^cond^cde.byte[0] = "08" and
                ps51^get^tkn.e^com^flg = "2"          then
                begin
                 if  pstm.tran.tran^cde.tc = "14" then
                        pstm.pt^srv^entry^mde.byte[0] ':=' "100"
                 else
                 pstm.pt^srv^entry^mde.byte[0] ':=' "016";
                end
             else
             if pstm.pt^srv^cond^cde.byte[0] = "59" and
                ps51^get^tkn.e^com^flg = "7"          then
                begin
                 pstm.pt^srv^entry^mde.byte[0] ':=' "017";
                end;
            end;
        move( psem.entry^mde, pstm.pt^srv^entry^mde );
       End;
!*-------------------------------------------------------------------**
! END   RPQ #A1010 - Inoperabilidad
!**********************************************************************
!**********************************************************************
! BEGIN RPQ #A2020 - Ajuste Ventas no presenciales
!*-------------------------------------------------------------------**
    if pstm.pt^srv^entry^mde.byte[0] = "01" then     ! No presenciales
       Begin
        tkn^id ':=' ps51^tkn^id^d;
        if hiswtkn^get^tkn( pstm, tkn^id, @ps51^get^tkn,
                            ps51^get^lgth ) then
           begin
           if ps51^get^tkn.cvd^fld.byte[0] = "    " then
              begin
               ps51^get^tkn.cvd^fld.byte[0] ':=' "XXX ";
              end;
           if ps51^get^tkn.cvd^fld^present = " " then
              begin
               ps51^get^tkn.cvd^fld^present ':=' "0";
              end;
           end;
       End;
!*-------------------------------------------------------------------**
! END   RPQ #A2020 - Ajuste Ventas no presenciales
!**********************************************************************









                                                                       !05793K00
                                                                       !05793K01
                                                                       !05793K02
                                                                       !05793)00
    call pos^util^sem^adjust^trk( sem, pstm );                         !05793)01
                                                                       !05793)02
    return true;                                                       !05806
    end;                                                               !05807
                                                                       !05807L00
                                                                       !05807L01
?section pstm^frmt^b24^to^pos^amt                                      !05807L02
?page "                                - pstm^frmt^b24^to^pos^amt"     !05807L03
!#####################################################################!
!#                                                                   #!
!#                  PSTM^FRMT^B24^T0^POS^AMT                         #!
!#                                                                   #!
!#    NARRATIVE : THIS PROCEDURE FORMATS AN PSTM AMOUNT FIELD TO THE #!
!#       BIC ISO SEM AMOUNT AFTER APPLYING ANY CONVERSION FACTOR.    #!
!#                                                                   #!
!#    INPUT PARAMETERS:                                              #!
!#       PSTM          : POINTER TO INTERNAL MESSAGE                 #!
!#       SEM           : POINTER TO EXTERNAL MESSAGE                 #!
!#                                                                   #!
!#    OUTPUT PARAMETERS:                                             #!
!#                                                                   #!
!#    RETURNS TRUE IF SUCCESSFUL WITH CONVERTED AMOUNT IN SEM AMT    #!
!#    RETURNS FALSE IF NOT SUCCESSFUL                                #!
!#                                                                   #!
!#####################################################################!
int proc pstm^frmt^b24^to^pos^amt( pstm, sem );                        !05807L10
struct  .pstm( pstm^def );                                             !05807L11
struct  .sem( sem^def );                                               !05807L12
                                                                       !05807L13
    begin                                                              !05807L14
                                                                       !05807L15
    fixed  pstm^amt  := 0f,                                            !05807L16
           pstm^amt2 := 0f;                                            !05807L17
                                                                       !05807L18
int subproc sub^convert^fixed^amt( pstm^amt, conv^rate );              !05807L19
fixed   .pstm^amt;                                                     !05807L1A
string  .conv^rate;                                                    !05807L1B
                                                                       !05807L1C
    begin                                                              !05807L1D
                                                                       !05807L1E
    fixed  buy^rate := 0f;                                             !05807L1F
                                                                       !05807L1G
    int    buy^scale := 0;                                             !05807L1H
                                                                       !05807L1I
                                                                       !05807f00
    !                                                                 !!05807f01
    ! Determine if the multiple currency add-on is being used.  If it !!05807f02
    ! is, skip this processing.                                       !!05807f03
    !                                                                 !!05807f04
    if pct.options.mult^crncy = "Y" then                               !05807f05
        begin                                                          !05807f06
        return true;                                                   !05807f07
        end;                                                           !05807f08
                                                                       !05807f09
    if  pct.crncy^cde <> local^crncy^cde^g                             !05807L1J
                             for $len( pct.crncy^cde ) then            !05807L1K
        begin                                                          !05807L1L
        call ascii^integer( conv^rate[0], 1, buy^scale );              !05807L1M
        call ascii^fixed  ( conv^rate[1], 7, buy^rate );               !05807L1N
                                                                       !05807L1O
        case buy^scale of                                              !05807L1P
            begin                                                      !05807L1Q
      ! 0!  pstm^amt := ( pstm^amt * buy^rate );                       !05807L1R
      ! 1!  pstm^amt := ( pstm^amt * buy^rate ) / 10f;                 !05807L1S
      ! 2!  pstm^amt := ( pstm^amt * buy^rate ) / 100f;                !05807L1T
      ! 3!  pstm^amt := ( pstm^amt * buy^rate ) / 1000f;               !05807L1U
      ! 4!  pstm^amt := ( pstm^amt * buy^rate ) / 10000f;              !05807L1V
      ! 5!  pstm^amt := ( pstm^amt * buy^rate ) / 100000f;             !05807L1W
      ! 6!  pstm^amt := ( pstm^amt * buy^rate ) / 1000000f;            !05807L1X
      ! 7!  pstm^amt := ( pstm^amt * buy^rate ) / 10000000f;           !05807L1Y
      ! 8!  pstm^amt := ( pstm^amt * buy^rate ) / 100000000f;          !05807L1Z
      ! 9!  pstm^amt := ( pstm^amt * buy^rate ) / 1000000000f;         !05807L20
      ! ?!  otherwise                                                  !05807L21
                return false;                                          !05807L22
            end;                                                       !05807L23
        end;                                                           !05807L24
                                                                       !05807L25
    return true;                                                       !05807L26
    end;                                                               !05807L27
                                                                       !05807f0A
                                                                       !05807f0B
                                                                       !05807f0C
                                                                       !05807f0D
                                                                       !05807f0E
                                                                       !05807f0F
                                                                       !05807f0G
                                                                       !05807f0H
                                                                       !05807f0I
                                                                       !05807i00
                                                                       !05807i01
!                                                                     !!05807i02
! This is the main body of proc pstm^frmt^b24^to^pos^amt              !!05807i03
!                                                                     !!05807i04
                                                                       !05807q00
    if pct.options.mult^crncy = "N" and                                !05807q01
       base24^rel^g >= 6            then                               !05807q02
                                                                       !05807q03
        begin                                                          !05807i06
        if pstm.orig^crncy^cde <> local^crncy^cde^g for                !05807i07
               $len( pstm.orig^crncy^cde ) then                        !05807i08
            begin                                                      !05807i09
            return false;                                              !05807i0A
            end;                                                       !05807i0B
        end;                                                           !05807i0C
                                                                       !05807i0D
                                                                       !05807L28
    if  pstm.typ = pstm^request^d or                                   !05807L29
        pstm.typ = pstm^tran^advice^d then                             !05807L2A
        begin                                                          !05807L2B
        if  pct.crncy^cde <> local^crncy^cde^g                         !05807L2C
                                     for $len( pct.crncy^cde ) then    !05807L2D
            begin                                                      !05807L2E
            set ( pstm^amt, pstm.tran.amt^1 );                         !05807L2F
            if  not sub^convert^fixed^amt( pstm^amt,                   !05807L2G
                                           pct.crncy.buy^rate ) then   !05807L2H
                return false;                                          !05807L2I
            if  not fixed^ascii^( psem.setl^amt, pstm^amt ) then       !05807L2J
                return false;                                          !05807L2K
            move( psem.setl^crncy,    pct.crncy^cde      );            !05807L2L
            move( psem.setl^conv^rat, pct.crncy.buy^rate );            !05807L2M
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !05807L2N
            end;                                                       !05807L2O
        if  not fixed^ascii^( psem.tran^amt, pstm.tran.amt^1 ) then    !05807L2P
            return false;                                              !05807L2Q
                                                                       !05807e0A
!**********************************************************************
!@ BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*====================================================================*
!@ BEGIN RPQ #500 Send Additional Amount in Rqeust Transactions

        if  pct.crncy^cde <> local^crncy^cde^g
                                 for $len( pct.crncy^cde ) then
            begin
            set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );
            if  not sub^convert^fixed^amt( pstm^amt2,
                     pstm.tran.mult^crncy.setl^conv^rate ) then
                return false;
            if  not fixed^ascii^( psem.add^amts.b24^def.amt,
                                  pstm^amt2 ) then
                return false;
            psem.add^amts.len ':=' "012";
            if  pstm.tran.amt^2 < 0f  then
                psem.add^amts.b24^def.amt.byte[0] ':=' "-";
            end
        else
            begin
            if  fixed^ascii^( psem.add^amts.b24^def.amt,
                              $abs( pstm.tran.amt^2 ) ) then
                begin
                psem.add^amts.len ':=' "012";
                if  pstm.tran.amt^2 < 0f  then
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";
                end;
            end;

!@ END   RPQ #500 Send Additional Amount in Request Transactions
!======================================================================!
!@ END   RPQ #26B Send Additional Amount in Request Transactions      @!
!**********************************************************************!

        mov^( psem.crncy^cde, pstm.orig^crncy^cde  );                  !05807e0B
                                                                       !05807e0C
                                                                       !05807e0D
                                                                       !05807e0E
                                                                       !05807L2S
        ! because this transaction will be logged to the ILF after!    !05807L2T
        ! being added to the SAF, the mult^crncy fields need to be!    !05807L2U
        ! set so the amounts can be logged in the settlement currency.!
        if  pstm.typ = pstm^tran^advice^d and                          !05807L2X
            pct.crncy^cde <> local^crncy^cde^g                         !05807L2Y
                                     for $len( pct.crncy^cde ) then    !05807L2Z
                begin                                                  !05807L30
                move( pstm.tran.mult^crncy.setl^crncy^cde,             !05807L31
                                                    pct.crncy^cde );   !05807L32
                move( pstm.tran.mult^crncy.setl^conv^rate,             !05807L33
                                              pct.crncy.buy^rate );    !05807L34
                end;                                                   !05807L35
                                                                       !05807L36
                                                                       !05807Z00
        if pstm^cash^back^d( pstm )          or                        !05807Z01
           pre^auth^cash^back^d( pstm )      or                        !05807Z02
           pre^auth^comp^cash^back^d( pstm ) then                      !05807Z03
                                                                       !05807Z04
                                                                       !05807Z05
                                                                       !05807Z06
            begin                                                      !05807L38
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L39
                                     for $len( pct.crncy^cde ) then    !05807L3A
                begin                                                  !05807L3B
                set ( pstm^amt2, pstm.tran.amt^2 );                    !05807L3C
                if  not sub^convert^fixed^amt( pstm^amt2,              !05807L3D
                                           pct.crncy.buy^rate ) then   !05807L3E
                    return false;                                      !05807L3F
                                                                       !05807l00
                if enhanced^crncy^conv^pos^d then                      !05807l01
                    begin                                              !05807l02
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l03
                                         pstm.tran.amt^2 ) then        !05807l04
                        begin                                          !05807l05
                        return false;                                  !05807l06
                        end;                                           !05807l07
                                                                       !05807l08
                    if not fixed^ascii^(                               !05807l09
                               psem.add^amts.b24^def.setl^amt,         !05807l0A
                               pstm^amt2 ) then                        !05807l0B
                        begin                                          !05807l0C
                        return false;                                  !05807l0D
                        end;                                           !05807l0E
                                                                       !05807l0F
                    psem.add^amts.len ':=' "024";                      !05807l0G
                    end                                                !05807l0H
                else                                                   !05807l0I
                    begin                                              !05807l0J
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l0K
                                         pstm^amt2 ) then              !05807l0L
                        begin                                          !05807l0M
                        return false;                                  !05807l0N
                        end;                                           !05807l0O
                    psem.add^amts.len ':=' "012"                       !05807l0P
                    end;                                               !05807l0Q
                                                                       !05807l0R
                                                                       !05807l0S
                                                                       !05807l0T
                                                                       !05807l0U
                end                                                    !05807L3L
            else                                                       !05807L3M
                begin                                                  !05807L3N
                if  fixed^ascii^( psem.add^amts.b24^def.amt,           !05807L3O
                                  pstm.tran.amt^2 ) then               !05807L3P
                    psem.add^amts.len ':=' "012"                       !05807L3Q
                else                                                   !05807L3R
                    return false;                                      !05807L3S
                end;                                                   !05807L3T
            end                                                        !05807L3U
        else                                                           !05807L3V
        if  pstm^adjustments^d( pstm )  then                           !05807L3W
            begin                                                      !05807L3X
                                                                       !05807l0V
            mov^( ssem.replacement.setl^amt, zeroes );                 !05807l0W
                                                                       !05807l0X
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L3Y
                                     for $len( pct.crncy^cde ) then    !05807L3Z
                begin                                                  !05807L40
                set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );            !05807L41
                if  not sub^convert^fixed^amt( pstm^amt2,              !05807L42
                                           pct.crncy.buy^rate ) then   !05807L43
                    return false;                                      !05807L44
                                                                       !05807l0Y
                if enhanced^crncy^conv^pos^d then                      !05807l0Z
                    begin                                              !05807l0a
                    if not fixed^ascii^( ssem.replacement.amt,         !05807l0b
                                         $abs( pstm.tran.amt^2 ) ) then
                        begin                                          !05807l0e
                        return false;                                  !05807l0f
                        end;                                           !05807l0g
                                                                       !05807l0h
                    if not fixed^ascii^( ssem.replacement.setl^amt,    !05807l0i
                                         pstm^amt2 ) then              !05807l0j
                        begin                                          !05807l0k
                        return false;                                  !05807l0l
                        end;                                           !05807l0m
                                                                       !05807l0n
                    if pstm.tran.amt^2 < 0f then                       !05807l0o
                        begin                                          !05807l0p
                        ssem.replacement.setl^amt.byte[ 0 ] ':=' "-";  !05807l0q
                        end;                                           !05807l0r
                    end                                                !05807l0s
                else                                                   !05807l0t
                    begin                                              !05807l0u
                    if not fixed^ascii^( ssem.replacement.amt,         !05807l0v
                                         pstm^amt2 ) then              !05807l0w
                        begin                                          !05807l0x
                        return false;                                  !05807l0y
                        end;                                           !05807l0z
                    end;                                               !05807l10
                                                                       !05807l11
                                                                       !05807l12
                                                                       !05807l13
                                                                       !05807l14
                end                                                    !05807L48
            else                                                       !05807L49
                begin                                                  !05807L4A
                if  not fixed^ascii^( ssem.replacement.amt,            !05807L4B
                                      $abs( pstm.tran.amt^2 ) ) then   !05807L4C
                    return false;                                      !05807L4D
                end;                                                   !05807L4E
            if  pstm.tran.amt^2 < 0f then                              !05807L4F
                ssem.replacement.amt.byte[0] ':=' "-";                 !05807L4G
                                                                       !05807P00
                                                                       !05807l15
                                                                       !05807l16
            mov^( ssem.replacement.tran^fee, zeroes );                 !05807P02
            mov^( ssem.replacement.setl^fee, zeroes );                 !05807P03
                                                                       !05807P04
            end;                                                       !05807L4H
        end;                                                           !05807L4I
                                                                       !05807L4J
    if  pstm.typ = pstm^response^d then                                !05807L4K
        begin                                                          !05807L4L
        if  pstm^inquiry^d( pstm ) then                                !05807L4M
            begin                                                      !05807L4N
                                                                       !N0580700
            if psem.crncy^cde = local^crncy^cde^g for                  !N0580701
                                    $len( psem.crncy^cde ) then        !N0580702
                begin                                                  !N0580703
                if not fixed^ascii^( psem.tran^amt,                    !N0580704
                                     $abs( pstm.tran.amt^1 ) ) then    !N0580705
                    begin                                              !N0580706
                    return false;                                      !N0580707
                    end;                                               !N0580708
                                                                       !N0580709
                if pstm.tran.amt^1 < 0f then                           !N058070A
                    begin                                              !N058070B
                    psem.tran^amt.byte[ 0 ] ':=' "-";                  !N058070C
                    end;                                               !N058070D
                end;                                                   !N058070E
                                                                       !N058070F
            set( pstm^amt, $abs( pstm.tran.amt^1 ) );                  !N058070G
                                                                       !N058070H
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L4O
                                     for $len( pct.crncy^cde ) then    !05807L4P
                begin                                                  !05807L4Q
                                                                       !N058070I
                                                                       !N058070J
                if  not sub^convert^fixed^amt( pstm^amt,               !05807L4S
                                           pct.crncy.buy^rate ) then   !05807L4T
                    return false;                                      !05807L4U
                                                                       !N058070K
                end;                                                   !N058070L
            if use^setl^crncy^amts^d( psem ) then                      !N058070M
                begin                                                  !N058070N
                if not fixed^ascii^( psem.setl^amt, pstm^amt ) then    !N058070O
                    begin                                              !N058070P
                    return false;                                      !N058070Q
                    end;                                               !N058070R
                                                                       !N058070S
                if pstm.tran.amt^1 < 0f then                           !N058070T
                    begin                                              !N058070U
                    psem.setl^amt.byte[ 0 ] ':=' "-";                  !N058070V
                    end;                                               !N058070W
                end ! of if use^setl^crncy^amts^d( psem )             !!N058070X
            else                                                       !N058070Y
                begin                                                  !N058070Z
                if not fixed^ascii^( psem.tran^amt,                    !N058070a
                                     $abs( pstm^amt ) ) then           !N058070b
                    begin                                              !N058070c
                    return false;                                      !N058070d
                    end;                                               !N058070e
                if pstm.tran.amt^1 < 0f then                           !N058070f
                    begin                                              !N058070g
                    psem.tran^amt.byte[ 0 ] ':=' "-";                  !N058070h
                    end;                                               !N058070i
                end; ! of NOT if use^setl^crncy^amts^d( psem )        !!N058070j
                                                                       !N058070k
                                                                       !N058070l
                                                                       !N058070m
                                                                       !N058070n
            end;                                                       !05807L57
        if  psem.setl^crncy <> blanks for $len( psem.setl^crncy ) then !05807L58
            begin                                                      !05807L59
            mov^( psem.bill^crncy,    local^crncy^cde^g );             !05807L5A
            move( psem.bill^conv^rat, pct.crncy.buy^rate );            !05807L5B
            if  not fixed^ascii^( psem.bill^amt,                       !05807L5C
                                  $abs( pstm.tran.amt^1 ) ) then       !05807L5D
                return false;                                          !05807L5E
            if  pstm.tran.amt^1 < 0f then                              !05807L5F
                psem.bill^amt.byte[ 0 ] ':=' "-";                      !05807L5G
            end;                                                       !05807L5H
        end;                                                           !05807L5I
                                                                       !05807L5J
!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*====================================================================*
!@ BEGIN RPQ #500 Send Additional Amount in Rqeust Transactions
!*--------------------------------------------------------------------*

        if  pct.crncy^cde <> local^crncy^cde^g
                                 for $len( pct.crncy^cde ) then
            begin
            set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );
            if  not sub^convert^fixed^amt( pstm^amt2,
                     pstm.tran.mult^crncy.setl^conv^rate ) then
                return false;
            if  not fixed^ascii^( psem.add^amts.b24^def.amt,
                                  pstm^amt2 ) then
                return false;
            psem.add^amts.len ':=' "012";
            if  pstm.tran.amt^2 < 0f  then
                psem.add^amts.b24^def.amt.byte[0] ':=' "-";
            end
        else
            begin
            if  fixed^ascii^( psem.add^amts.b24^def.amt,
                              $abs( pstm.tran.amt^2 ) ) then
                begin
                psem.add^amts.len ':=' "012";
                if  pstm.tran.amt^2 < 0f  then
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";
                end;
            end;

!*--------------------------------------------------------------------*
!@ END   RPQ #500 Send Additional Amount in Request Transactions
!*====================================================================*
!# END   RPQ #26B Send Additional Amount in Request Transactions
!**********************************************************************

    if  pstm.typ = pstm^rvsl^request^d then                            !05807L5K
        begin                                                          !05807L5L
        if  pct.crncy^cde <> local^crncy^cde^g                         !05807L5M
                                     for $len( pct.crncy^cde ) then    !05807L5N
            begin                                                      !05807L5O
            set ( pstm^amt, pstm.tran.amt^1 );                         !05807L5P
            if  not sub^convert^fixed^amt( pstm^amt,                   !05807L5Q
                                           pct.crncy.buy^rate ) then   !05807L5R
                return false;                                          !05807L5S
            if  not fixed^ascii^( psem.setl^amt, pstm^amt ) then       !05807L5T
                return false;                                          !05807L5U
            move( psem.setl^crncy,    pct.crncy^cde      );            !05807L5V
            move( psem.setl^conv^rat, pct.crncy.buy^rate );            !05807L5W
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !05807L5X
                                                                       !05807L5Y
            ! because this transaction will be logged to the ILF after!
            ! being added to the SAF, the mult^crncy fields need to be!
            ! set so the amounts can be logged in the settlement!      !05807L60
            ! currency.!                                               !05807L61
            move( pstm.tran.mult^crncy.setl^crncy^cde, pct.crncy^cde );
            move( pstm.tran.mult^crncy.setl^conv^rate,                 !05807L64
                                                                       !05807i0G
                  pct.crncy.buy^rate );                                !05807i0H
                                                                       !05807i0I
                                                                       !05807i0J
                                                                       !05807i0K
            end;                                                       !05807L66
        if  not fixed^ascii^( psem.tran^amt, pstm.tran.amt^1 ) then    !05807L67
            return false;                                              !05807L68
                                                                       !05807e0F
        mov^( psem.crncy^cde, pstm.orig^crncy^cde  );                  !05807e0G
                                                                       !05807e0H
                                                                       !05807e0I
                                                                       !05807e0J
                                                                       !05807L6A
        if  pct.crncy^cde <> local^crncy^cde^g                         !05807L6B
                                     for $len( pct.crncy^cde ) then    !05807L6C
            begin                                                      !05807L6D
            set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );                !05807L6E
            if  not sub^convert^fixed^amt( pstm^amt2,                  !05807L6F
                                           pct.crncy.buy^rate ) then   !05807L6G
                return false;                                          !05807L6H
                                                                       !05807l17
            if enhanced^crncy^conv^pos^d then                          !05807l18
                begin                                                  !05807l19
                if not fixed^ascii^( ssem.replacement.amt,             !05807l1A
                                     $abs( pstm.tran.amt^2 ) ) then    !05807l1B
                    begin                                              !05807l1C
                    return false;                                      !05807l1D
                    end;                                               !05807l1E
                                                                       !05807l1F
                if not fixed^ascii^( ssem.replacement.setl^amt,        !05807l1G
                                     pstm^amt2 ) then                  !05807l1H
                    begin                                              !05807l1I
                    return false;                                      !05807l1J
                    end;                                               !05807l1K
                                                                       !05807l1L
                if pstm.tran.amt^2 < 0f then                           !05807l1M
                    begin                                              !05807l1N
                    ssem.replacement.setl^amt.byte[ 0 ] ':=' "-";      !05807l1O
                    end;                                               !05807l1P
                end                                                    !05807l1Q
            else                                                       !05807l1R
                begin                                                  !05807l1S
                if not fixed^ascii^( ssem.replacement.amt,             !05807l1T
                                     pstm^amt2 ) then                  !05807l1U
                    begin                                              !05807l1V
                    return false;                                      !05807l1W
                    end;                                               !05807l1X
                mov^( ssem.replacement.setl^amt, zeroes );             !05807l1Y
                end;                                                   !05807l1Z
                                                                       !05807l1a
                                                                       !05807l1b
                                                                       !05807l1c
                                                                       !05807l1d
            if  pstm.tran.amt^2 < 0f  then                             !05807L6L
                ssem.replacement.amt.byte[0] ':=' "-";                 !05807L6M
                                                                       !05807P05
                                                                       !05807l1e
!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*--------------------------------------------------------------------*

            if  not fixed^ascii^( psem.add^amts.b24^def.amt,
                                  pstm^amt2 ) then
                return false;
            psem.add^amts.len ':=' "012";
            if  pstm.tran.amt^2 < 0f  then
                psem.add^amts.b24^def.amt.byte[0] ':=' "-";

!*--------------------------------------------------------------------*
!# END   RPQ #26B Send Additional Amount in Rqeust Transactions
!**********************************************************************
                                                                       !05807l1f
            mov^( ssem.replacement.tran^fee, zeroes );                 !05807P07
            mov^( ssem.replacement.setl^fee, zeroes );                 !05807P08
                                                                       !05807P09
            end                                                        !05807L6N
        else                                                           !05807L6O
            begin                                                      !05807L6P
            if  not fixed^ascii^( ssem.replacement.amt,                !05807L6Q
                                  $abs( pstm.tran.amt^2 ) ) then       !05807L6R
                return false;                                          !05807L6S
            if  pstm.tran.amt^2 < 0f  then                             !05807L6T
                ssem.replacement.amt.byte[0] ':=' "-";                 !05807L6U
                                                                       !05807P0A
!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*--------------------------------------------------------------------*
            if  fixed^ascii^( psem.add^amts.b24^def.amt,
                              $abs( pstm.tran.amt^2 ) ) then
                begin
                psem.add^amts.len ':=' "012";
                if  pstm.tran.amt^2 < 0f  then
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";
                end;
!*--------------------------------------------------------------------*
!# END   RPQ #26B Send Additional Amount in Rqeust Transactions
!**********************************************************************
            mov^( ssem.replacement.tran^fee, zeroes );                 !05807P0C
            mov^( ssem.replacement.setl^fee, zeroes );                 !05807P0D
                                                                       !05807P0E
            end;                                                       !05807L6V
                                                                       !05807L6W
                                                                       !05807Z07
        if pstm^cash^back^d( pstm )          or                        !05807Z08
           pre^auth^cash^back^d( pstm )      or                        !05807Z09
           pre^auth^comp^cash^back^d( pstm ) then                      !05807Z0A
                                                                       !05807Z0B
                                                                       !05807Z0C
                                                                       !05807Z0D
            begin                                                      !05807L6Y
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L6Z
                                     for $len( pct.crncy^cde ) then    !05807L70
                begin                                                  !05807L71
                set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );            !05807L72
                if  not sub^convert^fixed^amt( pstm^amt2,              !05807L73
                                           pct.crncy.buy^rate ) then   !05807L74
                    return false;                                      !05807L75
                                                                       !05807l1g
                if enhanced^crncy^conv^pos^d then                      !05807l1h
                    begin                                              !05807l1i
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l1j
                               $abs( pstm.tran.amt^2 ) ) then          !05807l1k
                        begin                                          !05807l1l
                        return false;                                  !05807l1m
                        end;                                           !05807l1n
                                                                       !05807l1o
                    if not fixed^ascii^(                               !05807l1p
                               psem.add^amts.b24^def.setl^amt,         !05807l1q
                               pstm^amt2 ) then                        !05807l1r
                        begin                                          !05807l1s
                        return false;                                  !05807l1t
                        end;                                           !05807l1u
                                                                       !05807l1v
                    psem.add^amts.len ':=' "024";                      !05807l1w
                                                                       !05807l1x
                    if pstm.tran.amt^2 < 0f then                       !05807l1y
                        begin                                          !05807l1z
                        psem.add^amts.b24^def.setl^amt.byte[ 0 ] ':='  !05807l20
                            "-";                                       !05807l21
                        end;                                           !05807l22
                    end                                                !05807l23
                else                                                   !05807l24
                    begin                                              !05807l25
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l26
                                         pstm^amt2 ) then              !05807l27
                        begin                                          !05807l28
                        return false;                                  !05807l29
                        end;                                           !05807l2A
                    psem.add^amts.len ':=' "012";                      !05807l2B
                    end;                                               !05807l2C
                                                                       !05807l2D
                                                                       !05807l2E
                                                                       !05807l2F
                                                                       !05807l2G
                if  pstm.tran.amt^2 < 0f  then                         !05807L7A
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";        !05807L7B
                end                                                    !05807L7C
            else                                                       !05807L7D
                begin                                                  !05807L7E
                if  not fixed^ascii^( psem.add^amts.b24^def.amt,       !05807L7F
                                  $abs( pstm.tran.amt^2 ) ) then       !05807L7G
                    return false;                                      !05807L7H
                psem.add^amts.len ':=' "012";                          !05807L7I
                if  pstm.tran.amt^2 < 0f  then                         !05807L7J
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";        !05807L7K
                end;                                                   !05807L7L
            end;                                                       !05807L7M
        end;                                                           !05807L7N
                                                                       !05807L7O
    if  pstm.typ = pstm^rvsl^advice^d then                             !05807L7P
        begin                                                          !05807L7Q
        if  pct.crncy^cde <> local^crncy^cde^g                         !05807L7R
                                     for $len( pct.crncy^cde ) then    !05807L7S
            begin                                                      !05807L7T
            set ( pstm^amt, pstm.tran.amt^1 );                         !05807L7U
                                                                       !05807l2H
                                                                       !05807v00
            move( pstm.tran.mult^crncy.setl^crncy^cde,                 !05807v01
                  pct.crncy^cde );                                     !05807v02
            move( pstm.tran.mult^crncy.setl^conv^rate,                 !05807v03
                  pct.crncy.buy^rate );                                !05807v04
                                                                       !05807v05
                                                                       !05807v06
                                                                       !05807v07
                                                                       !05807v08
                                                                       !05807l2Z
            if  not sub^convert^fixed^amt( pstm^amt,                   !05807L7V
                         pstm.tran.mult^crncy.setl^conv^rate ) then    !05807L7W
                return false;                                          !05807L7X
            if  not fixed^ascii^( psem.setl^amt,                       !05807L7Y
                                  pstm^amt ) then                      !05807L7Z
                return false;                                          !05807L80
            move( psem.setl^crncy,                                     !05807L81
                             pstm.tran.mult^crncy.setl^crncy^cde );    !05807L82
            move( psem.setl^conv^rat,                                  !05807L83
                             pstm.tran.mult^crncy.setl^conv^rate );    !05807L84
            pstm.tran.mult^crncy.conv^dat^tim := juliantimestamp();    !05807L85
            end;                                                       !05807L86
        if  not fixed^ascii^( psem.tran^amt, pstm.tran.amt^1 ) then    !05807L87
            return false;                                              !05807L88
                                                                       !A0580700
        if  pstm.tran.amt^2 > 0f and                                   !A0580701
            not ( pstm^cash^back^d( pstm ) or                          !A0580702
                  pre^auth^cash^back^d( pstm ) or                      !A0580703
                  pre^auth^comp^cash^back^d( pstm ) ) then             !A0580704
                                                                       !A0580705
                                                                       !A0580706
                                                                       !A0580707
            begin                                                      !05807L8A
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L8B
                                     for $len( pct.crncy^cde ) then    !05807L8C
                begin                                                  !05807L8D
                set ( pstm^amt2, pstm.tran.amt^2 );                    !05807L8E
                if  not sub^convert^fixed^amt( pstm^amt2,              !05807L8F
                         pstm.tran.mult^crncy.setl^conv^rate ) then    !05807L8G
                    return false;                                      !05807L8H
                                                                       !05807l2a
                if enhanced^crncy^conv^pos^d then                      !05807l2b
                    begin                                              !05807l2c
                    if not fixed^ascii^( ssem.replacement.amt,         !05807l2d
                                         pstm.tran.amt^2 ) then        !05807l2e
                        begin                                          !05807l2f
                        return false;                                  !05807l2g
                        end;                                           !05807l2h
                                                                       !05807l2i
                    if not fixed^ascii^( ssem.replacement.setl^amt,    !05807l2j
                                         pstm^amt2 ) then              !05807l2k
                        begin                                          !05807l2l
                        return false;                                  !05807l2m
                        end;                                           !05807l2n

!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!---------------------------------------------------------------------*
                    psem.add^amts.len ':=' "012";
                    if  pstm.tran.amt^2 < 0f  then
                         psem.add^amts.b24^def.amt.byte[0] ':=' "-";
!---------------------------------------------------------------------*
!# END   RPQ #26B Send Additional Amount in Rqeust Transactions
!**********************************************************************

                    end                                                !05807l2o
                else                                                   !05807l2p
                    begin                                              !05807l2q
                    if not fixed^ascii^( ssem.replacement.amt,         !05807l2r
                                         pstm^amt2 ) then              !05807l2s
                        begin                                          !05807l2t
                        return false;                                  !05807l2u
                        end;                                           !05807l2v
                    mov^( ssem.replacement.setl^amt, zeroes );         !05807l2w
                    end;                                               !05807l2x
                                                                       !05807l2y
                                                                       !05807l2z
                                                                       !05807l30
                                                                       !05807l31
                mov^( ssem.replacement.tran^fee, zeroes );             !05807P0H
                mov^( ssem.replacement.setl^fee, zeroes );             !05807P0I
                                                                       !05807P0J
                end                                                    !05807L8L
            else                                                       !05807L8M
                begin                                                  !05807L8N
                if  not fixed^ascii^( ssem.replacement.amt,            !05807L8O
                                      pstm.tran.amt^2 ) then           !05807L8P
                    return false;                                      !05807L8Q
                                                                       !05807P0K
!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*--------------------------------------------------------------------*

                if  not fixed^ascii^( psem.add^amts.b24^def.amt,
                                      pstm.tran.amt^2 ) then
                    return false;
                psem.add^amts.len ':=' "012";
                if  pstm.tran.amt^2 < 0f  then
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";

!*--------------------------------------------------------------------*
!# END   RPQ #26B Send Additional Amount in Rqeust Transactions
!**********************************************************************

                mov^( ssem.replacement.setl^amt, zeroes );             !05807P0L
                mov^( ssem.replacement.tran^fee, zeroes );             !05807P0M
                mov^( ssem.replacement.setl^fee, zeroes );             !05807P0N
                                                                       !05807P0O
                end;                                                   !05807L8R

!**********************************************************************
!# BEGIN RPQ #26B Send Additional Amount in Rqeust Transactions
!*--------------------------------------------------------------------*
-- *        end;                                                       !05807L8S


            end
        else
          begin
           if  fixed^ascii^( psem.add^amts.b24^def.amt,
                             $abs( pstm.tran.amt^2 ) ) then
               begin
               psem.add^amts.len ':=' "012";
               if  pstm.tran.amt^2 < 0f  then
                   psem.add^amts.b24^def.amt.byte[0] ':=' "-";
               end;
          end;
!*--------------------------------------------------------------------*
!# END   RPQ #26B Send Additional Amount in Rqeust Transactions
!**********************************************************************
                                                                       !05807L8T
                                                                       !05807Z0E
        if pstm^cash^back^d( pstm )          or                        !05807Z0F
           pre^auth^cash^back^d( pstm )      or                        !05807Z0G
           pre^auth^comp^cash^back^d( pstm ) then                      !05807Z0H
                                                                       !05807Z0I
                                                                       !05807Z0J
                                                                       !05807Z0K
            begin                                                      !05807L8V
            if  pct.crncy^cde <> local^crncy^cde^g                     !05807L8W
                                     for $len( pct.crncy^cde ) then    !05807L8X
                begin                                                  !05807L8Y
                set ( pstm^amt2, $abs( pstm.tran.amt^2 ) );            !05807L8Z
                if  not sub^convert^fixed^amt( pstm^amt2,              !05807L90
                         pstm.tran.mult^crncy.setl^conv^rate ) then    !05807L91
                    return false;                                      !05807L92
                                                                       !05807l32
                if enhanced^crncy^conv^pos^d then                      !05807l33
                    begin                                              !05807l34
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l35
                               $abs( pstm.tran.amt^2 ) ) then          !05807l36
                        begin                                          !05807l37
                        return false;                                  !05807l38
                        end;                                           !05807l39
                                                                       !05807l3A
                    if not fixed^ascii^(                               !05807l3B
                               psem.add^amts.b24^def.setl^amt,         !05807l3C
                               pstm^amt2 ) then                        !05807l3D
                        begin                                          !05807l3E
                        return false;                                  !05807l3F
                        end;                                           !05807l3G
                                                                       !05807l3H
                    psem.add^amts.len ':=' "024";                      !05807l3I
                                                                       !05807l3J
                    if pstm.tran.amt^2 < 0f then                       !05807l3K
                        begin                                          !05807l3L
                        psem.add^amts.b24^def.setl^amt.byte[ 0 ] ':='  !05807l3M
                            "-";                                       !05807l3N
                        end;                                           !05807l3O
                    end                                                !05807l3P
                else                                                   !05807l3Q
                    begin                                              !05807l3R
                    if not fixed^ascii^( psem.add^amts.b24^def.amt,    !05807l3S
                                         pstm^amt2 ) then              !05807l3T
                        begin                                          !05807l3U
                        return false;                                  !05807l3V
                        end;                                           !05807l3W
                    psem.add^amts.len ':=' "012";                      !05807l3X
                    end;                                               !05807l3Y
                                                                       !05807l3Z
                                                                       !05807l3a
                                                                       !05807l3b
                                                                       !05807l3c
                if  pstm.tran.amt^2 < 0f  then                         !05807L97
                    psem.add^amts.b24^def.amt.byte[0] ':=' "-";        !05807L98
                end                                                    !05807L99
            else                                                       !05807L9A
                begin                                                  !05807L9B
                if  fixed^ascii^( psem.add^amts.b24^def.amt,           !05807L9C
                                  $abs( pstm.tran.amt^2 ) ) then       !05807L9D
                    begin                                              !05807L9E
                    psem.add^amts.len ':=' "012";                      !05807L9F
                    if  pstm.tran.amt^2 < 0f  then                     !05807L9G
                        psem.add^amts.b24^def.amt.byte[0] ':=' "-";    !05807L9H
                    end;                                               !05807L9I
                end;                                                   !05807L9J
            end;                                                       !05807L9K
        end;                                                           !05807L9L
                                                                       !05807L9M
    return true;                                                       !05807L9N
    end;                                                               !05807L9O
                                                                       !05807L9P
                                                                       !05807L9Q
?section pstm^frmt^b24^to^pos^sem                                      !05808
?page "                                - pstm^frmt^b24^to^pos^sem"     !05808K00
!#####################################################################!!05811
!#                                                                   #!!05812
!#                    PSTM^FRMT^B24^TO^POS^SEM                       #!!05813
!#                                                                   #!!05814
!#    NARRATIVE : THIS PROCEDURE FORMATS A STANDARD INTERNAL MESSAGE #!!05815
!#       INTO AN EXTERNAL MESSAGE ( 0100, 0200, OR 0220 ) SERIES     #!!05816
!#       MESSAGE.                                                    #!!05817
!#                                                                   #!!05818
!#    INPUT PARAMETERS:                                              #!!05819
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!05820
!#                                                                   #!!05821
!#    OUTPUT PARAMETERS:                                             #!!05822
!#       SEM           : POINTER TO BIC ISO EXTERNAL MESSAGE         #!!05823
!#                                                                   #!!05824
!#####################################################################!!05825
proc pstm^frmt^b24^to^pos^sem( pstm, sem );                            !05826
struct  .pstm( pstm^def );                                             !05827
struct  .sem( sem^def );                                               !05828
    begin                                                              !05829
                                                                       !05829K00
    struct .address( p63^addr^def );                                   !05829K01
                                                                       !05829K02
    int                                                                !05829K03
        prvt4^lgth;                                                    !05829K04
                                                                       !05829K05
                                                                       !05829)00
    int             datalgth      := 26;                               !05829)01
    int             exp^date^lgth := 4;                                !05829)02
                                                                       !05829)03
    string         .discdata[ 0:25 ] := [ 26 * [" "] ];                !05829)04
                                                                       !05829)05
                                                                       !05829K06
                                                                       !05829K07
                                                                       !05829K08
                                                                       !05830
!*===================================================================*!
!* BEGIN RPQ #27 - Handle Transactions with IVA                -     *!
!*-------------------------------------------------------------------*!
    int     .user^data( user^data^def );
    string  .priv^field( privfield^def );
    string  .last;
!*-------------------------------------------------------------------*!
!* END   RPQ #27 - Handle Transactions with IVA                -     *!
!*===================================================================*!

    init ( sem, "  ", wlen( sem ) );                                   !05831
                                                                       !05832
    movd ( psem.strt^of^txt,            iso^identifier^d           );  !05833
    move ( psem.prod^id,                pstm.prod^id               );  !05834
                                                                       !05834K00
                                                                       !05834U00
    if pct.options.version^num = "60" then                             !05834U01
        begin                                                          !05834U02
        movd( psem.rel^num, release^6^frmt^d );                        !05834U03
        end ! of if pct.options.version^num = "60"                   ! !05834U04
    else                                                               !05834U05
    if pct.options.version^num = "01" then                             !05834U06
        begin                                                          !05834U07
        movd( psem.rel^num, release^5^frmt^d );                        !05834U08
        end ! of if pct.options.version^num = "01"                   ! !05834U09
    else                                                               !05834U0A
        begin                                                          !05834U0B
        movd( psem.rel^num, release^4^frmt^d );                        !05834U0C
        end; ! of else                                               ! !05834U0D
                                                                       !05834U0E
                                                                       !05834U0F
                                                                       !05834U0G
                                                                       !05834U0H
                                                                       !05834K05
                                                                       !05835K00
                                                                       !05835K01
    mov^ ( psem.stat,                   zeroes                     );  !05836
    move ( psem.originator,             pstm.originator            );  !05837
    move( psem.responder,              pstm.responder             );   !05838
    mov^ ( psem.tran^tim,               pstm.tran^tim              );  !05839
    mov^ ( psem.tran^dat,               pstm.tran^dat.mm           );  !05840
    mov^ ( psem.cap^dat,                pstm.post^dat.mm           );  !05841
    move ( psem.retrvl^ref^num,         pstm.seq^num               );  !05842
    move ( psem.term^id,                pstm.term^id               );  !05843
!**********************************************************************
! BEGIN RPQ #AJGA - Ajuste GANO
!**********************************************************************
    if pstm.typ = "0220"             and
       pstm.tran.apprv^cde = " GANO"   then
       begin
        psem.auth^id^resp^len := 6;
        psem.auth^id^resp    ':=' "*GANO*";
        pstm.tran.apprv^cde  ':=' "*GANO*";
      end
    else
    begin
    move ( psem.auth^id^resp^len,       pstm.tran.apprv^cde^lgth   );  !05844
    move ( psem.auth^id^resp,           pstm.tran.apprv^cde        );  !05845
    end;
!**********************************************************************
! END   RPQ #AJGA - Ajuste GANO
!**********************************************************************

    move ( psem.crd^accpt^id^cde,       pstm.crd^accpt^id^num      );  !05846

!@==================================================================*!
!@  Begin RPQ #79 / RPQ #Propina  per     - MPI -                    !
!@------------------------------------------------------------------*!
    psem.crd^accpt^id^cde.byte[0] ':='
             pstm.crd^accpt^id^num.byte[0] for 4;
    psem.crd^accpt^id^cde.byte[4] ':='
             pstm.crd^accpt^id^num.byte[6] for 5;
    psem.crd^accpt^id^cde.byte[9] ':=' pstm.zip^cde.byte[0] for 4;
!@------------------------------------------------------------------*!
!@  End   RPQ #79 / RPQ #Propina  per     - MPI -                    !
!@==================================================================*!

    move ( psem.mbr^num,                pstm.tran.mbr^num          );  !05847
    move ( psem.crncy^cde,              pstm.orig^crncy^cde        );  !05848
    move ( psem.pos^pin^capture^cde,    pstm.pin^size              );  !05849
    move ( psem.exp^dat,                pstm.tran.exp^dat          );  !05850
                                                                       !05851
                                                                       !05851)00
    !                                                                 !!05851)01
    ! Retrieve the expiration date from the discretionary data if the !!05851)02
    ! prefix wasn't configured on the CPF.                            !!05851)03
    !                                                                 !!05851)04
    if pstm.tran.exp^dat = zeroes for $len( pstm.tran.exp^dat ) then   !05851)05
        begin                                                          !05851)06
        call hiswutil^extract^track2^info( pstm.tran.track2,           !05851)07
                                           $len( pstm.tran.track2 ),   !05851)08
                                           ! pan !,                    !05851)09
                                           ! panlgth !,                !05851)0A
                                           discdata,                   !05851)0B
                                           datalgth );                 !05851)0C
                                                                       !05851)0D
        if discdata <> blanks for datalgth and                         !05851)0E
           discdata <> zeroes for exp^date^lgth then                   !05851)0F
            begin                                                      !05851)0G
            call hiswutil^exp^dat^yymm( discdata, psem.exp^dat );      !05851)0H
            end;                                                       !05851)0I
        end;                                                           !05851)0J
                                                                       !05851)0K
    move ( psem.setl^conv^rat, pstm.tran.mult^crncy.setl^conv^rate );  !05852
    move ( psem.mrcht^typ^cde,          pstm.retl^sic^cde          );  !05853
    move ( psem.entry^mde,              pstm.pt^srv^entry^mde      );  !05854
    move ( psem.pt^tran^spcl^cde,       pstm.pt^srv^cond^cde       );  !05855
                                                                       !05856
    movd ( psem.add^data^prvt.len,                "027"            );  !05857
    move ( psem.add^data^prvt.pos.retl^id,        pstm.retl^id     );  !05858
    move ( psem.add^data^prvt.pos.retl^regn,      pstm.retl^regn   );  !05859
    move ( psem.add^data^prvt.pos.retl^grp,       pstm.retl^grp    );  !05860
                                                                       !05861
    movd ( psem.pri^rsrvd1^prvt.len,               "016"           );  !05862
    move ( psem.pri^rsrvd1^prvt.pos.term^fiid,     pstm.term^fiid  );  !05863
    move ( psem.pri^rsrvd1^prvt.pos.term^ln,       pstm.term^ln    );  !05864
    move ( psem.pri^rsrvd1^prvt.pos.pseudo^term^id,                    !05865
        pstm.tran.pseudo^term^id );                                    !05866
                                                                       !05867
    if  integer^ascii^( psem.pri^rsrvd1^prvt.pos.term^time^ofst,       !05868
            $abs( pstm.term^tim^ofst ) ) then                          !05869
        begin                                                          !05870
        psem.pri^rsrvd1^prvt.pos.term^time^ofst.byte :=                !05871
            if pstm.term^tim^ofst < 0 then "-" else "+";               !05872
        end;                                                           !05873
                                                                       !05874
    movd ( psem.pri^rsrvd2^prvt.len,           "019"                 );
    move ( psem.pri^rsrvd2^prvt.pos.crd^fiid,  pstm.tran.crd^fiid    );
    move ( psem.pri^rsrvd2^prvt.pos.crd^ln,    pstm.tran.crd^ln      );
    move ( psem.pri^rsrvd2^prvt.pos.category,  pstm.tran.tran^cde.c  );
    move ( psem.pri^rsrvd2^prvt.pos.save^acct^typ,                     !05883
        pstm.tran.save^acct^typ );                                     !05884
    move ( psem.pri^rsrvd2^prvt.pos.ichg^resp, pstm.tran.ichg^resp   );
                                                                       !05887
    movd ( psem.pri^rsrvd3^prvt.len,           "010"                 );
    move ( psem.pri^rsrvd3^prvt.b24^def.postal^cde, pstm.postal^cde  );
                                                                       !05892
    move ( psem.crd^accpt^name^loc.term^owner, pstm.term^owner^name  );
    move ( psem.crd^accpt^name^loc.term^city,  pstm.term^city        );
    move ( psem.crd^accpt^name^loc.term^st,    pstm.term^st          );
    move( psem.crd^accpt^name^loc.term^cntry,  pstm.term^cntry^cde   );
                                                                       !05901
    move( ssem.b24^orig.orig^typ,              pstm.orig^data.msg^typ );
    move( ssem.b24^orig.orig^tran^dat,         pstm.orig^data.trn^dat );
    move( ssem.b24^orig.orig^tran^tim,         pstm.orig^data.trn^tim );
    move( ssem.b24^orig.orig^b24^post^dat,                             !05908
                                            pstm.orig^data.b24^post^dat );
    move( ssem.b24^orig.orig^seq^num,       pstm.orig^data.tran^seq^num );

!*********************************************************************!
!* BEGIN RPQ #27 - Handle Transactions with IVA                -     *!
!*-------------------------------------------------------------------*!

    @user^data := @pstm.srvcs[ $min( $occurs( pstm.srvcs ),
                                      pstm.num^services ) ]  '>>' 1;
    !
    ! priv^field is being mapped to the second byte, because the first
    ! byte is used as term^type in the HPDHS.  The priv^fields needed
    ! start after the term^type.
    !
    @priv^field := @user^data.info.byte[1];

    rscan
       priv^field.rpq^priv^data.byte[ $len(priv^field.rpq^priv^data)-1]
                                        while " " -> @last;
    if  integer^ascii^( psem.add^data^natl.len,
                       $min( ( @last - (@priv^field.rpq^priv^data - 1)),
                               $len( priv^field.rpq^priv^data ) ) ) then
        begin
         psem.add^data^natl.data ':='
                          [ $len( priv^field.rpq^priv^data ) * [" "]];
         movl(  psem.add^data^natl.data,
                priv^field.rpq^priv^data,
                $min( ( @last - ( @priv^field.rpq^priv^data - 1 ) ),
                $len( priv^field.rpq^priv^data ) ) );
         end;

    if ( psem.add^data^natl.len = "000" or
         psem.add^data^natl.len = "   "   ) then
       begin
        psem.add^data^natl.len ':=' "012";
        psem.add^data^natl.data.byte[0] ':=' "000000000000";
       end;


!   movd( psem.add^data^natl.len,                "012"            );
!   psem.add^data^natl.data ':=' priv^field.rpq^priv^data.byte[0] for
!                                12;

!*-------------------------------------------------------------------*!
!* END   RPQ #27 - Handle Transactions with IVA                -     *!
!*********************************************************************!


    mov^( ssem.secndry^rsrvd3^prvt.len,     zeroes                 );  !05913
                                                                       !05914
    call util^frmt^inst^id( pstm.crd^iss^id^num,                       !05915
       ssem.secndry^rsrvd3^prvt.len.byte[1],                           !05916
       ssem.secndry^rsrvd3^prvt.b24.crd^iss^id^num, 0 );               !05917
                                                                       !05918
    call util^frmt^inst^id( pstm.acq^inst^id^num,                      !05919
        psem.acq^inst^id.len, psem.acq^inst^id.num, 0 );               !05920
                                                                       !05921
    call util^frmt^inst^id( pstm.frwd^inst^id^num,                     !05922
        psem.frwd^inst^id.len, psem.frwd^inst^id.num, 0 );             !05923
                                                                       !05924
    call util^frmt^inst^id( pstm.rcv^inst^id^num,                      !05925
        ssem.rcv^inst.len, ssem.rcv^inst.id^num, 0 );                  !05926
                                                                       !05926j00
    if ovrrd^acq^inst^id^d then                                        !05926j01
        begin                                                          !05926j02
        !                                                             !!05926j03
        ! Move pct.swi^id (right justified, zero filled) into         !!05926j04
        ! psem.acq^inst^id.num (left justified, blank filled)         !!05926j05
        !                                                             !!05926j06
        call util^frmt^inst^id( pct.swi^id,                            !05926j07
                                psem.acq^inst^id.len,                  !05926j08
                                psem.acq^inst^id.num,                  !05926j09
                                int^to^ext^l );                        !05926j0A
        end;                                                           !05926j0B
                                                                       !05926j0C
    if ovrrd^frwd^inst^id^d then                                       !05926j0D
        begin                                                          !05926j0E
        !                                                             !!05926j0F
        ! Move pct.swi^id (right justified, zero filled) into         !!05926j0G
        ! psem.frwd^inst^id.num (left justified, blank filled)        !!05926j0H
        !                                                             !!05926j0I
        call util^frmt^inst^id( pct.swi^id,                            !05926j0J
                                psem.frwd^inst^id.len,                 !05926j0K
                                psem.frwd^inst^id.num,                 !05926j0L
                                int^to^ext^l );                        !05926j0M
        end;                                                           !05926j0N
                                                                       !05926j0O
    if ovrrd^rcv^inst^id^d then                                        !05926j0P
        begin                                                          !05926j0Q
        !                                                             !!05926j0R
        ! Move pct.acq^id^num (right justified, zero filled) into     !!05926j0S
        ! ssem.rcv^inst.id^num (left justified, blank filled)         !!05926j0T
        !                                                             !!05926j0U
        call util^frmt^inst^id( pct.acq^id^num,                        !05926j0V
                                ssem.rcv^inst.len,                     !05926j0W
                                ssem.rcv^inst.id^num,                  !05926j0X
                                int^to^ext^l );                        !05926j0Y
        end;                                                           !05926j0Z
                                                                       !05926j0a
                                                                       !05927
    movd ( ssem.secndry^rsrvd1^prvt.len,          "029"              );
    move ( ssem.secndry^rsrvd1^prvt.pos.term^name^loc,                 !05930
        pstm.term^name^loc );                                          !05931
    move ( ssem.secndry^rsrvd1^prvt.pos.brch^id,  pstm.brch^id       );
                                                                       !05934
    movd ( ssem.secndry^rsrvd2^prvt.len,           "020"             );
    move ( ssem.secndry^rsrvd2^prvt.pos.clerk^id,  pstm.clerk^id     );
    move ( ssem.secndry^rsrvd2^prvt.pos.crt^auth^grp,                  !05939
        pstm.crt^auth.grp );                                           !05940
    move ( ssem.secndry^rsrvd2^prvt.pos.crt^auth^user^id,              !05941
        pstm.crt^auth.user^id  );                                      !05942
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind,  pstm.rte.auth^ind );
    move ( ssem.secndry^rsrvd2^prvt.pos.auth^ind2, pstm.auth^ind2    );
    movd ( ssem.secndry^rsrvd4^prvt.len,           "020"             );
    move ( ssem.secndry^rsrvd4^prvt.pos.invoice^num,                   !05949
        pstm.invoice^num );                                            !05950
    move ( ssem.secndry^rsrvd4^prvt.pos.orig^invoice^num,              !05951
        pstm.orig^invoice^num  );                                      !05952
                                                                       !05953
    movd ( ssem.secndry^rsrvd5^prvt.len,           "009"             );
    move ( ssem.secndry^rsrvd5^prvt.pos.batch^seq^num,                 !05956
        pstm.batch^seq^num   );                                        !05957
    move ( ssem.secndry^rsrvd5^prvt.pos.batch^num, pstm.batch^num    );
    move ( ssem.secndry^rsrvd5^prvt.pos.shift^num, pstm.shift^num    );
                                                                       !05962
    movd ( ssem.secndry^rsrvd6^prvt.len,           "012"             );
    move ( ssem.secndry^rsrvd6^prvt.pos.orig,      pct.swi^typ       );
    movd ( ssem.secndry^rsrvd6^prvt.pos.dest,      "B24 "            );
    move ( ssem.secndry^rsrvd6^prvt.pos.setl^flg,  pstm.tran.setl^flg );
    move ( ssem.secndry^rsrvd6^prvt.pos.srv,       pstm.rte.srv      );
    move ( ssem.secndry^rsrvd6^prvt.pos.dft^capture^flg,               !05973
        pstm.tran.dft^capture^flg );                                   !05974
                                                                       !05975
    movd ( ssem.secndry^rsrvd7^prvt.len, "038" );                      !05976
    move ( ssem.secndry^rsrvd7^prvt.pos.pre^auth^seq^num,              !05977
        pstm.pre^auth^seq^num );                                       !05978
    move ( ssem.secndry^rsrvd7^prvt.pos.rfrl^phone,                    !05979
        pstm.tran.rfrl^phone );                                        !05980
    move ( ssem.secndry^rsrvd7^prvt.pos.rea^for^chrgbck,               !05981
        pstm.rea^for^chrgbck );                                        !05982
    move ( ssem.secndry^rsrvd7^prvt.pos.num^of^chrgbck,                !05983
        pstm.num^of^chrgbck );                                         !05984
                                                                       !05985
    call integer^ascii^( ssem.secndry^rsrvd7^prvt.pos.pre^auth^hld,    !05986
        pstm.tran.pre^auth^hld );                                      !05987
                                                                       !05988
    if  pstm.data^flag <> "0" then                                     !05989
        begin                                                          !05990
        call integer^ascii^(                                           !05991
            ssem.secndry^rsrvd8^prvt.len, pos^userdata^lgth^g );       !05992
                                                                       !05993
        movl ( ssem.secndry^rsrvd8^prvt.pos^user^data,                 !05994
            pos^userdata^g, pos^userdata^lgth^g );                     !05995
        end;                                                           !05996
                                                                       !05997
                                                                       !05997D00
    !!                                                                 !05997D01
    ! Transfer address and verification status from PSTM to SEM!       !05997D02
    !!                                                                 !05997D03
    if pstm.addr^typ = av^addr^typ^d then                              !05997D04
        begin                                                          !05997D05
                                                                       !05997K00
        !!                                                             !05997K01
        !if running as a previous release the address info will be!    !05997K02
        !processed in bit 63 the same as 3.4.  If running as release!  !05997K03
        !5.0 the address info will be added to the pstm and then the!  !05997K04
        !sem in a later proc.  This is so the address verification!    !05997K05
        !token is not suspended in extended memory.!                   !05997K06
        !!                                                             !05997K07
                                                                       !05997L00
                                                                       !05997U00
        if pct.options.version^num = "00" then                         !05997U01
                                                                       !05997U02
                                                                       !05997L02
                                                                       !05997L03
                                                                       !05997L04
            begin                                                      !05997K09
            !!                                                         !05997K0A
            ! Add address info to pri^rsrvd4^prvt.pos data!            !05997K0B
            !!                                                         !05997K0C
            if not ascii^integer^( psem.pri^rsrvd4^prvt.len,           !05997K0D
                                   prvt4^lgth ) then prvt4^lgth := 0;  !05997K0E
            if ( prvt4^lgth + av^data^item^lgth^l ) <                  !05997K0F
                $len( psem.pri^rsrvd4^prvt.pos.add^data ) then         !05997K0G
                begin                                                  !05997K0H
                init( address, "  ", wlen( address ) );                !05997K0I
                call integer^ascii( address.addr^lgth, 2,              !05997K0J
                                     ( av^data^item^lgth^l - 2 ) );    !05997K0K
                movd( address.addr^cde,   av^data^item^cde^d );        !05997K0L
                mov^( address.addr,       pstm.addr^flds.addr );       !05997K0M
                mov^( address.zip^cde,    pstm.zip^cde );              !05997K0N
                movl( psem.pri^rsrvd4^prvt.pos.add^data.               !05997K0O
                      byte[prvt4^lgth], address, wlen( address ) );    !05997K0P
                prvt4^lgth := prvt4^lgth + av^data^item^lgth^l;        !05997K0Q
                call integer^ascii^( psem.pri^rsrvd4^prvt.len,         !05997K0R
                                     prvt4^lgth );                     !05997K0S
                end;                                                   !05997K0T
            end;                                                       !05997K0U
        !!                                                             !05997K0V
        ! Transfer address verification status!                        !05997K0W
        !!                                                             !05997K0X
        move( psem.resp^data.pos.addr^vrfy^stat,                       !05997K0Y
              pstm.addr^flds.addr^vrfy^stat );                         !05997K0Z
        movd( psem.resp^data.len, "02" );                              !05997K10
        end;                                                           !05997K11
                                                                       !05997K12
                                                                       !05997K13
                                                                       !05997K14
                                                                       !05997K15
    end;                                                               !05998
                                                                       !05998K00
?section pstm^frmt^b24^to^pos^tkn                                      !05998K01
?page                         "pstm^frmt^b24^to^pos^tkn"               !05998K02
!#####################################################################!!05998K03
!#                                                                   #!!05998K04
!#                   PSTM^FRMT^B24^TO^POS^TKN                        #!!05998K05
!#                                                                   #!!05998K06
!#    This proc formats PSTM token data to SEM token data.           #!!05998K07
!#                                                                   #!!05998K08
!#    INPUT PARAMETERS:                                              #!!05998K09
!#        pstm    :  POS Standard Internal Message                   #!!05998K0A
!#        tkn^grp :  Token group                                     #!!05998K0B
!#                                                                   #!!05998K0C
!#    OUTPUT PARAMETERS:                                             #!!05998K0D
!#        sem     :  Standard External Message                       #!!05998K0E
!#                                                                   #!!05998K0F
!#    RETURNS:                                                       #!!05998K0G
!#        True  = Format was successful                              #!!05998K0H
!#        False = Format was not successful                          #!!05998K0I
!#                                                                   #!!05998K0J
!#####################################################################!!05998K0K
int proc pstm^frmt^b24^to^pos^tkn( pstm, sem, tkn^grp );               !05998K0L
struct         .pstm( pstm^def );                                      !05998K0M
struct         .sem( sem^def );                                        !05998K0N
string         .tkn^grp;                                               !05998K0O
                                                                       !05998K0P
    begin                                                              !05998K0Q
    struct                                                             !05998K0R
                   .tkn^mem^rec( tkn^mem^rec^def );                    !05998K0S
                                                                       !05998K0T
    string                                                             !05998K0U
                    subtyp  [0:1],                                     !05998K0V
                    token^id[0:1],                                     !05998K0W
                    typ     [0:1];                                     !05998K0X
                                                                       !05998K0Y
    movd( subtyp, tkn^dflt^subtyp^d );                                 !05998K0Z
    movd( typ,    financial^typ^d   );                                 !05998K10
                                                                       !05998K11
    if tkn^name^g <> invalid^name^d           and                      !05998K12
                                                                       !05998U00
       ( pct.options.version^num = "60" or                             !05998U01
         pct.options.version^num = "01" ) and                          !05998U02
                                                                       !05998U03
                                                                       !05998U04
                                                                       !05998U05
       get^tkn^mem^rec( pos^tkn^tbl,, tkn^grp, typ, subtyp,            !05998K14
                        tkn^mem^rec, trace^g.<pos^l> ) then            !05998K15
        begin                                                          !05998K16
        if not hiswtkn^frmt^int^tkn^to^ext^tkn(                        !05998K17
                             pct.options.fixed^lgth^frmt,              !05998K18
                             pos^l, pstm, pstm^lgth^d( pstm ),         !05998K19
                                                                       !05998M00
                       tkn^mem^rec, psem.pri^rsrvd4^prvt.pos.add^data, !05998M01
                            $len( psem.pri^rsrvd4^prvt.pos.add^data ), !05998M02
                                                                       !05998M03
                                                                       !05998M04
                                                                       !05998M05
                                                                       !05998M06
                             psem.pri^rsrvd4^prvt.len,                 !05998K1C
                             psem.retrvl^ref^num, psem.pan.data,       !05998K1D
                             pstm.data^flag ) then                     !05998K1E
                return false;                                          !05998K1F
        end                                                            !05998K1G
    else                                                               !05998K1H
        begin                                                          !05998K1I
        !!                                                             !05998K1J
        ! No tokens will be sent in the external message to the host.! !05998K1K
        ! If response, then data in suspended sem is cleared.!         !05998K1L
        !!                                                             !05998K1M
        if pct.options.fixed^lgth^frmt then                            !05998K1N
            call integer^ascii^( psem.pri^rsrvd4^prvt.len,             !05998K1O
                                                                       !05998M07
                           $len( psem.pri^rsrvd4^prvt.pos.add^data ) ) !05998M08
                                                                       !05998M09
                                                                       !05998M0A
                                                                       !05998M0B
        else                                                           !05998K1Q
            psem.pri^rsrvd4^prvt.len ':=' "000";                       !05998K1R
                                                                       !05998K1S
                                                                       !05998M0C
        psem.pri^rsrvd4^prvt.pos.add^data ':='                         !05998M0D
             [ $len( psem.pri^rsrvd4^prvt.pos.add^data ) * [ " " ] ];  !05998M0E
                                                                       !05998M0F
                                                                       !05998M0G
                                                                       !05998M0H
                                                                       !05998M0I
        end;                                                           !05998K1V
                                                                       !05998K1W
    return true;                                                       !05998K1X
    end;                                                               !05998K1Y
                                                                       !05998K1Z
?section pstm^frmt^b24^to^pos^tran                                     !05999
?page "                               - pstm^frmt^b24^to^pos^tran"     !05999K00
!#####################################################################!!06002
!#                                                                   #!!06003
!#                  PSTM^FRMT^B24^T0^POS^TRAN                        #!!06004
!#                                                                   #!!06005
!#    NARRATIVE : THIS PROCEDURE FORMATS A PSTM TRANSACTION CODE AND #!!06006
!#       ACCOUNT TYPE INTO AN ISO EXTERNAL PROCESSING CODE AND       #!!06007
!#       CATEGORY.                                                   #!!06008
!#                                                                   #!!06009
!#    INPUT PARAMETERS:                                              #!!06010
!#       SEM           : POINTER TO BIC ISO EXTERNAL SEM.            #!!06011
!#                                                                   #!!06012
!#    OUTPUT PARAMETERS:                                             #!!06013
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!06014
!#                                                                   #!!06015
!#####################################################################!!06016
int proc pstm^frmt^b24^to^pos^tran( pstm, sem );                       !06017
struct   .pstm( pstm^def );                                            !06018
struct   .sem( sem^def );                                              !06019
    begin                                                              !06020
    wlform( inv^tran,                                                  !06021
    "INVALID Transaction Code Received \\ from BASE24-pos" )           !06022
    wlform( inv^card,                                                  !06023
    "INVALID Card Type Received \ from BASE24-pos" )                   !06024
    wlform( inv^acct,                                                  !06025
    "INVALID Account Type Received \\ from BASE24-pos" )               !06026
                                                                       !06027
    define    pstm^code^d( i ) = tran^tbl[ ( i ) * 4 + 0 ]#,           !06028
              sem^code^d( i )  = tran^tbl[ ( i ) * 4 + 2 ]#;           !06029
                                                                       !06030
    int       x;                                                       !06031
                                                                       !06032
    string    tran^tbl = 'p' := [                                      !06033
    !                                                                 !!06034
    !        + -  BASE24 Transaction Code        + - BIC ISO Tran Code!!06035
    !        |                                   |                    !!06036
    !        v                                   v                    !!06037
           "10",  ! Normal Purchase        !   "00",                   !06038
           "11",  ! Pre-Auth Purchase      !   "00",                   !06039
           "12",  ! Pre-Auth Purchase Cmpl.!   "00",                   !06040
           "13",  ! Mail/Phone Order       !   "80",                   !06041
           "14",  ! Merchandise Return     !   "20",                   !06042
           "15",  ! Cash Advanceds         !   "01",                   !06043
           "16",  ! Card Verification      !   "81",                   !06044
           "17",  ! Balance Inquiry        !   "31",                   !06045
           "18",  ! Purchase with Cash Back!   "09",                   !06046
           "19",  ! Check Verification     !   "04",                   !06047
                                                                       !06048`00
                                                                       !06048`01
           "20",  ! Check Guarantee        !   "03",                   !06048`02
           "21",  ! Adj - Purchase         !   "22",                   !06048`03
           "22",  ! Adj - Merchandise Retrn!   "02",                   !06048`04
                                                                       !06048`05
           "23",  ! Adj - Cash Advance     !   "14",                   !06051
           "24",  ! Adj - Purc. /w csh back!   "19",                   !06052
            0 ];                                                       !06053
                                                                       !06054
    define    pstm^card^typ^d( i )  = acct^tbl[ ( i ) * 7 + 0 ]#,      !06055
              pstm^acct^typ^d( i )  = acct^tbl[ ( i ) * 7 + 1 ]#,      !06056
              sem^from^acct^d( i )  = acct^tbl[ ( i ) * 7 + 3 ]#,      !06057
              sem^to^acct^d( i )    = acct^tbl[ ( i ) * 7 + 5 ]#;      !06058
                                                                       !06059
    string    acct^tbl = 'p' := [                                      !06060
    !                                                                 !!06061
    !        + - BASE24 Card Type                                     !!06062
    !        :    + - BASE24 Account Type                             !!06063
    !        :    :     + - ISO From Acct. Type                       !!06064
    !        :    :     :      + - ISO To Acct. Typ                   !!06065
    !        :    :     :      :                                      !!06066
    !        v    v     v      v                                      !!06067
            "0", "00", "00",  "00", ! None   None                     !!06068
            "0", "01", "00",  "00", ! None   DDA                      !!06069
            "0", "11", "00",  "00", ! None   Savings                  !!06070
            "0", "31", "00",  "00", ! None   Credit                   !!06071
            "1", "00", "00",  "00", ! Cr.Crd None                     !!06072
            "1", "01", "00",  "20", ! Cr.Crd DDA                      !!06073
            "1", "11", "00",  "10", ! Cr.Crd Savings                  !!06074
            "1", "31", "00",  "30", ! Cr.Crd Credit                   !!06075
            "2", "00", "00",  "00", ! Db.Crd None                     !!06076
            "2", "01", "20",  "00", ! Db.Crd DDA                      !!06077
            "2", "11", "10",  "00", ! Db.Crd Savings                  !!06078
            "2", "31", "30",  "00", ! Db.Crd Credit                   !!06079
             0 ];                                                      !06080
                                                                       !06081
    !                                                                 !!06082
    ! Verify the transaction code                                     !!06083
    !                                                                 !!06084
    x := -1;                                                           !06085
    while pstm^code^d( x:=x+1 ) and  pstm.tran.tran^cde  <>            !06086
          pstm^code^d( x ) for $len( pstm.tran.tran^cde.tc ) do;       !06087
                                                                       !06088
    if  not pstm^code^d( x ) then                                      !06089
        begin                                                          !06090
        call logmessage^( 1185, , @inv^tran, net.myname, 2,            !06091
            @pos^prod^g, @pstm.tran.tran^cde.tc );                     !06092
        return false;                                                  !06093
        end;                                                           !06094
                                                                       !06095
    ! Assign the transaction code                                     !!06096
                                                                       !06097
    movl( psem.proc^cde.tran^cde, sem^code^d( x ),                     !06098
        $len( psem.proc^cde.tran^cde ) );                              !06099
                                                                       !06100
    if  pstm^pre^auth^compl^d( pstm ) then                             !06101
        movd ( psem.pt^tran^spcl^cde, "06" );                          !06102
   !                                                                  !!06103
   ! Verify the Card Type and Account Type                            !!06104
   !                                                                  !!06105
    x := -1;                                                           !06106
    while pstm^card^typ^d( x:=x+1 ) and pstm.tran.tran^cde.t <>        !06107
          pstm^card^typ^d( x ) for $len( pstm.tran.tran^cde.t ) do;    !06108
                                                                       !06109
    if  pstm^card^typ^d( x )  then                                     !06110
        begin                                                          !06111
                                                                       !B0611100
        if bici_g.supprs^b24^to^pos^acct^typ then                      !B0611101
            begin                                                      !B0611102
            !                                                         !!B0611103
            ! Suppress account type mapping                           !!B0611104
            ! LCONF: POS-B24-TO-POS-ACCT-TYP-SUPPRS                   !!B0611105
            !                                                         !!B0611106
            movd( psem.proc^cde.from^acct^typ, "00" );                 !B0611107
            movd( psem.proc^cde.to^acct^typ, "00" );                   !B0611108
            move( psem.pri^rsrvd2^prvt.pos.category,                   !B0611109
                  pstm.tran.tran^cde.c );                              !B061110A
            end                                                        !B061110B
        else                                                           !B061110C
            begin                                                      !B061110D
            while pstm^card^typ^d( x ) and                             !B061110E
                  ( pstm.tran.tran^cde.aa <> pstm^acct^typ^d( x ) for  !B061110F
                        $len( pstm.tran.tran^cde.aa ) )                !B061110G
                do x := x + 1;                                         !B061110H
                                                                       !B061110I
            if pstm^acct^typ^d( x )  then                              !B061110J
                begin                                                  !B061110K
                movl( psem.proc^cde.from^acct^typ,                     !B061110L
                      sem^from^acct^d( x ),                            !B061110M
                      $len( psem.proc^cde.from^acct^typ ) );           !B061110N
                movl( psem.proc^cde.to^acct^typ,                       !B061110O
                      sem^to^acct^d( x ),                              !B061110P
                      $len( psem.proc^cde.to^acct^typ ) );             !B061110Q
                move( psem.pri^rsrvd2^prvt.pos.category,               !B061110R
                      pstm.tran.tran^cde.c );                          !B061110S
                end                                                    !B061110T
            else                                                       !B061110U
                begin                                                  !B061110V
                call logmessage^( 1190, , @inv^acct, net.myname, 2,    !B061110W
                    @pos^prod^g, @pstm.tran.tran^cde.aa );             !B061110X
                return false;                                          !B061110Y
                end;                                                   !B061110Z
            end;                                                       !B061110a
                                                                       !B061110b
                                                                       !B0611200
                                                                       !B0611201
                                                                       !B0611202
        end                                                            !06131
    else                                                               !06132
        begin                                                          !06133
        call logmessage^( 1195, , @inv^card, net.myname, 2,            !06134
            @pos^prod^g, @pstm.tran.tran^cde.t );                      !06135
        return false;                                                  !06136
        end;                                                           !06137
                                                                       !06138
!*********************************************************************!
!* BEGIN RPQ #VT - Verificacion de Tarjetas                    -     *!
!*********************************************************************!
   if  pstm.tran.tran^cde.tc = "16" then
       begin
        psem.proc^cde.tran^cde.byte[0] ':=' "00";
       end;
!*********************************************************************!
!* END   RPQ #VT - Verificacion de Tarjetas                    -     *!
!*********************************************************************!

    return true;                                                       !06139
    end;                                                               !06140
?section pstm^frmt^b24^to^prikey                                       !06141
?page "                                 - pstm^frmt^b24^to^prikey"     !06141K00
!#####################################################################!!06144
!#                                                                   #!!06145
!#                   PSTM^FRMT^B24^T0^PRIKEY                         #!!06146
!#                                                                   #!!06147
!#    NARRATIVE : THIS PROCEDURE FORMATS A TRANSACTION PRIMARY KEY   #!!06148
!#       FROM THE BASE24 INTERNAL POS MESSAGE.                       #!!06149
!#                                                                   #!!06150
!#    INPUT PARAMETERS:                                              #!!06151
!#       PSTM          : POINTER TO BASE24 INTERNAL POS MESSAGE      #!!06152
!#                                                                   #!!06153
!#    OUTPUT PARAMETERS:                                             #!!06154
!#       PRIKEY        : POINTER TO TRANSACTION PRIMARY KEY          #!!06155
!#                                                                   #!!06156
!#####################################################################!!06157
proc pstm^frmt^b24^to^prikey( pstm, prikey );                          !06158
int .pstm( pstm^def );                                                 !06159
int .prikey( prikey^def );                                             !06160
    begin                                                              !06161
    int  pan^lgth;                                                     !06162
                                                                       !06163
    init ( prikey, "  ", wlen( prikey^def ) );                         !06164
    set  ( pan^lgth,   $len( prikey.pan )   );                         !06165
    call hiswutil^extract^track2^info( pstm.tran.track2,               !06166
        $len( pstm.tran.track2 ), prikey.pan, pan^lgth );              !06167
                                                                       !06167K00
                                                                       !06167K01
    if not pan^lgth then                                               !06167K02
        init^( prikey.pan, "0" );                                      !06167K03
                                                                       !06167K04
                                                                       !06167K05
    move ( prikey.ref^num,  pstm.seq^num        );                     !06168
    move ( prikey.term^id,  pstm.term^id        );                     !06169
    mov^ ( prikey.tran^dat, pstm.tran^dat.mm    );                     !06170
                                                                       !06171
    call ascii^double( pstm.tran^tim, 4, prikey.tran^tim );            !06172
    end;                                                               !06173
                                                                       !06174K00
                                                                       !06174K01
